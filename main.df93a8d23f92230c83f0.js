(self.webpackChunkmister_dex = self.webpackChunkmister_dex || []).push([[179], { 8255: t => { function e(t) { return Promise.resolve().then(() => { var e = new Error("Cannot find module '" + t + "'"); throw e.code = "MODULE_NOT_FOUND", e }) } e.keys = () => [], e.resolve = e, e.id = 8255, t.exports = e }, 5366: (t, e, n) => { "use strict"; n.d(e, { deG: () => xn, tb: () => Pp, AFp: () => Sp, ip1: () => wp, CZH: () => Ep, hGG: () => Ef, z2F: () => df, n4l: () => L, sBO: () => wh, Sil: () => Up, wA2: () => dp, _Vd: () => Hu, EJc: () => Ip, Xek: () => hp, SBq: () => Ku, qLn: () => bs, vpe: () => bd, gxx: () => xo, tBr: () => er, XFs: () => A, OlP: () => Cn, zs3: () => Vo, IIB: () => fp, ZZ4: () => fh, aQg: () => mh, soG: () => Ap, LVF: () => vp, YKP: () => Ih, v3s: () => ff, h0i: () => Ah, PXZ: () => af, R0b: () => qp, FiY: () => nr, r_U: () => gp, Lbi: () => Tp, g9A: () => Op, E6H: () => pp, Qsj: () => Ju, FYo: () => Qu, JOm: () => Ps, Tiy: () => th, q3G: () => is, PiD: () => rr, tp0: () => sr, EAV: () => _f, Rgc: () => Oh, dDg: () => Kp, DyG: () => Tn, GfV: () => eh, s_b: () => Mh, ifc: () => N, eFA: () => lf, G48: () => sf, Gpc: () => p, X6Q: () => rf, _c5: () => bf, VLi: () => Jp, c2e: () => kp, zSh: () => To, wAp: () => Pc, vHH: () => m, EiD: () => rs, mCW: () => Ur, qzn: () => Tr, JVY: () => kr, pB0: () => Mr, eBb: () => Ir, L6k: () => Ar, LAX: () => Rr, cg1: () => xc, Tjo: () => vf, kL8: () => Oc, yhl: () => Pr, dqk: () => B, sIi: () => ta, CqO: () => qa, QGY: () => Va, F4k: () => Ba, zlt: () => Hh, RDi: () => At, AaK: () => u, z3N: () => Or, qOj: () => $o, TTD: () => Et, _Bn: () => qu, xp6: () => Ci, uIk: () => la, Tol: () => Sl, ekj: () => bl, Suo: () => Dd, Xpm: () => J, lG2: () => ot, Yz7: () => w, cJS: () => E, oAB: () => rt, Yjl: () => at, Y36: () => ka, _UZ: () => La, BQk: () => Fa, ynx: () => Na, qZA: () => Da, TgZ: () => Ma, EpF: () => Ua, n5z: () => pn, Ikx: () => bc, LFG: () => Qn, $8M: () => gn, NdJ: () => $a, CRH: () => Ld, oxw: () => Wa, ALo: () => hd, lcZ: () => dd, xi3: () => pd, Q6J: () => Ia, DdM: () => Kh, VKq: () => Yh, iGM: () => Rd, MAs: () => Pa, CHM: () => Qt, LSH: () => ls, kYT: () => st, YNc: () => Ta, _uU: () => Nl, Oqu: () => Fl, hij: () => jl, AsE: () => Ul }); var r = n(5959), s = n(7570), i = n(8318), o = n(1906), a = n(1055); function l(t) { for (let e in t) if (t[e] === l) return e; throw Error("Could not find renamed property on target object.") } function c(t, e) { for (const n in e) e.hasOwnProperty(n) && !t.hasOwnProperty(n) && (t[n] = e[n]) } function u(t) { if ("string" == typeof t) return t; if (Array.isArray(t)) return "[" + t.map(u).join(", ") + "]"; if (null == t) return "" + t; if (t.overriddenName) return `${t.overriddenName}`; if (t.name) return `${t.name}`; const e = t.toString(); if (null == e) return "" + e; const n = e.indexOf("\n"); return -1 === n ? e : e.substring(0, n) } function h(t, e) { return null == t || "" === t ? null === e ? "" : e : null == e || "" === e ? t : t + " " + e } const d = l({ __forward_ref__: l }); function p(t) { return t.__forward_ref__ = p, t.toString = function () { return u(this()) }, t } function f(t) { return g(t) ? t() : t } function g(t) { return "function" == typeof t && t.hasOwnProperty(d) && t.__forward_ref__ === p } class m extends Error { constructor(t, e) { super(function (t, e) { return `${t ? `NG0${t}: ` : ""}${e}` }(t, e)), this.code = t } } function _(t) { return "string" == typeof t ? t : null == t ? "" : String(t) } function y(t) { return "function" == typeof t ? t.name || t.toString() : "object" == typeof t && null != t && "function" == typeof t.type ? t.type.name || t.type.toString() : _(t) } function v(t, e) { const n = e ? ` in ${e}` : ""; throw new m("201", `No provider for ${y(t)} found${n}`) } function b(t, e, n, r) { throw new Error(`ASSERTION ERROR: ${t}` + (null == r ? "" : ` [Expected=> ${n} ${r} ${e} <=Actual]`)) } function w(t) { return { token: t.token, providedIn: t.providedIn || null, factory: t.factory, value: void 0 } } function E(t) { return { providers: t.providers || [], imports: t.imports || [] } } function S(t) { return C(t, O) || C(t, P) } function C(t, e) { return t.hasOwnProperty(e) ? t[e] : null } function x(t) { return t && (t.hasOwnProperty(T) || t.hasOwnProperty(k)) ? t[T] : null } const O = l({ "\u0275prov": l }), T = l({ "\u0275inj": l }), P = l({ ngInjectableDef: l }), k = l({ ngInjectorDef: l }); var A = function (t) { return t[t.Default = 0] = "Default", t[t.Host = 1] = "Host", t[t.Self = 2] = "Self", t[t.SkipSelf = 4] = "SkipSelf", t[t.Optional = 8] = "Optional", t }({}); let I; function R(t) { const e = I; return I = t, e } function M(t, e, n) { const r = S(t); return r && "root" == r.providedIn ? void 0 === r.value ? r.value = r.factory() : r.value : n & A.Optional ? null : void 0 !== e ? e : void v(u(t), "Injector") } function D(t) { return { toString: t }.toString() } var L = function (t) { return t[t.OnPush = 0] = "OnPush", t[t.Default = 1] = "Default", t }({}), N = function (t) { return t[t.Emulated = 0] = "Emulated", t[t.None = 2] = "None", t[t.ShadowDom = 3] = "ShadowDom", t }({}); const F = "undefined" != typeof globalThis && globalThis, j = "undefined" != typeof window && window, U = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self, V = "undefined" != typeof global && global, B = F || V || j || U, q = {}, $ = [], z = l({ "\u0275cmp": l }), H = l({ "\u0275dir": l }), G = l({ "\u0275pipe": l }), Z = l({ "\u0275mod": l }), W = l({ "\u0275loc": l }), K = l({ "\u0275fac": l }), Y = l({ __NG_ELEMENT_ID__: l }); let Q = 0; function J(t) { return D(() => { const e = {}, n = { type: t.type, providersResolver: null, decls: t.decls, vars: t.vars, factory: null, template: t.template || null, consts: t.consts || null, ngContentSelectors: t.ngContentSelectors, hostBindings: t.hostBindings || null, hostVars: t.hostVars || 0, hostAttrs: t.hostAttrs || null, contentQueries: t.contentQueries || null, declaredInputs: e, inputs: null, outputs: null, exportAs: t.exportAs || null, onPush: t.changeDetection === L.OnPush, directiveDefs: null, pipeDefs: null, selectors: t.selectors || $, viewQuery: t.viewQuery || null, features: t.features || null, data: t.data || {}, encapsulation: t.encapsulation || N.Emulated, id: "c", styles: t.styles || $, _: null, setInput: null, schemas: t.schemas || null, tView: null }, r = t.directives, s = t.features, i = t.pipes; return n.id += Q++, n.inputs = it(t.inputs, e), n.outputs = it(t.outputs), s && s.forEach(t => t(n)), n.directiveDefs = r ? () => ("function" == typeof r ? r() : r).map(tt) : null, n.pipeDefs = i ? () => ("function" == typeof i ? i() : i).map(et) : null, n }) } function X(t, e, n) { const r = t.\u0275cmp; r.directiveDefs = () => e.map(tt), r.pipeDefs = () => n.map(et) } function tt(t) { return lt(t) || ct(t) } function et(t) { return ut(t) } const nt = {}; function rt(t) { return D(() => { const e = { type: t.type, bootstrap: t.bootstrap || $, declarations: t.declarations || $, imports: t.imports || $, exports: t.exports || $, transitiveCompileScopes: null, schemas: t.schemas || null, id: t.id || null }; return null != t.id && (nt[t.id] = t.type), e }) } function st(t, e) { return D(() => { const n = ht(t, !0); n.declarations = e.declarations || $, n.imports = e.imports || $, n.exports = e.exports || $ }) } function it(t, e) { if (null == t) return q; const n = {}; for (const r in t) if (t.hasOwnProperty(r)) { let s = t[r], i = s; Array.isArray(s) && (i = s[1], s = s[0]), n[s] = r, e && (e[s] = i) } return n } const ot = J; function at(t) { return { type: t.type, name: t.name, factory: null, pure: !1 !== t.pure, onDestroy: t.type.prototype.ngOnDestroy || null } } function lt(t) { return t[z] || null } function ct(t) { return t[H] || null } function ut(t) { return t[G] || null } function ht(t, e) { const n = t[Z] || null; if (!n && !0 === e) throw new Error(`Type ${u(t)} does not have '\u0275mod' property.`); return n } const dt = 20, pt = 10; function ft(t) { return Array.isArray(t) && "object" == typeof t[1] } function gt(t) { return Array.isArray(t) && !0 === t[1] } function mt(t) { return 0 != (8 & t.flags) } function _t(t) { return 2 == (2 & t.flags) } function yt(t) { return 1 == (1 & t.flags) } function vt(t) { return null !== t.template } function bt(t, e) { return t.hasOwnProperty(K) ? t[K] : null } class wt { constructor(t, e, n) { this.previousValue = t, this.currentValue = e, this.firstChange = n } isFirstChange() { return this.firstChange } } function Et() { return St } function St(t) { return t.type.prototype.ngOnChanges && (t.setInput = xt), Ct } function Ct() { const t = Ot(this), e = null == t ? void 0 : t.current; if (e) { const n = t.previous; if (n === q) t.previous = e; else for (let t in e) n[t] = e[t]; t.current = null, this.ngOnChanges(e) } } function xt(t, e, n, r) { const s = Ot(t) || function (t, e) { return t.__ngSimpleChanges__ = e }(t, { previous: q, current: null }), i = s.current || (s.current = {}), o = s.previous, a = this.declaredInputs[n], l = o[a]; i[a] = new wt(l && l.currentValue, e, o === q), t[r] = e } function Ot(t) { return t.__ngSimpleChanges__ || null } Et.ngInherit = !0; const Tt = "http://www.w3.org/2000/svg", Pt = "http://www.w3.org/1998/MathML/"; let kt; function At(t) { kt = t } function It() { return void 0 !== kt ? kt : "undefined" != typeof document ? document : void 0 } function Rt(t) { return !!t.listen } const Mt = { createRenderer: (t, e) => It() }; function Dt(t) { for (; Array.isArray(t);)t = t[0]; return t } function Lt(t, e) { return Dt(e[t]) } function Nt(t, e) { return Dt(e[t.index]) } function Ft(t, e) { return t.data[e] } function jt(t, e) { return t[e] } function Ut(t, e) { const n = e[t]; return ft(n) ? n : n[0] } function Vt(t) { return 4 == (4 & t[2]) } function Bt(t) { return 128 == (128 & t[2]) } function qt(t, e) { return null == e ? null : t[e] } function $t(t) { t[18] = 0 } function zt(t, e) { t[5] += e; let n = t, r = t[3]; for (; null !== r && (1 === e && 1 === n[5] || -1 === e && 0 === n[5]);)r[5] += e, n = r, r = r[3] } const Ht = { lFrame: we(null), bindingsEnabled: !0, isInCheckNoChangesMode: !1 }; function Gt() { return Ht.bindingsEnabled } function Zt() { Ht.bindingsEnabled = !0 } function Wt() { Ht.bindingsEnabled = !1 } function Kt() { return Ht.lFrame.lView } function Yt() { return Ht.lFrame.tView } function Qt(t) { return Ht.lFrame.contextLView = t, t[8] } function Jt() { let t = Xt(); for (; null !== t && 64 === t.type;)t = t.parent; return t } function Xt() { return Ht.lFrame.currentTNode } function te() { const t = Ht.lFrame, e = t.currentTNode; return t.isParent ? e : e.parent } function ee(t, e) { const n = Ht.lFrame; n.currentTNode = t, n.isParent = e } function ne() { return Ht.lFrame.isParent } function re() { Ht.lFrame.isParent = !1 } function se() { return Ht.isInCheckNoChangesMode } function ie(t) { Ht.isInCheckNoChangesMode = t } function oe() { const t = Ht.lFrame; let e = t.bindingRootIndex; return -1 === e && (e = t.bindingRootIndex = t.tView.bindingStartIndex), e } function ae() { return Ht.lFrame.bindingIndex } function le(t) { return Ht.lFrame.bindingIndex = t } function ce() { return Ht.lFrame.bindingIndex++ } function ue(t) { const e = Ht.lFrame, n = e.bindingIndex; return e.bindingIndex = e.bindingIndex + t, n } function he(t) { Ht.lFrame.inI18n = t } function de(t, e) { const n = Ht.lFrame; n.bindingIndex = n.bindingRootIndex = t, pe(e) } function pe(t) { Ht.lFrame.currentDirectiveIndex = t } function fe(t) { const e = Ht.lFrame.currentDirectiveIndex; return -1 === e ? null : t[e] } function ge() { return Ht.lFrame.currentQueryIndex } function me(t) { Ht.lFrame.currentQueryIndex = t } function _e(t) { const e = t[1]; return 2 === e.type ? e.declTNode : 1 === e.type ? t[6] : null } function ye(t, e, n) { if (n & A.SkipSelf) { let r = e, s = t; for (; r = r.parent, !(null !== r || n & A.Host || (r = _e(s), null === r) || (s = s[15], 10 & r.type));); if (null === r) return !1; e = r, t = s } const r = Ht.lFrame = be(); return r.currentTNode = e, r.lView = t, !0 } function ve(t) { const e = be(), n = t[1]; Ht.lFrame = e, e.currentTNode = n.firstChild, e.lView = t, e.tView = n, e.contextLView = t, e.bindingIndex = n.bindingStartIndex, e.inI18n = !1 } function be() { const t = Ht.lFrame, e = null === t ? null : t.child; return null === e ? we(t) : e } function we(t) { const e = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: t, child: null, inI18n: !1 }; return null !== t && (t.child = e), e } function Ee() { const t = Ht.lFrame; return Ht.lFrame = t.parent, t.currentTNode = null, t.lView = null, t } const Se = Ee; function Ce() { const t = Ee(); t.isParent = !0, t.tView = null, t.selectedIndex = -1, t.contextLView = null, t.elementDepthCount = 0, t.currentDirectiveIndex = -1, t.currentNamespace = null, t.bindingRootIndex = -1, t.bindingIndex = -1, t.currentQueryIndex = 0 } function xe() { return Ht.lFrame.selectedIndex } function Oe(t) { Ht.lFrame.selectedIndex = t } function Te() { const t = Ht.lFrame; return Ft(t.tView, t.selectedIndex) } function Pe() { Ht.lFrame.currentNamespace = Tt } function ke() { Ht.lFrame.currentNamespace = Pt } function Ae() { Ht.lFrame.currentNamespace = null } function Ie(t, e) { for (let n = e.directiveStart, r = e.directiveEnd; n < r; n++) { const e = t.data[n].type.prototype, { ngAfterContentInit: r, ngAfterContentChecked: s, ngAfterViewInit: i, ngAfterViewChecked: o, ngOnDestroy: a } = e; r && (t.contentHooks || (t.contentHooks = [])).push(-n, r), s && ((t.contentHooks || (t.contentHooks = [])).push(n, s), (t.contentCheckHooks || (t.contentCheckHooks = [])).push(n, s)), i && (t.viewHooks || (t.viewHooks = [])).push(-n, i), o && ((t.viewHooks || (t.viewHooks = [])).push(n, o), (t.viewCheckHooks || (t.viewCheckHooks = [])).push(n, o)), null != a && (t.destroyHooks || (t.destroyHooks = [])).push(n, a) } } function Re(t, e, n) { Le(t, e, 3, n) } function Me(t, e, n, r) { (3 & t[2]) === n && Le(t, e, n, r) } function De(t, e) { let n = t[2]; (3 & n) === e && (n &= 2047, n += 1, t[2] = n) } function Le(t, e, n, r) { const s = null != r ? r : -1, i = e.length - 1; let o = 0; for (let a = void 0 !== r ? 65535 & t[18] : 0; a < i; a++)if ("number" == typeof e[a + 1]) { if (o = e[a], null != r && o >= r) break } else e[a] < 0 && (t[18] += 65536), (o < s || -1 == s) && (Ne(t, n, e, a), t[18] = (4294901760 & t[18]) + a + 2), a++ } function Ne(t, e, n, r) { const s = n[r] < 0, i = n[r + 1], o = t[s ? -n[r] : n[r]]; if (s) { if (t[2] >> 11 < t[18] >> 16 && (3 & t[2]) === e) { t[2] += 2048; try { i.call(o) } finally { } } } else try { i.call(o) } finally { } } const Fe = -1; class je { constructor(t, e, n) { this.factory = t, this.resolving = !1, this.canSeeViewProviders = e, this.injectImpl = n } } function Ue(t, e, n) { const r = Rt(t); let s = 0; for (; s < n.length;) { const i = n[s]; if ("number" == typeof i) { if (0 !== i) break; s++; const o = n[s++], a = n[s++], l = n[s++]; r ? t.setAttribute(e, a, l, o) : e.setAttributeNS(o, a, l) } else { const o = i, a = n[++s]; Be(o) ? r && t.setProperty(e, o, a) : r ? t.setAttribute(e, o, a) : e.setAttribute(o, a), s++ } } return s } function Ve(t) { return 3 === t || 4 === t || 6 === t } function Be(t) { return 64 === t.charCodeAt(0) } function qe(t, e) { if (null === e || 0 === e.length); else if (null === t || 0 === t.length) t = e.slice(); else { let n = -1; for (let r = 0; r < e.length; r++) { const s = e[r]; "number" == typeof s ? n = s : 0 === n || $e(t, n, s, null, -1 === n || 2 === n ? e[++r] : null) } } return t } function $e(t, e, n, r, s) { let i = 0, o = t.length; if (-1 === e) o = -1; else for (; i < t.length;) { const n = t[i++]; if ("number" == typeof n) { if (n === e) { o = -1; break } if (n > e) { o = i - 1; break } } } for (; i < t.length;) { const e = t[i]; if ("number" == typeof e) break; if (e === n) { if (null === r) return void (null !== s && (t[i + 1] = s)); if (r === t[i + 1]) return void (t[i + 2] = s) } i++, null !== r && i++, null !== s && i++ } -1 !== o && (t.splice(o, 0, e), i = o + 1), t.splice(i++, 0, n), null !== r && t.splice(i++, 0, r), null !== s && t.splice(i++, 0, s) } function ze(t) { return t !== Fe } function He(t) { return 32767 & t } function Ge(t, e) { let n = t >> 16, r = e; for (; n > 0;)r = r[15], n--; return r } let Ze = !0; function We(t) { const e = Ze; return Ze = t, e } let Ke = 0; function Ye(t, e) { const n = Je(t, e); if (-1 !== n) return n; const r = e[1]; r.firstCreatePass && (t.injectorIndex = e.length, Qe(r.data, t), Qe(e, null), Qe(r.blueprint, null)); const s = Xe(t, e), i = t.injectorIndex; if (ze(s)) { const t = He(s), n = Ge(s, e), r = n[1].data; for (let s = 0; s < 8; s++)e[i + s] = n[t + s] | r[t + s] } return e[i + 8] = s, i } function Qe(t, e) { t.push(0, 0, 0, 0, 0, 0, 0, 0, e) } function Je(t, e) { return -1 === t.injectorIndex || t.parent && t.parent.injectorIndex === t.injectorIndex || null === e[t.injectorIndex + 8] ? -1 : t.injectorIndex } function Xe(t, e) { if (t.parent && -1 !== t.parent.injectorIndex) return t.parent.injectorIndex; let n = 0, r = null, s = e; for (; null !== s;) { const t = s[1], e = t.type; if (r = 2 === e ? t.declTNode : 1 === e ? s[6] : null, null === r) return Fe; if (n++, s = s[15], -1 !== r.injectorIndex) return r.injectorIndex | n << 16 } return Fe } function tn(t, e, n) { !function (t, e, n) { let r; "string" == typeof n ? r = n.charCodeAt(0) || 0 : n.hasOwnProperty(Y) && (r = n[Y]), null == r && (r = n[Y] = Ke++); const s = 255 & r; e.data[t + (s >> 5)] |= 1 << s }(t, e, n) } function en(t, e, n) { if (n & A.Optional) return t; v(e, "NodeInjector") } function nn(t, e, n, r) { if (n & A.Optional && void 0 === r && (r = null), 0 == (n & (A.Self | A.Host))) { const s = t[9], i = R(void 0); try { return s ? s.get(e, r, n & A.Optional) : M(e, r, n & A.Optional) } finally { R(i) } } return en(r, e, n) } function rn(t, e, n, r = A.Default, s) { if (null !== t) { const i = function (t) { if ("string" == typeof t) return t.charCodeAt(0) || 0; const e = t.hasOwnProperty(Y) ? t[Y] : void 0; return "number" == typeof e ? e >= 0 ? 255 & e : on : e }(n); if ("function" == typeof i) { if (!ye(e, t, r)) return r & A.Host ? en(s, n, r) : nn(e, n, r, s); try { const t = i(r); if (null != t || r & A.Optional) return t; v(n) } finally { Se() } } else if ("number" == typeof i) { let s = null, o = Je(t, e), a = Fe, l = r & A.Host ? e[16][6] : null; for ((-1 === o || r & A.SkipSelf) && (a = -1 === o ? Xe(t, e) : e[o + 8], a !== Fe && hn(r, !1) ? (s = e[1], o = He(a), e = Ge(a, e)) : o = -1); -1 !== o;) { const t = e[1]; if (un(i, o, t.data)) { const t = an(o, e, n, s, r, l); if (t !== sn) return t } a = e[o + 8], a !== Fe && hn(r, e[1].data[o + 8] === l) && un(i, o, e) ? (s = t, o = He(a), e = Ge(a, e)) : o = -1 } } } return nn(e, n, r, s) } const sn = {}; function on() { return new dn(Jt(), Kt()) } function an(t, e, n, r, s, i) { const o = e[1], a = o.data[t + 8], l = ln(a, o, n, null == r ? _t(a) && Ze : r != o && 0 != (3 & a.type), s & A.Host && i === a); return null !== l ? cn(e, o, l, a) : sn } function ln(t, e, n, r, s) { const i = t.providerIndexes, o = e.data, a = 1048575 & i, l = t.directiveStart, c = i >> 20, u = s ? a + c : t.directiveEnd; for (let h = r ? a : a + c; h < u; h++) { const t = o[h]; if (h < l && n === t || h >= l && t.type === n) return h } if (s) { const t = o[l]; if (t && vt(t) && t.type === n) return l } return null } function cn(t, e, n, r) { let s = t[n]; const i = e.data; if (s instanceof je) { const o = s; o.resolving && function (t, e) { throw new m("200", `Circular dependency in DI detected for ${t}`) }(y(i[n])); const a = We(o.canSeeViewProviders); o.resolving = !0; const l = o.injectImpl ? R(o.injectImpl) : null; ye(t, r, A.Default); try { s = t[n] = o.factory(void 0, i, t, r), e.firstCreatePass && n >= r.directiveStart && function (t, e, n) { const { ngOnChanges: r, ngOnInit: s, ngDoCheck: i } = e.type.prototype; if (r) { const r = St(e); (n.preOrderHooks || (n.preOrderHooks = [])).push(t, r), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(t, r) } s && (n.preOrderHooks || (n.preOrderHooks = [])).push(0 - t, s), i && ((n.preOrderHooks || (n.preOrderHooks = [])).push(t, i), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(t, i)) }(n, i[n], e) } finally { null !== l && R(l), We(a), o.resolving = !1, Se() } } return s } function un(t, e, n) { return !!(n[e + (t >> 5)] & 1 << t) } function hn(t, e) { return !(t & A.Self || t & A.Host && e) } class dn { constructor(t, e) { this._tNode = t, this._lView = e } get(t, e) { return rn(this._tNode, this._lView, t, void 0, e) } } function pn(t) { return D(() => { const e = t.prototype.constructor, n = e[K] || fn(e), r = Object.prototype; let s = Object.getPrototypeOf(t.prototype).constructor; for (; s && s !== r;) { const t = s[K] || fn(s); if (t && t !== n) return t; s = Object.getPrototypeOf(s) } return t => new t }) } function fn(t) { return g(t) ? () => { const e = fn(f(t)); return e && e() } : bt(t) } function gn(t) { return function (t, e) { if ("class" === e) return t.classes; if ("style" === e) return t.styles; const n = t.attrs; if (n) { const t = n.length; let r = 0; for (; r < t;) { const s = n[r]; if (Ve(s)) break; if (0 === s) r += 2; else if ("number" == typeof s) for (r++; r < t && "string" == typeof n[r];)r++; else { if (s === e) return n[r + 1]; r += 2 } } } return null }(Jt(), t) } const mn = "__annotations__", _n = "__parameters__", yn = "__prop__metadata__"; function vn(t, e, n, r, s) { return D(() => { const i = bn(e); function o(...t) { if (this instanceof o) return i.call(this, ...t), this; const e = new o(...t); return function (n) { return s && s(n, ...t), (n.hasOwnProperty(mn) ? n[mn] : Object.defineProperty(n, mn, { value: [] })[mn]).push(e), r && r(n), n } } return n && (o.prototype = Object.create(n.prototype)), o.prototype.ngMetadataName = t, o.annotationCls = o, o }) } function bn(t) { return function (...e) { if (t) { const n = t(...e); for (const t in n) this[t] = n[t] } } } function wn(t, e, n) { return D(() => { const r = bn(e); function s(...t) { if (this instanceof s) return r.apply(this, t), this; const e = new s(...t); return n.annotation = e, n; function n(t, n, r) { const s = t.hasOwnProperty(_n) ? t[_n] : Object.defineProperty(t, _n, { value: [] })[_n]; for (; s.length <= r;)s.push(null); return (s[r] = s[r] || []).push(e), t } } return n && (s.prototype = Object.create(n.prototype)), s.prototype.ngMetadataName = t, s.annotationCls = s, s }) } function En(t, e, n, r) { return D(() => { const s = bn(e); function i(...t) { if (this instanceof i) return s.apply(this, t), this; const e = new i(...t); return function (n, s) { const i = n.constructor, o = i.hasOwnProperty(yn) ? i[yn] : Object.defineProperty(i, yn, { value: {} })[yn]; o[s] = o.hasOwnProperty(s) && o[s] || [], o[s].unshift(e), r && r(n, s, ...t) } } return n && (i.prototype = Object.create(n.prototype)), i.prototype.ngMetadataName = t, i.annotationCls = i, i }) } const Sn = function () { return wn("Attribute", t => ({ attributeName: t, __NG_ELEMENT_ID__: () => gn(t) })) }(); class Cn { constructor(t, e) { this._desc = t, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof e ? this.__NG_ELEMENT_ID__ = e : void 0 !== e && (this.\u0275prov = w({ token: this, providedIn: e.providedIn || "root", factory: e.factory })) } toString() { return `InjectionToken ${this._desc}` } } const xn = new Cn("AnalyzeForEntryComponents"); function On() { const t = B.ng; if (!t || !t.\u0275compilerFacade) throw new Error("Angular JIT compilation failed: '@angular/compiler' not loaded!\n  - JIT compilation is discouraged for production use-cases! Consider AOT mode instead.\n  - Did you bootstrap using '@angular/platform-browser-dynamic' or '@angular/platform-server'?\n  - Alternatively provide the compiler with 'import \"@angular/compiler\";' before bootstrapping."); return t.\u0275compilerFacade } const Tn = Function; function Pn(t) { return "function" == typeof t } function kn(t, e) { void 0 === e && (e = t); for (let n = 0; n < t.length; n++) { let r = t[n]; Array.isArray(r) ? (e === t && (e = t.slice(0, n)), kn(r, e)) : e !== t && e.push(r) } return e } function An(t, e) { t.forEach(t => Array.isArray(t) ? An(t, e) : e(t)) } function In(t, e, n) { e >= t.length ? t.push(n) : t.splice(e, 0, n) } function Rn(t, e) { return e >= t.length - 1 ? t.pop() : t.splice(e, 1)[0] } function Mn(t, e) { const n = []; for (let r = 0; r < t; r++)n.push(e); return n } function Dn(t, e, n) { let r = Nn(t, e); return r >= 0 ? t[1 | r] = n : (r = ~r, function (t, e, n, r) { let s = t.length; if (s == e) t.push(n, r); else if (1 === s) t.push(r, t[0]), t[0] = n; else { for (s--, t.push(t[s - 1], t[s]); s > e;)t[s] = t[s - 2], s--; t[e] = n, t[e + 1] = r } }(t, r, e, n)), r } function Ln(t, e) { const n = Nn(t, e); if (n >= 0) return t[1 | n] } function Nn(t, e) { return function (t, e, n) { let r = 0, s = t.length >> 1; for (; s !== r;) { const n = r + (s - r >> 1), i = t[n << 1]; if (e === i) return n << 1; i > e ? s = n : r = n + 1 } return ~(s << 1) }(t, e) } const Fn = /^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*(arguments|(?:[^()]+\(\[\],)?[^()]+\(arguments\))\)/, jn = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{/, Un = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(/, Vn = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(\)\s*{\s*super\(\.\.\.arguments\)/; class Bn { constructor(t) { this._reflect = t || B.Reflect } isReflectionEnabled() { return !0 } factory(t) { return (...e) => new t(...e) } _zipTypesAndAnnotations(t, e) { let n; n = Mn(void 0 === t ? e.length : t.length); for (let r = 0; r < n.length; r++)n[r] = void 0 === t ? [] : t[r] && t[r] != Object ? [t[r]] : [], e && null != e[r] && (n[r] = n[r].concat(e[r])); return n } _ownParameters(t, e) { if (n = t.toString(), Fn.test(n) || Vn.test(n) || jn.test(n) && !Un.test(n)) return null; var n; if (t.parameters && t.parameters !== e.parameters) return t.parameters; const r = t.ctorParameters; if (r && r !== e.ctorParameters) { const t = "function" == typeof r ? r() : r, e = t.map(t => t && t.type), n = t.map(t => t && qn(t.decorators)); return this._zipTypesAndAnnotations(e, n) } const s = t.hasOwnProperty(_n) && t[_n], i = this._reflect && this._reflect.getOwnMetadata && this._reflect.getOwnMetadata("design:paramtypes", t); return i || s ? this._zipTypesAndAnnotations(i, s) : Mn(t.length) } parameters(t) { if (!Pn(t)) return []; const e = $n(t); let n = this._ownParameters(t, e); return n || e === Object || (n = this.parameters(e)), n || [] } _ownAnnotations(t, e) { if (t.annotations && t.annotations !== e.annotations) { let e = t.annotations; return "function" == typeof e && e.annotations && (e = e.annotations), e } return t.decorators && t.decorators !== e.decorators ? qn(t.decorators) : t.hasOwnProperty(mn) ? t[mn] : null } annotations(t) { if (!Pn(t)) return []; const e = $n(t), n = this._ownAnnotations(t, e) || []; return (e !== Object ? this.annotations(e) : []).concat(n) } _ownPropMetadata(t, e) { if (t.propMetadata && t.propMetadata !== e.propMetadata) { let e = t.propMetadata; return "function" == typeof e && e.propMetadata && (e = e.propMetadata), e } if (t.propDecorators && t.propDecorators !== e.propDecorators) { const e = t.propDecorators, n = {}; return Object.keys(e).forEach(t => { n[t] = qn(e[t]) }), n } return t.hasOwnProperty(yn) ? t[yn] : null } propMetadata(t) { if (!Pn(t)) return {}; const e = $n(t), n = {}; if (e !== Object) { const t = this.propMetadata(e); Object.keys(t).forEach(e => { n[e] = t[e] }) } const r = this._ownPropMetadata(t, e); return r && Object.keys(r).forEach(t => { const e = []; n.hasOwnProperty(t) && e.push(...n[t]), e.push(...r[t]), n[t] = e }), n } ownPropMetadata(t) { return Pn(t) && this._ownPropMetadata(t, $n(t)) || {} } hasLifecycleHook(t, e) { return t instanceof Tn && e in t.prototype } guards(t) { return {} } getter(t) { return new Function("o", "return o." + t + ";") } setter(t) { return new Function("o", "v", "return o." + t + " = v;") } method(t) { return new Function("o", "args", `if (!o.${t}) throw new Error('"${t}" is undefined');\n        return o.${t}.apply(o, args);`) } importUri(t) { return "object" == typeof t && t.filePath ? t.filePath : `./${u(t)}` } resourceUri(t) { return `./${u(t)}` } resolveIdentifier(t, e, n, r) { return r } resolveEnum(t, e) { return t[e] } } function qn(t) { return t ? t.map(t => new (0, t.type.annotationCls)(...t.args ? t.args : [])) : [] } function $n(t) { const e = t.prototype ? Object.getPrototypeOf(t.prototype) : null; return (e ? e.constructor : null) || Object } const zn = {}, Hn = /\n/gm, Gn = "__source", Zn = l({ provide: String, useValue: l }); let Wn; function Kn(t) { const e = Wn; return Wn = t, e } function Yn(t, e = A.Default) { if (void 0 === Wn) throw new Error("inject() must be called from an injection context"); return null === Wn ? M(t, void 0, e) : Wn.get(t, e & A.Optional ? null : void 0, e) } function Qn(t, e = A.Default) { return (I || Yn)(f(t), e) } function Jn(t) { throw new Error("invalid") } function Xn(t) { const e = []; for (let n = 0; n < t.length; n++) { const r = f(t[n]); if (Array.isArray(r)) { if (0 === r.length) throw new Error("Arguments array must have arguments."); let t, n = A.Default; for (let e = 0; e < r.length; e++) { const s = r[e], i = s.__NG_DI_FLAG__; "number" == typeof i ? -1 === i ? t = s.token : n |= i : t = s } e.push(Qn(t, n)) } else e.push(Qn(r)) } return e } function tr(t, e) { return t.__NG_DI_FLAG__ = e, t.prototype.__NG_DI_FLAG__ = e, t } const er = tr(wn("Inject", t => ({ token: t })), -1), nr = tr(wn("Optional"), 8), rr = tr(wn("Self"), 2), sr = tr(wn("SkipSelf"), 4), ir = tr(wn("Host"), 1); let or = null; function ar() { return or = or || new Bn } function lr(t) { return ar().parameters(t).map(t => function (t) { const e = { token: null, attribute: null, host: !1, optional: !1, self: !1, skipSelf: !1 }; if (Array.isArray(t) && t.length > 0) for (let n = 0; n < t.length; n++) { const r = t[n]; if (void 0 === r) continue; const s = Object.getPrototypeOf(r); if (r instanceof nr || "Optional" === s.ngMetadataName) e.optional = !0; else if (r instanceof sr || "SkipSelf" === s.ngMetadataName) e.skipSelf = !0; else if (r instanceof rr || "Self" === s.ngMetadataName) e.self = !0; else if (r instanceof ir || "Host" === s.ngMetadataName) e.host = !0; else if (r instanceof er) e.token = r.token; else if (r instanceof Sn) { if (void 0 === r.attributeName) throw new Error("Attribute name must be defined."); e.attribute = r.attributeName } else e.token = r } else e.token = void 0 === t || Array.isArray(t) && 0 === t.length ? null : t; return e }(t)) } let cr = new Map; const ur = new Set; function hr(t) { return !!(t.templateUrl && !t.hasOwnProperty("template") || t.styleUrls && t.styleUrls.length) } let dr, pr; function fr() { if (void 0 === dr && (dr = null, B.trustedTypes)) try { dr = B.trustedTypes.createPolicy("angular", { createHTML: t => t, createScript: t => t, createScriptURL: t => t }) } catch (t) { } return dr } function gr(t) { var e; return (null === (e = fr()) || void 0 === e ? void 0 : e.createHTML(t)) || t } function mr() { if (void 0 === pr && (pr = null, B.trustedTypes)) try { pr = B.trustedTypes.createPolicy("angular#unsafe-bypass", { createHTML: t => t, createScript: t => t, createScriptURL: t => t }) } catch (t) { } return pr } function _r(t) { var e; return (null === (e = mr()) || void 0 === e ? void 0 : e.createHTML(t)) || t } function yr(t) { var e; return (null === (e = mr()) || void 0 === e ? void 0 : e.createScript(t)) || t } function vr(t) { var e; return (null === (e = mr()) || void 0 === e ? void 0 : e.createScriptURL(t)) || t } class br { constructor(t) { this.changingThisBreaksApplicationSecurity = t } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)` } } class wr extends br { getTypeName() { return "HTML" } } class Er extends br { getTypeName() { return "Style" } } class Sr extends br { getTypeName() { return "Script" } } class Cr extends br { getTypeName() { return "URL" } } class xr extends br { getTypeName() { return "ResourceURL" } } function Or(t) { return t instanceof br ? t.changingThisBreaksApplicationSecurity : t } function Tr(t, e) { const n = Pr(t); if (null != n && n !== e) { if ("ResourceURL" === n && "URL" === e) return !0; throw new Error(`Required a safe ${e}, got a ${n} (see https://g.co/ng/security#xss)`) } return n === e } function Pr(t) { return t instanceof br && t.getTypeName() || null } function kr(t) { return new wr(t) } function Ar(t) { return new Er(t) } function Ir(t) { return new Sr(t) } function Rr(t) { return new Cr(t) } function Mr(t) { return new xr(t) } function Dr(t) { const e = new Nr(t); return function () { try { return !!(new window.DOMParser).parseFromString(gr(""), "text/html") } catch (t) { return !1 } }() ? new Lr(e) : e } class Lr { constructor(t) { this.inertDocumentHelper = t } getInertBodyElement(t) { t = "<body><remove></remove>" + t; try { const e = (new window.DOMParser).parseFromString(gr(t), "text/html").body; return null === e ? this.inertDocumentHelper.getInertBodyElement(t) : (e.removeChild(e.firstChild), e) } catch (e) { return null } } } class Nr { constructor(t) { if (this.defaultDoc = t, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"), null == this.inertDocument.body) { const t = this.inertDocument.createElement("html"); this.inertDocument.appendChild(t); const e = this.inertDocument.createElement("body"); t.appendChild(e) } } getInertBodyElement(t) { const e = this.inertDocument.createElement("template"); if ("content" in e) return e.innerHTML = gr(t), e; const n = this.inertDocument.createElement("body"); return n.innerHTML = gr(t), this.defaultDoc.documentMode && this.stripCustomNsAttrs(n), n } stripCustomNsAttrs(t) { const e = t.attributes; for (let r = e.length - 1; 0 < r; r--) { const n = e.item(r).name; "xmlns:ns1" !== n && 0 !== n.indexOf("ns1:") || t.removeAttribute(n) } let n = t.firstChild; for (; n;)n.nodeType === Node.ELEMENT_NODE && this.stripCustomNsAttrs(n), n = n.nextSibling } } const Fr = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi, jr = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i; function Ur(t) { return (t = String(t)).match(Fr) || t.match(jr) ? t : "unsafe:" + t } function Vr(t) { return (t = String(t)).split(",").map(t => Ur(t.trim())).join(", ") } function Br(t) { const e = {}; for (const n of t.split(",")) e[n] = !0; return e } function qr(...t) { const e = {}; for (const n of t) for (const t in n) n.hasOwnProperty(t) && (e[t] = !0); return e } const $r = Br("area,br,col,hr,img,wbr"), zr = Br("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), Hr = Br("rp,rt"), Gr = qr(Hr, zr), Zr = qr($r, qr(zr, Br("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")), qr(Hr, Br("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")), Gr), Wr = Br("background,cite,href,itemtype,longdesc,poster,src,xlink:href"), Kr = Br("srcset"), Yr = qr(Wr, Kr, Br("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"), Br("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")), Qr = Br("script,style,template"); class Jr { constructor() { this.sanitizedSomething = !1, this.buf = [] } sanitizeChildren(t) { let e = t.firstChild, n = !0; for (; e;)if (e.nodeType === Node.ELEMENT_NODE ? n = this.startElement(e) : e.nodeType === Node.TEXT_NODE ? this.chars(e.nodeValue) : this.sanitizedSomething = !0, n && e.firstChild) e = e.firstChild; else for (; e;) { e.nodeType === Node.ELEMENT_NODE && this.endElement(e); let t = this.checkClobberedElement(e, e.nextSibling); if (t) { e = t; break } e = this.checkClobberedElement(e, e.parentNode) } return this.buf.join("") } startElement(t) { const e = t.nodeName.toLowerCase(); if (!Zr.hasOwnProperty(e)) return this.sanitizedSomething = !0, !Qr.hasOwnProperty(e); this.buf.push("<"), this.buf.push(e); const n = t.attributes; for (let r = 0; r < n.length; r++) { const t = n.item(r), e = t.name, s = e.toLowerCase(); if (!Yr.hasOwnProperty(s)) { this.sanitizedSomething = !0; continue } let i = t.value; Wr[s] && (i = Ur(i)), Kr[s] && (i = Vr(i)), this.buf.push(" ", e, '="', es(i), '"') } return this.buf.push(">"), !0 } endElement(t) { const e = t.nodeName.toLowerCase(); Zr.hasOwnProperty(e) && !$r.hasOwnProperty(e) && (this.buf.push("</"), this.buf.push(e), this.buf.push(">")) } chars(t) { this.buf.push(es(t)) } checkClobberedElement(t, e) { if (e && (t.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) throw new Error(`Failed to sanitize html because the element is clobbered: ${t.outerHTML}`); return e } } const Xr = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, ts = /([^\#-~ |!])/g; function es(t) { return t.replace(/&/g, "&amp;").replace(Xr, function (t) { return "&#" + (1024 * (t.charCodeAt(0) - 55296) + (t.charCodeAt(1) - 56320) + 65536) + ";" }).replace(ts, function (t) { return "&#" + t.charCodeAt(0) + ";" }).replace(/</g, "&lt;").replace(/>/g, "&gt;") } let ns; function rs(t, e) { let n = null; try { ns = ns || Dr(t); let r = e ? String(e) : ""; n = ns.getInertBodyElement(r); let s = 5, i = r; do { if (0 === s) throw new Error("Failed to sanitize html because the input is unstable"); s--, r = i, i = n.innerHTML, n = ns.getInertBodyElement(r) } while (r !== i); return gr((new Jr).sanitizeChildren(ss(n) || n)) } finally { if (n) { const t = ss(n) || n; for (; t.firstChild;)t.removeChild(t.firstChild) } } } function ss(t) { return "content" in t && function (t) { return t.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === t.nodeName }(t) ? t.content : null } var is = function (t) { return t[t.NONE = 0] = "NONE", t[t.HTML = 1] = "HTML", t[t.STYLE = 2] = "STYLE", t[t.SCRIPT = 3] = "SCRIPT", t[t.URL = 4] = "URL", t[t.RESOURCE_URL = 5] = "RESOURCE_URL", t }({}); function os(t) { const e = fs(); return e ? _r(e.sanitize(is.HTML, t) || "") : Tr(t, "HTML") ? _r(Or(t)) : rs(It(), _(t)) } function as(t) { const e = fs(); return e ? e.sanitize(is.STYLE, t) || "" : Tr(t, "Style") ? Or(t) : _(t) } function ls(t) { const e = fs(); return e ? e.sanitize(is.URL, t) || "" : Tr(t, "URL") ? Or(t) : Ur(_(t)) } function cs(t) { const e = fs(); if (e) return vr(e.sanitize(is.RESOURCE_URL, t) || ""); if (Tr(t, "ResourceURL")) return vr(Or(t)); throw new Error("unsafe value used in a resource URL context (see https://g.co/ng/security#xss)") } function us(t) { const e = fs(); if (e) return yr(e.sanitize(is.SCRIPT, t) || ""); if (Tr(t, "Script")) return yr(Or(t)); throw new Error("unsafe value used in a script context") } function hs(t) { return gr(t[0]) } function ds(t) { return function (t) { var e; return (null === (e = fr()) || void 0 === e ? void 0 : e.createScriptURL(t)) || t }(t[0]) } function ps(t, e, n) { return function (t, e) { return "src" === e && ("embed" === t || "frame" === t || "iframe" === t || "media" === t || "script" === t) || "href" === e && ("base" === t || "link" === t) ? cs : ls }(e, n)(t) } function fs() { const t = Kt(); return t && t[12] } function gs(t, e) { t.__ngContext__ = e } function ms(t) { const e = function (t) { return t.__ngContext__ || null }(t); return e ? Array.isArray(e) ? e : e.lView : null } function _s(t) { return t.ngDebugContext } function ys(t) { return t.ngOriginalError } function vs(t, ...e) { t.error(...e) } class bs { constructor() { this._console = console } handleError(t) { const e = this._findOriginalError(t), n = this._findContext(t), r = function (t) { return t.ngErrorLogger || vs }(t); r(this._console, "ERROR", t), e && r(this._console, "ORIGINAL ERROR", e), n && r(this._console, "ERROR CONTEXT", n) } _findContext(t) { return t ? _s(t) ? _s(t) : this._findContext(ys(t)) : null } _findOriginalError(t) { let e = ys(t); for (; e && ys(e);)e = ys(e); return e } } const ws = /^>|^->|<!--|-->|--!>|<!-$/g, Es = /(<|>)/, Ss = (() => ("undefined" != typeof requestAnimationFrame && requestAnimationFrame || setTimeout).bind(B))(); function Cs(t) { return t.ownerDocument.defaultView } function xs(t) { return t.ownerDocument } function Os(t) { return t.ownerDocument.body } function Ts(t) { return t instanceof Function ? t() : t } var Ps = function (t) { return t[t.Important = 1] = "Important", t[t.DashCase = 2] = "DashCase", t }({}); let ks; function As(t, e) { return ks(t, e) } function Is(t) { const e = t[3]; return gt(e) ? e[3] : e } function Rs(t) { return Ds(t[13]) } function Ms(t) { return Ds(t[4]) } function Ds(t) { for (; null !== t && !gt(t);)t = t[4]; return t } function Ls(t, e, n, r, s) { if (null != r) { let i, o = !1; gt(r) ? i = r : ft(r) && (o = !0, r = r[0]); const a = Dt(r); 0 === t && null !== n ? null == s ? Zs(e, n, a) : Gs(e, n, a, s || null, !0) : 1 === t && null !== n ? Gs(e, n, a, s || null, !0) : 2 === t ? ii(e, a, o) : 3 === t && e.destroyNode(a), null != i && function (t, e, n, r, s) { const i = n[7]; i !== Dt(n) && Ls(e, t, r, i, s); for (let o = pt; o < n.length; o++) { const s = n[o]; ai(s[1], s, t, e, r, i) } }(e, t, i, n, s) } } function Ns(t, e) { return Rt(t) ? t.createText(e) : t.createTextNode(e) } function Fs(t, e, n) { Rt(t) ? t.setValue(e, n) : e.textContent = n } function js(t, e) { return t.createComment(function (t) { return t.replace(ws, t => t.replace(Es, "\u200b$1\u200b")) }(e)) } function Us(t, e, n) { return Rt(t) ? t.createElement(e, n) : null === n ? t.createElement(e) : t.createElementNS(n, e) } function Vs(t, e) { const n = t[9], r = n.indexOf(e), s = e[3]; 1024 & e[2] && (e[2] &= -1025, zt(s, -1)), n.splice(r, 1) } function Bs(t, e) { if (t.length <= pt) return; const n = pt + e, r = t[n]; if (r) { const i = r[17]; null !== i && i !== t && Vs(i, r), e > 0 && (t[n - 1][4] = r[4]); const o = Rn(t, pt + e); ai(r[1], s = r, s[11], 2, null, null), s[0] = null, s[6] = null; const a = o[19]; null !== a && a.detachView(o[1]), r[3] = null, r[4] = null, r[2] &= -129 } var s; return r } function qs(t, e) { if (!(256 & e[2])) { const n = e[11]; Rt(n) && n.destroyNode && ai(t, e, n, 3, null, null), function (t) { let e = t[13]; if (!e) return $s(t[1], t); for (; e;) { let n = null; if (ft(e)) n = e[13]; else { const t = e[10]; t && (n = t) } if (!n) { for (; e && !e[4] && e !== t;)ft(e) && $s(e[1], e), e = e[3]; null === e && (e = t), ft(e) && $s(e[1], e), n = e && e[4] } e = n } }(e) } } function $s(t, e) { if (!(256 & e[2])) { e[2] &= -129, e[2] |= 256, function (t, e) { let n; if (null != t && null != (n = t.destroyHooks)) for (let r = 0; r < n.length; r += 2) { const t = e[n[r]]; if (!(t instanceof je)) { const e = n[r + 1]; if (Array.isArray(e)) for (let n = 0; n < e.length; n += 2) { const r = t[e[n]], s = e[n + 1]; try { s.call(r) } finally { } } else try { e.call(t) } finally { } } } }(t, e), function (t, e) { const n = t.cleanup, r = e[7]; let s = -1; if (null !== n) for (let i = 0; i < n.length - 1; i += 2)if ("string" == typeof n[i]) { const t = n[i + 1], o = "function" == typeof t ? t(e) : Dt(e[t]), a = r[s = n[i + 2]], l = n[i + 3]; "boolean" == typeof l ? o.removeEventListener(n[i], a, l) : l >= 0 ? r[s = l]() : r[s = -l].unsubscribe(), i += 2 } else { const t = r[s = n[i + 1]]; n[i].call(t) } if (null !== r) { for (let t = s + 1; t < r.length; t++)(0, r[t])(); e[7] = null } }(t, e), 1 === e[1].type && Rt(e[11]) && e[11].destroy(); const n = e[17]; if (null !== n && gt(e[3])) { n !== e[3] && Vs(n, e); const r = e[19]; null !== r && r.detachView(t) } } } function zs(t, e, n) { return Hs(t, e.parent, n) } function Hs(t, e, n) { let r = e; for (; null !== r && 40 & r.type;)r = (e = r).parent; if (null === r) return n[0]; if (2 & r.flags) { const e = t.data[r.directiveStart].encapsulation; if (e === N.None || e === N.Emulated) return null } return Nt(r, n) } function Gs(t, e, n, r, s) { Rt(t) ? t.insertBefore(e, n, r, s) : e.insertBefore(n, r, s) } function Zs(t, e, n) { Rt(t) ? t.appendChild(e, n) : e.appendChild(n) } function Ws(t, e, n, r, s) { null !== r ? Gs(t, e, n, r, s) : Zs(t, e, n) } function Ks(t, e) { return Rt(t) ? t.parentNode(e) : e.parentNode } function Ys(t, e, n) { return Xs(t, e, n) } function Qs(t, e, n) { return 40 & t.type ? Nt(t, n) : null } let Js, Xs = Qs; function ti(t, e) { Xs = t, Js = e } function ei(t, e, n, r) { const s = zs(t, r, e), i = e[11], o = Ys(r.parent || e[6], r, e); if (null != s) if (Array.isArray(n)) for (let a = 0; a < n.length; a++)Ws(i, s, n[a], o, !1); else Ws(i, s, n, o, !1); void 0 !== Js && Js(i, r, e, n, s) } function ni(t, e) { if (null !== e) { const n = e.type; if (3 & n) return Nt(e, t); if (4 & n) return si(-1, t[e.index]); if (8 & n) { const n = e.child; if (null !== n) return ni(t, n); { const n = t[e.index]; return gt(n) ? si(-1, n) : Dt(n) } } if (32 & n) return As(e, t)() || Dt(t[e.index]); { const n = ri(t, e); return null !== n ? Array.isArray(n) ? n[0] : ni(Is(t[16]), n) : ni(t, e.next) } } return null } function ri(t, e) { return null !== e ? t[16][6].projection[e.projection] : null } function si(t, e) { const n = pt + t + 1; if (n < e.length) { const t = e[n], r = t[1].firstChild; if (null !== r) return ni(t, r) } return e[7] } function ii(t, e, n) { const r = Ks(t, e); r && function (t, e, n, r) { Rt(t) ? t.removeChild(e, n, r) : e.removeChild(n) }(t, r, e, n) } function oi(t, e, n, r, s, i, o) { for (; null != n;) { const a = r[n.index], l = n.type; if (o && 0 === e && (a && gs(Dt(a), r), n.flags |= 4), 64 != (64 & n.flags)) if (8 & l) oi(t, e, n.child, r, s, i, !1), Ls(e, t, s, a, i); else if (32 & l) { const o = As(n, r); let l; for (; l = o();)Ls(e, t, s, l, i); Ls(e, t, s, a, i) } else 16 & l ? li(t, e, r, n, s, i) : Ls(e, t, s, a, i); n = o ? n.projectionNext : n.next } } function ai(t, e, n, r, s, i) { oi(n, r, t.firstChild, e, s, i, !1) } function li(t, e, n, r, s, i) { const o = n[16], a = o[6].projection[r.projection]; if (Array.isArray(a)) for (let l = 0; l < a.length; l++)Ls(e, t, s, a[l], i); else oi(t, e, a, o[3], s, i, !0) } function ci(t, e, n) { Rt(t) ? t.setAttribute(e, "style", n) : e.style.cssText = n } function ui(t, e, n) { Rt(t) ? "" === n ? t.removeAttribute(e, "class") : t.setAttribute(e, "class", n) : e.className = n } function hi(t, e, n) { let r = t.length; for (; ;) { const s = t.indexOf(e, n); if (-1 === s) return s; if (0 === s || t.charCodeAt(s - 1) <= 32) { const n = e.length; if (s + n === r || t.charCodeAt(s + n) <= 32) return s } n = s + 1 } } const di = "ng-template"; function pi(t, e, n) { let r = 0; for (; r < t.length;) { let s = t[r++]; if (n && "class" === s) { if (s = t[r], -1 !== hi(s.toLowerCase(), e, 0)) return !0 } else if (1 === s) { for (; r < t.length && "string" == typeof (s = t[r++]);)if (s.toLowerCase() === e) return !0; return !1 } } return !1 } function fi(t) { return 4 === t.type && t.value !== di } function gi(t, e, n) { return e === (4 !== t.type || n ? t.value : di) } function mi(t, e, n) { let r = 4; const s = t.attrs || [], i = function (t) { for (let e = 0; e < t.length; e++)if (Ve(t[e])) return e; return t.length }(s); let o = !1; for (let a = 0; a < e.length; a++) { const l = e[a]; if ("number" != typeof l) { if (!o) if (4 & r) { if (r = 2 | 1 & r, "" !== l && !gi(t, l, n) || "" === l && 1 === e.length) { if (_i(r)) return !1; o = !0 } } else { const c = 8 & r ? l : e[++a]; if (8 & r && null !== t.attrs) { if (!pi(t.attrs, c, n)) { if (_i(r)) return !1; o = !0 } continue } const u = yi(8 & r ? "class" : l, s, fi(t), n); if (-1 === u) { if (_i(r)) return !1; o = !0; continue } if ("" !== c) { let t; t = u > i ? "" : s[u + 1].toLowerCase(); const e = 8 & r ? t : null; if (e && -1 !== hi(e, c, 0) || 2 & r && c !== t) { if (_i(r)) return !1; o = !0 } } } } else { if (!o && !_i(r) && !_i(l)) return !1; if (o && _i(l)) continue; o = !1, r = l | 1 & r } } return _i(r) || o } function _i(t) { return 0 == (1 & t) } function yi(t, e, n, r) { if (null === e) return -1; let s = 0; if (r || !n) { let n = !1; for (; s < e.length;) { const r = e[s]; if (r === t) return s; if (3 === r || 6 === r) n = !0; else { if (1 === r || 2 === r) { let t = e[++s]; for (; "string" == typeof t;)t = e[++s]; continue } if (4 === r) break; if (0 === r) { s += 4; continue } } s += n ? 1 : 2 } return -1 } return function (t, e) { let n = t.indexOf(4); if (n > -1) for (n++; n < t.length;) { const r = t[n]; if ("number" == typeof r) return -1; if (r === e) return n; n++ } return -1 }(e, t) } function vi(t, e, n = !1) { for (let r = 0; r < e.length; r++)if (mi(t, e[r], n)) return !0; return !1 } function bi(t, e) { t: for (let n = 0; n < e.length; n++) { const r = e[n]; if (t.length === r.length) { for (let e = 0; e < t.length; e++)if (t[e] !== r[e]) continue t; return !0 } } return !1 } function wi(t, e) { return t ? ":not(" + e.trim() + ")" : e } function Ei(t) { let e = t[0], n = 1, r = 2, s = "", i = !1; for (; n < t.length;) { let o = t[n]; if ("string" == typeof o) if (2 & r) { const e = t[++n]; s += "[" + o + (e.length > 0 ? '="' + e + '"' : "") + "]" } else 8 & r ? s += "." + o : 4 & r && (s += " " + o); else "" === s || _i(o) || (e += wi(i, s), s = ""), r = o, i = i || !_i(r); n++ } return "" !== s && (e += wi(i, s)), e } const Si = {}; function Ci(t) { xi(Yt(), Kt(), xe() + t, se()) } function xi(t, e, n, r) { if (!r) if (3 == (3 & e[2])) { const r = t.preOrderCheckHooks; null !== r && Re(e, r, n) } else { const r = t.preOrderHooks; null !== r && Me(e, r, 0, n) } Oe(n) } function Oi(t, e) { return t << 17 | e << 2 } function Ti(t) { return t >> 17 & 32767 } function Pi(t) { return 2 | t } function ki(t) { return (131068 & t) >> 2 } function Ai(t, e) { return -131069 & t | e << 2 } function Ii(t) { return 1 | t } function Ri(t, e) { const n = t.contentQueries; if (null !== n) for (let r = 0; r < n.length; r += 2) { const s = n[r], i = n[r + 1]; if (-1 !== i) { const n = t.data[i]; me(s), n.contentQueries(2, e[i], i) } } } function Mi(t, e, n, r, s, i, o, a, l, c) { const u = e.blueprint.slice(); return u[0] = s, u[2] = 140 | r, $t(u), u[3] = u[15] = t, u[8] = n, u[10] = o || t && t[10], u[11] = a || t && t[11], u[12] = l || t && t[12] || null, u[9] = c || t && t[9] || null, u[6] = i, u[16] = 2 == e.type ? t[16] : u, u } function Di(t, e, n, r, s) { let i = t.data[e]; if (null === i) i = Li(t, e, n, r, s), Ht.lFrame.inI18n && (i.flags |= 64); else if (64 & i.type) { i.type = n, i.value = r, i.attrs = s; const t = te(); i.injectorIndex = null === t ? -1 : t.injectorIndex } return ee(i, !0), i } function Li(t, e, n, r, s) { const i = Xt(), o = ne(), a = t.data[e] = function (t, e, n, r, s, i) { return { type: n, index: r, insertBeforeIndex: null, injectorIndex: e ? e.injectorIndex : -1, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, propertyBindings: null, flags: 0, providerIndexes: 0, value: s, attrs: i, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tViews: null, next: null, projectionNext: null, child: null, parent: e, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, o ? i : i && i.parent, n, e, r, s); return null === t.firstChild && (t.firstChild = a), null !== i && (o ? null == i.child && null !== a.parent && (i.child = a) : null === i.next && (i.next = a)), a } function Ni(t, e, n, r) { if (0 === n) return -1; const s = e.length; for (let i = 0; i < n; i++)e.push(r), t.blueprint.push(r), t.data.push(null); return s } function Fi(t, e, n) { ve(e); try { const r = t.viewQuery; null !== r && mo(1, r, n); const s = t.template; null !== s && Vi(t, e, s, 1, n), t.firstCreatePass && (t.firstCreatePass = !1), t.staticContentQueries && Ri(t, e), t.staticViewQueries && mo(2, t.viewQuery, n); const i = t.components; null !== i && function (t, e) { for (let n = 0; n < e.length; n++)uo(t, e[n]) }(e, i) } catch (r) { throw t.firstCreatePass && (t.incompleteFirstPass = !0), r } finally { e[2] &= -5, Ce() } } function ji(t, e, n, r) { const s = e[2]; if (256 == (256 & s)) return; ve(e); const i = se(); try { $t(e), le(t.bindingStartIndex), null !== n && Vi(t, e, n, 2, r); const o = 3 == (3 & s); if (!i) if (o) { const n = t.preOrderCheckHooks; null !== n && Re(e, n, null) } else { const n = t.preOrderHooks; null !== n && Me(e, n, 0, null), De(e, 0) } if (function (t) { for (let e = Rs(t); null !== e; e = Ms(e)) { if (!e[2]) continue; const t = e[9]; for (let e = 0; e < t.length; e++) { const n = t[e], r = n[3]; 0 == (1024 & n[2]) && zt(r, 1), n[2] |= 1024 } } }(e), function (t) { for (let e = Rs(t); null !== e; e = Ms(e))for (let t = pt; t < e.length; t++) { const n = e[t], r = n[1]; Bt(n) && ji(r, n, r.template, n[8]) } }(e), null !== t.contentQueries && Ri(t, e), !i) if (o) { const n = t.contentCheckHooks; null !== n && Re(e, n) } else { const n = t.contentHooks; null !== n && Me(e, n, 1), De(e, 1) } !function (t, e) { const n = t.hostBindingOpCodes; if (null !== n) try { for (let t = 0; t < n.length; t++) { const r = n[t]; if (r < 0) Oe(~r); else { const s = r, i = n[++t], o = n[++t]; de(i, s), o(2, e[s]) } } } finally { Oe(-1) } }(t, e); const a = t.components; null !== a && function (t, e) { for (let n = 0; n < e.length; n++)lo(t, e[n]) }(e, a); const l = t.viewQuery; if (null !== l && mo(2, l, r), !i) if (o) { const n = t.viewCheckHooks; null !== n && Re(e, n) } else { const n = t.viewHooks; null !== n && Me(e, n, 2), De(e, 2) } !0 === t.firstUpdatePass && (t.firstUpdatePass = !1), i || (e[2] &= -73), 1024 & e[2] && (e[2] &= -1025, zt(e[3], -1)) } finally { Ce() } } function Ui(t, e, n, r) { const s = e[10], i = !se(), o = Vt(e); try { i && !o && s.begin && s.begin(), o && Fi(t, e, r), ji(t, e, n, r) } finally { i && !o && s.end && s.end() } } function Vi(t, e, n, r, s) { const i = xe(), o = 2 & r; try { Oe(-1), o && e.length > dt && xi(t, e, dt, se()), n(r, s) } finally { Oe(i) } } function Bi(t, e, n) { if (mt(e)) { const r = e.directiveEnd; for (let s = e.directiveStart; s < r; s++) { const e = t.data[s]; e.contentQueries && e.contentQueries(1, n[s], s) } } } function qi(t, e, n) { Gt() && (function (t, e, n, r) { const s = n.directiveStart, i = n.directiveEnd; t.firstCreatePass || Ye(n, e), gs(r, e); const o = n.initialInputs; for (let a = s; a < i; a++) { const r = t.data[a], i = vt(r); i && no(e, n, r); const l = cn(e, t, a, n); gs(l, e), null !== o && io(0, a - s, l, r, 0, o), i && (Ut(n.index, e)[8] = l) } }(t, e, n, Nt(n, e)), 128 == (128 & n.flags) && function (t, e, n) { const r = n.directiveStart, s = n.directiveEnd, i = n.index, o = Ht.lFrame.currentDirectiveIndex; try { Oe(i); for (let n = r; n < s; n++) { const r = t.data[n], s = e[n]; pe(n), null === r.hostBindings && 0 === r.hostVars && null === r.hostAttrs || Qi(r, s) } } finally { Oe(-1), pe(o) } }(t, e, n)) } function $i(t, e, n = Nt) { const r = e.localNames; if (null !== r) { let s = e.index + 1; for (let i = 0; i < r.length; i += 2) { const o = r[i + 1], a = -1 === o ? n(e, t) : t[o]; t[s++] = a } } } function zi(t) { const e = t.tView; return null === e || e.incompleteFirstPass ? t.tView = Hi(1, null, t.template, t.decls, t.vars, t.directiveDefs, t.pipeDefs, t.viewQuery, t.schemas, t.consts) : e } function Hi(t, e, n, r, s, i, o, a, l, c) { const u = dt + r, h = u + s, d = function (t, e) { const n = []; for (let r = 0; r < e; r++)n.push(r < t ? null : Si); return n }(u, h), p = "function" == typeof c ? c() : c; return d[1] = { type: t, blueprint: d, template: n, queries: null, viewQuery: a, declTNode: e, data: d.slice().fill(null, u), bindingStartIndex: u, expandoStartIndex: h, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof i ? i() : i, pipeRegistry: "function" == typeof o ? o() : o, firstChild: null, schemas: l, consts: p, incompleteFirstPass: !1 } } function Gi(t, e, n, r) { const s = yo(e); null === n ? s.push(r) : (s.push(n), t.firstCreatePass && vo(t).push(r, s.length - 1)) } function Zi(t, e, n) { for (let r in t) if (t.hasOwnProperty(r)) { const s = t[r]; (n = null === n ? {} : n).hasOwnProperty(r) ? n[r].push(e, s) : n[r] = [e, s] } return n } function Wi(t, e, n, r, s, i, o, a) { const l = Nt(e, n); let c, u = e.inputs; var h; !a && null != u && (c = u[r]) ? (Eo(t, n, c, r, s), _t(e) && function (t, e) { const n = Ut(e, t); 16 & n[2] || (n[2] |= 64) }(n, e.index)) : 3 & e.type && (r = "class" === (h = r) ? "className" : "for" === h ? "htmlFor" : "formaction" === h ? "formAction" : "innerHtml" === h ? "innerHTML" : "readonly" === h ? "readOnly" : "tabindex" === h ? "tabIndex" : h, s = null != o ? o(s, e.value || "", r) : s, Rt(i) ? i.setProperty(l, r, s) : Be(r) || (l.setProperty ? l.setProperty(r, s) : l[r] = s)) } function Ki(t, e, n, r) { let s = !1; if (Gt()) { const i = function (t, e, n) { const r = t.directiveRegistry; let s = null; if (r) for (let i = 0; i < r.length; i++) { const o = r[i]; vi(n, o.selectors, !1) && (s || (s = []), tn(Ye(n, e), t, o.type), vt(o) ? (Ji(t, n), s.unshift(o)) : s.push(o)) } return s }(t, e, n), o = null === r ? null : { "": -1 }; if (null !== i) { s = !0, to(n, t.data.length, i.length); for (let t = 0; t < i.length; t++) { const e = i[t]; e.providersResolver && e.providersResolver(e) } let r = !1, a = !1, l = Ni(t, e, i.length, null); for (let s = 0; s < i.length; s++) { const c = i[s]; n.mergedAttrs = qe(n.mergedAttrs, c.hostAttrs), eo(t, n, e, l, c), Xi(l, c, o), null !== c.contentQueries && (n.flags |= 8), null === c.hostBindings && null === c.hostAttrs && 0 === c.hostVars || (n.flags |= 128); const u = c.type.prototype; !r && (u.ngOnChanges || u.ngOnInit || u.ngDoCheck) && ((t.preOrderHooks || (t.preOrderHooks = [])).push(n.index), r = !0), a || !u.ngOnChanges && !u.ngDoCheck || ((t.preOrderCheckHooks || (t.preOrderCheckHooks = [])).push(n.index), a = !0), l++ } !function (t, e) { const n = e.directiveEnd, r = t.data, s = e.attrs, i = []; let o = null, a = null; for (let l = e.directiveStart; l < n; l++) { const t = r[l], n = t.inputs, c = null === s || fi(e) ? null : oo(n, s); i.push(c), o = Zi(n, l, o), a = Zi(t.outputs, l, a) } null !== o && (o.hasOwnProperty("class") && (e.flags |= 16), o.hasOwnProperty("style") && (e.flags |= 32)), e.initialInputs = i, e.inputs = o, e.outputs = a }(t, n) } o && function (t, e, n) { if (e) { const r = t.localNames = []; for (let t = 0; t < e.length; t += 2) { const s = n[e[t + 1]]; if (null == s) throw new m("301", `Export of name '${e[t + 1]}' not found!`); r.push(e[t], s) } } }(n, r, o) } return n.mergedAttrs = qe(n.mergedAttrs, n.attrs), s } function Yi(t, e, n, r, s, i) { const o = i.hostBindings; if (o) { let n = t.hostBindingOpCodes; null === n && (n = t.hostBindingOpCodes = []); const i = ~e.index; (function (t) { let e = t.length; for (; e > 0;) { const n = t[--e]; if ("number" == typeof n && n < 0) return n } return 0 })(n) != i && n.push(i), n.push(r, s, o) } } function Qi(t, e) { null !== t.hostBindings && t.hostBindings(1, e) } function Ji(t, e) { e.flags |= 2, (t.components || (t.components = [])).push(e.index) } function Xi(t, e, n) { if (n) { if (e.exportAs) for (let r = 0; r < e.exportAs.length; r++)n[e.exportAs[r]] = t; vt(e) && (n[""] = t) } } function to(t, e, n) { t.flags |= 1, t.directiveStart = e, t.directiveEnd = e + n, t.providerIndexes = e } function eo(t, e, n, r, s) { t.data[r] = s; const i = s.factory || (s.factory = bt(s.type)), o = new je(i, vt(s), null); t.blueprint[r] = o, n[r] = o, Yi(t, e, 0, r, Ni(t, n, s.hostVars, Si), s) } function no(t, e, n) { const r = Nt(e, t), s = zi(n), i = t[10], o = ho(t, Mi(t, s, null, n.onPush ? 64 : 16, r, e, i, i.createRenderer(r, n), null, null)); t[e.index] = o } function ro(t, e, n, r, s, i) { const o = Nt(t, e); so(e[11], o, i, t.value, n, r, s) } function so(t, e, n, r, s, i, o) { if (null == i) Rt(t) ? t.removeAttribute(e, s, n) : e.removeAttribute(s); else { const a = null == o ? _(i) : o(i, r || "", s); Rt(t) ? t.setAttribute(e, s, a, n) : n ? e.setAttributeNS(n, s, a) : e.setAttribute(s, a) } } function io(t, e, n, r, s, i) { const o = i[e]; if (null !== o) { const t = r.setInput; for (let e = 0; e < o.length;) { const s = o[e++], i = o[e++], a = o[e++]; null !== t ? r.setInput(n, a, s, i) : n[i] = a } } } function oo(t, e) { let n = null, r = 0; for (; r < e.length;) { const s = e[r]; if (0 !== s) if (5 !== s) { if ("number" == typeof s) break; t.hasOwnProperty(s) && (null === n && (n = []), n.push(s, t[s], e[r + 1])), r += 2 } else r += 2; else r += 4 } return n } function ao(t, e, n, r) { return new Array(t, !0, !1, e, null, 0, r, n, null, null) } function lo(t, e) { const n = Ut(e, t); if (Bt(n)) { const t = n[1]; 80 & n[2] ? ji(t, n, t.template, n[8]) : n[5] > 0 && co(n) } } function co(t) { for (let n = Rs(t); null !== n; n = Ms(n))for (let t = pt; t < n.length; t++) { const e = n[t]; if (1024 & e[2]) { const t = e[1]; ji(t, e, t.template, e[8]) } else e[5] > 0 && co(e) } const e = t[1].components; if (null !== e) for (let n = 0; n < e.length; n++) { const r = Ut(e[n], t); Bt(r) && r[5] > 0 && co(r) } } function uo(t, e) { const n = Ut(e, t), r = n[1]; !function (t, e) { for (let n = e.length; n < t.blueprint.length; n++)e.push(t.blueprint[n]) }(r, n), Fi(r, n, n[8]) } function ho(t, e) { return t[13] ? t[14][4] = e : t[13] = e, t[14] = e, e } function po(t) { for (; t;) { t[2] |= 64; const e = Is(t); if (0 != (512 & t[2]) && !e) return t; t = e } return null } function fo(t, e, n) { const r = e[10]; r.begin && r.begin(); try { ji(t, e, t.template, n) } catch (s) { throw wo(e, s), s } finally { r.end && r.end() } } function go(t) { !function (t) { for (let e = 0; e < t.components.length; e++) { const n = t.components[e], r = ms(n), s = r[1]; Ui(s, r, s.template, n) } }(t[8]) } function mo(t, e, n) { me(0), e(t, n) } const _o = (() => Promise.resolve(null))(); function yo(t) { return t[7] || (t[7] = []) } function vo(t) { return t.cleanup || (t.cleanup = []) } function bo(t, e, n) { return (null === t || vt(t)) && (n = function (t) { for (; Array.isArray(t);) { if ("object" == typeof t[1]) return t; t = t[0] } return null }(n[e.index])), n[11] } function wo(t, e) { const n = t[9], r = n ? n.get(bs, null) : null; r && r.handleError(e) } function Eo(t, e, n, r, s) { for (let i = 0; i < n.length;) { const o = n[i++], a = n[i++], l = e[o], c = t.data[o]; null !== c.setInput ? c.setInput(l, s, r, a) : l[a] = s } } function So(t, e, n) { const r = Lt(e, t); Fs(t[11], r, n) } function Co(t, e, n) { let r = n ? t.styles : null, s = n ? t.classes : null, i = 0; if (null !== e) for (let o = 0; o < e.length; o++) { const t = e[o]; "number" == typeof t ? i = t : 1 == i ? s = h(s, t) : 2 == i && (r = h(r, t + ": " + e[++o] + ";")) } n ? t.styles = r : t.stylesWithoutHost = r, n ? t.classes = s : t.classesWithoutHost = s } const xo = new Cn("INJECTOR", -1); class Oo { get(t, e = zn) { if (e === zn) { const e = new Error(`NullInjectorError: No provider for ${u(t)}!`); throw e.name = "NullInjectorError", e } return e } } const To = new Cn("Set Injector scope."), Po = {}, ko = {}; let Ao; function Io() { return void 0 === Ao && (Ao = new Oo), Ao } function Ro(t, e = null, n = null, r) { return new Mo(t, n, e || Io(), r) } class Mo { constructor(t, e, n, r = null) { this.parent = n, this.records = new Map, this.injectorDefTypes = new Set, this.onDestroy = new Set, this._destroyed = !1; const s = []; e && An(e, n => this.processProvider(n, t, e)), An([t], t => this.processInjectorType(t, [], s)), this.records.set(xo, No(void 0, this)); const i = this.records.get(To); this.scope = null != i ? i.value : null, this.source = r || ("object" == typeof t ? null : u(t)) } get destroyed() { return this._destroyed } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { this.onDestroy.forEach(t => t.ngOnDestroy()) } finally { this.records.clear(), this.onDestroy.clear(), this.injectorDefTypes.clear() } } get(t, e = zn, n = A.Default) { this.assertNotDestroyed(); const r = Kn(this); try { if (!(n & A.SkipSelf)) { let e = this.records.get(t); if (void 0 === e) { const n = ("function" == typeof (s = t) || "object" == typeof s && s instanceof Cn) && S(t); e = n && this.injectableDefInScope(n) ? No(Do(t), Po) : null, this.records.set(t, e) } if (null != e) return this.hydrate(t, e) } return (n & A.Self ? Io() : this.parent).get(t, e = n & A.Optional && e === zn ? null : e) } catch (i) { if ("NullInjectorError" === i.name) { if ((i.ngTempTokenPath = i.ngTempTokenPath || []).unshift(u(t)), r) throw i; return function (t, e, n, r) { const s = t.ngTempTokenPath; throw e[Gn] && s.unshift(e[Gn]), t.message = function (t, e, n, r = null) { t = t && "\n" === t.charAt(0) && "\u0275" == t.charAt(1) ? t.substr(2) : t; let s = u(e); if (Array.isArray(e)) s = e.map(u).join(" -> "); else if ("object" == typeof e) { let t = []; for (let n in e) if (e.hasOwnProperty(n)) { let r = e[n]; t.push(n + ":" + ("string" == typeof r ? JSON.stringify(r) : u(r))) } s = `{${t.join(", ")}}` } return `${n}${r ? "(" + r + ")" : ""}[${s}]: ${t.replace(Hn, "\n  ")}` }("\n" + t.message, s, n, r), t.ngTokenPath = s, t.ngTempTokenPath = null, t }(i, t, "R3InjectorError", this.source) } throw i } finally { Kn(r) } var s } _resolveInjectorDefTypes() { this.injectorDefTypes.forEach(t => this.get(t)) } toString() { const t = []; return this.records.forEach((e, n) => t.push(u(n))), `R3Injector[${t.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new Error("Injector has already been destroyed.") } processInjectorType(t, e, n) { if (!(t = f(t))) return !1; let r = x(t); const s = null == r && t.ngModule || void 0, i = void 0 === s ? t : s, o = -1 !== n.indexOf(i); if (void 0 !== s && (r = x(s)), null == r) return !1; if (null != r.imports && !o) { let t; n.push(i); try { An(r.imports, r => { this.processInjectorType(r, e, n) && (void 0 === t && (t = []), t.push(r)) }) } finally { } if (void 0 !== t) for (let e = 0; e < t.length; e++) { const { ngModule: n, providers: r } = t[e]; An(r, t => this.processProvider(t, n, r || $)) } } this.injectorDefTypes.add(i); const a = bt(i) || (() => new i); this.records.set(i, No(a, Po)); const l = r.providers; if (null != l && !o) { const e = t; An(l, t => this.processProvider(t, e, l)) } return void 0 !== s && void 0 !== t.providers } processProvider(t, e, n) { let r = jo(t = f(t)) ? t : f(t && t.provide); const s = function (t, e, n) { return Fo(t) ? No(void 0, t.useValue) : No(Lo(t), Po) }(t); if (jo(t) || !0 !== t.multi) this.records.get(r); else { let e = this.records.get(r); e || (e = No(void 0, Po, !0), e.factory = () => Xn(e.multi), this.records.set(r, e)), r = t, e.multi.push(t) } this.records.set(r, s) } hydrate(t, e) { var n; return e.value === Po && (e.value = ko, e.value = e.factory()), "object" == typeof e.value && e.value && null !== (n = e.value) && "object" == typeof n && "function" == typeof n.ngOnDestroy && this.onDestroy.add(e.value), e.value } injectableDefInScope(t) { if (!t.providedIn) return !1; const e = f(t.providedIn); return "string" == typeof e ? "any" === e || e === this.scope : this.injectorDefTypes.has(e) } } function Do(t) { const e = S(t), n = null !== e ? e.factory : bt(t); if (null !== n) return n; if (t instanceof Cn) throw new Error(`Token ${u(t)} is missing a \u0275prov definition.`); if (t instanceof Function) return function (t) { const e = t.length; if (e > 0) { const n = Mn(e, "?"); throw new Error(`Can't resolve all parameters for ${u(t)}: (${n.join(", ")}).`) } const n = function (t) { const e = t && (t[O] || t[P]); if (e) { const n = function (t) { if (t.hasOwnProperty("name")) return t.name; const e = ("" + t).match(/^function\s*([^\s(]+)/); return null === e ? "" : e[1] }(t); return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`), e } return null }(t); return null !== n ? () => n.factory(t) : () => new t }(t); throw new Error("unreachable") } function Lo(t, e, n) { let r; if (jo(t)) { const e = f(t); return bt(e) || Do(e) } if (Fo(t)) r = () => f(t.useValue); else if ((s = t) && s.useFactory) r = () => t.useFactory(...Xn(t.deps || [])); else if (function (t) { return !(!t || !t.useExisting) }(t)) r = () => Qn(f(t.useExisting)); else { const e = f(t && (t.useClass || t.provide)); if (!function (t) { return !!t.deps }(t)) return bt(e) || Do(e); r = () => new e(...Xn(t.deps)) } var s; return r } function No(t, e, n = !1) { return { factory: t, value: e, multi: n ? [] : void 0 } } function Fo(t) { return null !== t && "object" == typeof t && Zn in t } function jo(t) { return "function" == typeof t } const Uo = function (t, e, n) { return function (t, e = null, n = null, r) { const s = Ro(t, e, n, r); return s._resolveInjectorDefTypes(), s }({ name: n }, e, t, n) }; let Vo = (() => { class t { static create(t, e) { return Array.isArray(t) ? Uo(t, e, "") : Uo(t.providers, t.parent, t.name || "") } } return t.THROW_IF_NOT_FOUND = zn, t.NULL = new Oo, t.\u0275prov = w({ token: t, providedIn: "any", factory: () => Qn(xo) }), t.__NG_ELEMENT_ID__ = -1, t })(); function Bo(t, e) { Ie(ms(t)[1], Jt()) } function qo(t) { return Object.getPrototypeOf(t.prototype).constructor } function $o(t) { let e = qo(t.type), n = !0; const r = [t]; for (; e;) { let s; if (vt(t)) s = e.\u0275cmp || e.\u0275dir; else { if (e.\u0275cmp) throw new Error("Directives cannot inherit Components"); s = e.\u0275dir } if (s) { if (n) { r.push(s); const e = t; e.inputs = zo(t.inputs), e.declaredInputs = zo(t.declaredInputs), e.outputs = zo(t.outputs); const n = s.hostBindings; n && Zo(t, n); const i = s.viewQuery, o = s.contentQueries; if (i && Ho(t, i), o && Go(t, o), c(t.inputs, s.inputs), c(t.declaredInputs, s.declaredInputs), c(t.outputs, s.outputs), vt(s) && s.data.animation) { const e = t.data; e.animation = (e.animation || []).concat(s.data.animation) } } const e = s.features; if (e) for (let r = 0; r < e.length; r++) { const s = e[r]; s && s.ngInherit && s(t), s === $o && (n = !1) } } e = Object.getPrototypeOf(e) } !function (t) { let e = 0, n = null; for (let r = t.length - 1; r >= 0; r--) { const s = t[r]; s.hostVars = e += s.hostVars, s.hostAttrs = qe(s.hostAttrs, n = qe(n, s.hostAttrs)) } }(r) } function zo(t) { return t === q ? {} : t === $ ? [] : t } function Ho(t, e) { const n = t.viewQuery; t.viewQuery = n ? (t, r) => { e(t, r), n(t, r) } : e } function Go(t, e) { const n = t.contentQueries; t.contentQueries = n ? (t, r, s) => { e(t, r, s), n(t, r, s) } : e } function Zo(t, e) { const n = t.hostBindings; t.hostBindings = n ? (t, r) => { e(t, r), n(t, r) } : e } const Wo = ["providersResolver"], Ko = ["template", "decls", "consts", "vars", "onPush", "ngContentSelectors", "styles", "encapsulation", "schemas"]; function Yo(t) { let e, n = qo(t.type); e = vt(t) ? n.\u0275cmp : n.\u0275dir; const r = t; for (const s of Wo) r[s] = e[s]; if (vt(e)) for (const s of Ko) r[s] = e[s] } let Qo = null; function Jo() { if (!Qo) { const t = B.Symbol; if (t && t.iterator) Qo = t.iterator; else { const t = Object.getOwnPropertyNames(Map.prototype); for (let e = 0; e < t.length; ++e) { const n = t[e]; "entries" !== n && "size" !== n && Map.prototype[n] === Map.prototype.entries && (Qo = n) } } } return Qo } class Xo { constructor(t) { this.wrapped = t } static wrap(t) { return new Xo(t) } static unwrap(t) { return Xo.isWrapped(t) ? t.wrapped : t } static isWrapped(t) { return t instanceof Xo } } function ta(t) { return !!ea(t) && (Array.isArray(t) || !(t instanceof Map) && Jo() in t) } function ea(t) { return null !== t && ("function" == typeof t || "object" == typeof t) } function na(t, e, n) { return t[e] = n } function ra(t, e) { return t[e] } function sa(t, e, n) { return !Object.is(t[e], n) && (t[e] = n, !0) } function ia(t, e, n, r) { const s = sa(t, e, n); return sa(t, e + 1, r) || s } function oa(t, e, n, r, s) { const i = ia(t, e, n, r); return sa(t, e + 2, s) || i } function aa(t, e, n, r, s, i) { const o = ia(t, e, n, r); return ia(t, e + 2, s, i) || o } function la(t, e, n, r) { const s = Kt(); return sa(s, ce(), e) && (Yt(), ro(Te(), s, t, e, n, r)), la } function ca(t, e) { let n = !1, r = ae(); for (let i = 1; i < e.length; i += 2)n = sa(t, r++, e[i]) || n; if (le(r), !n) return Si; let s = e[0]; for (let i = 1; i < e.length; i += 2)s += _(e[i]) + e[i + 1]; return s } function ua(t, e, n, r) { return sa(t, ce(), n) ? e + _(n) + r : Si } function ha(t, e, n, r, s, i) { const o = ia(t, ae(), n, s); return ue(2), o ? e + _(n) + r + _(s) + i : Si } function da(t, e, n, r, s, i, o, a) { const l = oa(t, ae(), n, s, o); return ue(3), l ? e + _(n) + r + _(s) + i + _(o) + a : Si } function pa(t, e, n, r, s, i, o, a, l, c) { const u = aa(t, ae(), n, s, o, l); return ue(4), u ? e + _(n) + r + _(s) + i + _(o) + a + _(l) + c : Si } function fa(t, e, n, r, s, i, o, a, l, c, u, h) { const d = ae(); let p = aa(t, d, n, s, o, l); return p = sa(t, d + 4, u) || p, ue(5), p ? e + _(n) + r + _(s) + i + _(o) + a + _(l) + c + _(u) + h : Si } function ga(t, e, n, r, s, i, o, a, l, c, u, h, d, p) { const f = ae(); let g = aa(t, f, n, s, o, l); return g = ia(t, f + 4, u, d) || g, ue(6), g ? e + _(n) + r + _(s) + i + _(o) + a + _(l) + c + _(u) + h + _(d) + p : Si } function ma(t, e, n, r, s, i, o, a, l, c, u, h, d, p, f, g) { const m = ae(); let y = aa(t, m, n, s, o, l); return y = oa(t, m + 4, u, d, f) || y, ue(7), y ? e + _(n) + r + _(s) + i + _(o) + a + _(l) + c + _(u) + h + _(d) + p + _(f) + g : Si } function _a(t, e, n, r, s, i, o, a, l, c, u, h, d, p, f, g, m, y) { const v = ae(); let b = aa(t, v, n, s, o, l); return b = aa(t, v + 4, u, d, f, m) || b, ue(8), b ? e + _(n) + r + _(s) + i + _(o) + a + _(l) + c + _(u) + h + _(d) + p + _(f) + g + _(m) + y : Si } function ya(t, e, n, r, s, i) { const o = Kt(), a = ua(o, e, n, r); return a !== Si && ro(Te(), o, t, a, s, i), ya } function va(t, e, n, r, s, i, o, a) { const l = Kt(), c = ha(l, e, n, r, s, i); return c !== Si && ro(Te(), l, t, c, o, a), va } function ba(t, e, n, r, s, i, o, a, l, c) { const u = Kt(), h = da(u, e, n, r, s, i, o, a); return h !== Si && ro(Te(), u, t, h, l, c), ba } function wa(t, e, n, r, s, i, o, a, l, c, u, h) { const d = Kt(), p = pa(d, e, n, r, s, i, o, a, l, c); return p !== Si && ro(Te(), d, t, p, u, h), wa } function Ea(t, e, n, r, s, i, o, a, l, c, u, h, d, p) { const f = Kt(), g = fa(f, e, n, r, s, i, o, a, l, c, u, h); return g !== Si && ro(Te(), f, t, g, d, p), Ea } function Sa(t, e, n, r, s, i, o, a, l, c, u, h, d, p, f, g) { const m = Kt(), _ = ga(m, e, n, r, s, i, o, a, l, c, u, h, d, p); return _ !== Si && ro(Te(), m, t, _, f, g), Sa } function Ca(t, e, n, r, s, i, o, a, l, c, u, h, d, p, f, g, m, _) { const y = Kt(), v = ma(y, e, n, r, s, i, o, a, l, c, u, h, d, p, f, g); return v !== Si && ro(Te(), y, t, v, m, _), Ca } function xa(t, e, n, r, s, i, o, a, l, c, u, h, d, p, f, g, m, _, y, v) { const b = Kt(), w = _a(b, e, n, r, s, i, o, a, l, c, u, h, d, p, f, g, m, _); return w !== Si && ro(Te(), b, t, w, y, v), xa } function Oa(t, e, n, r) { const s = Kt(), i = ca(s, e); return i !== Si && ro(Te(), s, t, i, n, r), Oa } function Ta(t, e, n, r, s, i, o, a) { const l = Kt(), c = Yt(), u = t + dt, h = c.firstCreatePass ? function (t, e, n, r, s, i, o, a, l) { const c = e.consts, u = Di(e, t, 4, o || null, qt(c, a)); Ki(e, n, u, qt(c, l)), Ie(e, u); const h = u.tViews = Hi(2, u, r, s, i, e.directiveRegistry, e.pipeRegistry, null, e.schemas, c); return null !== e.queries && (e.queries.template(e, u), h.queries = e.queries.embeddedTView(u)), u }(u, c, l, e, n, r, s, i, o) : c.data[u]; ee(h, !1); const d = l[11].createComment(""); ei(c, l, d, h), gs(d, l), ho(l, l[u] = ao(d, l, d, h)), yt(h) && qi(c, l, h), null != o && $i(l, h, a) } function Pa(t) { return jt(Ht.lFrame.contextLView, dt + t) } function ka(t, e = A.Default) { const n = Kt(); return null === n ? Qn(t, e) : rn(Jt(), n, f(t), e) } function Aa() { throw new Error("invalid") } function Ia(t, e, n) { const r = Kt(); return sa(r, ce(), e) && Wi(Yt(), Te(), r, t, e, r[11], n, !1), Ia } function Ra(t, e, n, r, s) { const i = s ? "class" : "style"; Eo(t, n, e.inputs[i], i, r) } function Ma(t, e, n, r) { const s = Kt(), i = Yt(), o = dt + t, a = s[11], l = s[o] = Us(a, e, Ht.lFrame.currentNamespace), c = i.firstCreatePass ? function (t, e, n, r, s, i, o) { const a = e.consts, l = Di(e, t, 2, s, qt(a, i)); return Ki(e, n, l, qt(a, o)), null !== l.attrs && Co(l, l.attrs, !1), null !== l.mergedAttrs && Co(l, l.mergedAttrs, !0), null !== e.queries && e.queries.elementStart(e, l), l }(o, i, s, 0, e, n, r) : i.data[o]; ee(c, !0); const u = c.mergedAttrs; null !== u && Ue(a, l, u); const h = c.classes; null !== h && ui(a, l, h); const d = c.styles; null !== d && ci(a, l, d), 64 != (64 & c.flags) && ei(i, s, l, c), 0 === Ht.lFrame.elementDepthCount && gs(l, s), Ht.lFrame.elementDepthCount++, yt(c) && (qi(i, s, c), Bi(i, c, s)), null !== r && $i(s, c) } function Da() { let t = Jt(); ne() ? re() : (t = t.parent, ee(t, !1)); const e = t; Ht.lFrame.elementDepthCount--; const n = Yt(); n.firstCreatePass && (Ie(n, t), mt(t) && n.queries.elementEnd(t)), null != e.classesWithoutHost && function (t) { return 0 != (16 & t.flags) }(e) && Ra(n, e, Kt(), e.classesWithoutHost, !0), null != e.stylesWithoutHost && function (t) { return 0 != (32 & t.flags) }(e) && Ra(n, e, Kt(), e.stylesWithoutHost, !1) } function La(t, e, n, r) { Ma(t, e, n, r), Da() } function Na(t, e, n) { const r = Kt(), s = Yt(), i = t + dt, o = s.firstCreatePass ? function (t, e, n, r, s) { const i = e.consts, o = qt(i, r), a = Di(e, t, 8, "ng-container", o); return null !== o && Co(a, o, !0), Ki(e, n, a, qt(i, s)), null !== e.queries && e.queries.elementStart(e, a), a }(i, s, r, e, n) : s.data[i]; ee(o, !0); const a = r[i] = r[11].createComment(""); ei(s, r, a, o), gs(a, r), yt(o) && (qi(s, r, o), Bi(s, o, r)), null != n && $i(r, o) } function Fa() { let t = Jt(); const e = Yt(); ne() ? re() : (t = t.parent, ee(t, !1)), e.firstCreatePass && (Ie(e, t), mt(t) && e.queries.elementEnd(t)) } function ja(t, e, n) { Na(t, e, n), Fa() } function Ua() { return Kt() } function Va(t) { return !!t && "function" == typeof t.then } function Ba(t) { return !!t && "function" == typeof t.subscribe } const qa = Ba; function $a(t, e, n, r) { const s = Kt(), i = Yt(), o = Jt(); return Ha(i, s, s[11], o, t, e, !!n, r), $a } function za(t, e) { const n = Jt(), r = Kt(), s = Yt(); return Ha(s, r, bo(fe(s.data), n, r), n, t, e, !1), za } function Ha(t, e, n, r, s, i, o, a) { const l = yt(r), c = t.firstCreatePass && vo(t), u = yo(e); let h = !0; if (3 & r.type || a) { const d = Nt(r, e), p = a ? a(d) : d, f = u.length, g = a ? t => a(Dt(t[r.index])) : r.index; if (Rt(n)) { let o = null; if (!a && l && (o = function (t, e, n, r) { const s = t.cleanup; if (null != s) for (let i = 0; i < s.length - 1; i += 2) { const t = s[i]; if (t === n && s[i + 1] === r) { const t = e[7], n = s[i + 2]; return t.length > n ? t[n] : null } "string" == typeof t && (i += 2) } return null }(t, e, s, r.index)), null !== o) (o.__ngLastListenerFn__ || o).__ngNextListenerFn__ = i, o.__ngLastListenerFn__ = i, h = !1; else { i = Za(r, e, 0, i, !1); const t = n.listen(p, s, i); u.push(i, t), c && c.push(s, g, f, f + 1) } } else i = Za(r, e, 0, i, !0), p.addEventListener(s, i, o), u.push(i), c && c.push(s, g, f, o) } else i = Za(r, e, 0, i, !1); const d = r.outputs; let p; if (h && null !== d && (p = d[s])) { const t = p.length; if (t) for (let n = 0; n < t; n += 2) { const t = e[p[n]][p[n + 1]].subscribe(i), o = u.length; u.push(i, t), c && c.push(s, r.index, o, -(o + 1)) } } } function Ga(t, e, n, r) { try { return !1 !== n(r) } catch (s) { return wo(t, s), !1 } } function Za(t, e, n, r, s) { return function n(i) { if (i === Function) return r; const o = 2 & t.flags ? Ut(t.index, e) : e; 0 == (32 & e[2]) && po(o); let a = Ga(e, 0, r, i), l = n.__ngNextListenerFn__; for (; l;)a = Ga(e, 0, l, i) && a, l = l.__ngNextListenerFn__; return s && !1 === a && (i.preventDefault(), i.returnValue = !1), a } } function Wa(t = 1) { return function (t) { return (Ht.lFrame.contextLView = function (t, e) { for (; t > 0;)e = e[15], t--; return e }(t, Ht.lFrame.contextLView))[8] }(t) } function Ka(t, e) { let n = null; const r = function (t) { const e = t.attrs; if (null != e) { const t = e.indexOf(5); if (0 == (1 & t)) return e[t + 1] } return null }(t); for (let s = 0; s < e.length; s++) { const i = e[s]; if ("*" !== i) { if (null === r ? vi(t, i, !0) : bi(r, i)) return s } else n = s } return n } function Ya(t) { const e = Kt()[16][6]; if (!e.projection) { const n = e.projection = Mn(t ? t.length : 1, null), r = n.slice(); let s = e.child; for (; null !== s;) { const e = t ? Ka(s, t) : 0; null !== e && (r[e] ? r[e].projectionNext = s : n[e] = s, r[e] = s), s = s.next } } } function Qa(t, e = 0, n) { const r = Kt(), s = Yt(), i = Di(s, dt + t, 16, null, n || null); null === i.projection && (i.projection = e), re(), 64 != (64 & i.flags) && function (t, e, n) { li(e[11], 0, e, n, zs(t, n, e), Ys(n.parent || e[6], n, e)) }(s, r, i) } function Ja(t, e, n) { return Xa(t, "", e, "", n), Ja } function Xa(t, e, n, r, s) { const i = Kt(), o = ua(i, e, n, r); return o !== Si && Wi(Yt(), Te(), i, t, o, i[11], s, !1), Xa } function tl(t, e, n, r, s, i, o) { const a = Kt(), l = ha(a, e, n, r, s, i); return l !== Si && Wi(Yt(), Te(), a, t, l, a[11], o, !1), tl } function el(t, e, n, r, s, i, o, a, l) { const c = Kt(), u = da(c, e, n, r, s, i, o, a); return u !== Si && Wi(Yt(), Te(), c, t, u, c[11], l, !1), el } function nl(t, e, n, r, s, i, o, a, l, c, u) { const h = Kt(), d = pa(h, e, n, r, s, i, o, a, l, c); return d !== Si && Wi(Yt(), Te(), h, t, d, h[11], u, !1), nl } function rl(t, e, n, r, s, i, o, a, l, c, u, h, d) { const p = Kt(), f = fa(p, e, n, r, s, i, o, a, l, c, u, h); return f !== Si && Wi(Yt(), Te(), p, t, f, p[11], d, !1), rl } function sl(t, e, n, r, s, i, o, a, l, c, u, h, d, p, f) { const g = Kt(), m = ga(g, e, n, r, s, i, o, a, l, c, u, h, d, p); return m !== Si && Wi(Yt(), Te(), g, t, m, g[11], f, !1), sl } function il(t, e, n, r, s, i, o, a, l, c, u, h, d, p, f, g, m) { const _ = Kt(), y = ma(_, e, n, r, s, i, o, a, l, c, u, h, d, p, f, g); return y !== Si && Wi(Yt(), Te(), _, t, y, _[11], m, !1), il } function ol(t, e, n, r, s, i, o, a, l, c, u, h, d, p, f, g, m, _, y) { const v = Kt(), b = _a(v, e, n, r, s, i, o, a, l, c, u, h, d, p, f, g, m, _); return b !== Si && Wi(Yt(), Te(), v, t, b, v[11], y, !1), ol } function al(t, e, n) { const r = Kt(), s = ca(r, e); return s !== Si && Wi(Yt(), Te(), r, t, s, r[11], n, !1), al } function ll(t, e, n, r, s) { const i = t[n + 1], o = null === e; let a = r ? Ti(i) : ki(i), l = !1; for (; 0 !== a && (!1 === l || o);) { const n = t[a + 1]; cl(t[a], e) && (l = !0, t[a + 1] = r ? Ii(n) : Pi(n)), a = r ? Ti(n) : ki(n) } l && (t[n + 1] = r ? Pi(i) : Ii(i)) } function cl(t, e) { return null === t || null == e || (Array.isArray(t) ? t[1] : t) === e || !(!Array.isArray(t) || "string" != typeof e) && Nn(t, e) >= 0 } const ul = { textEnd: 0, key: 0, keyEnd: 0, value: 0, valueEnd: 0 }; function hl(t) { return t.substring(ul.key, ul.keyEnd) } function dl(t) { return t.substring(ul.value, ul.valueEnd) } function pl(t, e) { const n = ul.textEnd; return n === e ? -1 : (e = ul.keyEnd = function (t, e, n) { for (; e < n && t.charCodeAt(e) > 32;)e++; return e }(t, ul.key = e, n), ml(t, e, n)) } function fl(t, e) { const n = ul.textEnd; let r = ul.key = ml(t, e, n); return n === r ? -1 : (r = ul.keyEnd = function (t, e, n) { let r; for (; e < n && (45 === (r = t.charCodeAt(e)) || 95 === r || (-33 & r) >= 65 && (-33 & r) <= 90 || r >= 48 && r <= 57);)e++; return e }(t, r, n), r = _l(t, r, n), r = ul.value = ml(t, r, n), r = ul.valueEnd = function (t, e, n) { let r = -1, s = -1, i = -1, o = e, a = o; for (; o < n;) { const l = t.charCodeAt(o++); if (59 === l) return a; 34 === l || 39 === l ? a = o = yl(t, l, o, n) : e === o - 4 && 85 === i && 82 === s && 76 === r && 40 === l ? a = o = yl(t, 41, o, n) : l > 32 && (a = o), i = s, s = r, r = -33 & l } return a }(t, r, n), _l(t, r, n)) } function gl(t) { ul.key = 0, ul.keyEnd = 0, ul.value = 0, ul.valueEnd = 0, ul.textEnd = t.length } function ml(t, e, n) { for (; e < n && t.charCodeAt(e) <= 32;)e++; return e } function _l(t, e, n, r) { return (e = ml(t, e, n)) < n && e++, e } function yl(t, e, n, r) { let s = -1, i = n; for (; i < r;) { const n = t.charCodeAt(i++); if (n == e && 92 !== s) return i; s = 92 == n && 92 === s ? 0 : n } throw new Error } function vl(t, e, n) { return xl(t, e, n, !1), vl } function bl(t, e) { return xl(t, e, null, !0), bl } function wl(t) { Ol(Il, El, t, !1) } function El(t, e) { for (let n = function (t) { return gl(t), fl(t, ml(t, 0, ul.textEnd)) }(e); n >= 0; n = fl(e, n))Il(t, hl(e), dl(e)) } function Sl(t) { Ol(Dn, Cl, t, !0) } function Cl(t, e) { for (let n = function (t) { return gl(t), pl(t, ml(t, 0, ul.textEnd)) }(e); n >= 0; n = pl(e, n))Dn(t, hl(e), !0) } function xl(t, e, n, r) { const s = Kt(), i = Yt(), o = ue(2); i.firstUpdatePass && Pl(i, t, o, r), e !== Si && sa(s, o, e) && Rl(i, i.data[xe()], s, s[11], t, s[o + 1] = function (t, e) { return null == t || ("string" == typeof e ? t += e : "object" == typeof t && (t = u(Or(t)))), t }(e, n), r, o) } function Ol(t, e, n, r) { const s = Yt(), i = ue(2); s.firstUpdatePass && Pl(s, null, i, r); const o = Kt(); if (n !== Si && sa(o, i, n)) { const a = s.data[xe()]; if (Ll(a, r) && !Tl(s, i)) { let t = r ? a.classesWithoutHost : a.stylesWithoutHost; null !== t && (n = h(t, n || "")), Ra(s, a, o, n, r) } else !function (t, e, n, r, s, i, o, a) { s === Si && (s = $); let l = 0, c = 0, u = 0 < s.length ? s[0] : null, h = 0 < i.length ? i[0] : null; for (; null !== u || null !== h;) { const d = l < s.length ? s[l + 1] : void 0, p = c < i.length ? i[c + 1] : void 0; let f, g = null; u === h ? (l += 2, c += 2, d !== p && (g = h, f = p)) : null === h || null !== u && u < h ? (l += 2, g = u) : (c += 2, g = h, f = p), null !== g && Rl(t, e, n, r, g, f, o, a), u = l < s.length ? s[l] : null, h = c < i.length ? i[c] : null } }(s, a, o, o[11], o[i + 1], o[i + 1] = function (t, e, n) { if (null == n || "" === n) return $; const r = [], s = Or(n); if (Array.isArray(s)) for (let i = 0; i < s.length; i++)t(r, s[i], !0); else if ("object" == typeof s) for (const i in s) s.hasOwnProperty(i) && t(r, i, s[i]); else "string" == typeof s && e(r, s); return r }(t, e, n), r, i) } } function Tl(t, e) { return e >= t.expandoStartIndex } function Pl(t, e, n, r) { const s = t.data; if (null === s[n + 1]) { const i = s[xe()], o = Tl(t, n); Ll(i, r) && null === e && !o && (e = !1), e = function (t, e, n, r) { const s = fe(t); let i = r ? e.residualClasses : e.residualStyles; if (null === s) 0 === (r ? e.classBindings : e.styleBindings) && (n = Al(n = kl(null, t, e, n, r), e.attrs, r), i = null); else { const o = e.directiveStylingLast; if (-1 === o || t[o] !== s) if (n = kl(s, t, e, n, r), null === i) { let n = function (t, e, n) { const r = n ? e.classBindings : e.styleBindings; if (0 !== ki(r)) return t[Ti(r)] }(t, e, r); void 0 !== n && Array.isArray(n) && (n = kl(null, t, e, n[1], r), n = Al(n, e.attrs, r), function (t, e, n, r) { t[Ti(n ? e.classBindings : e.styleBindings)] = r }(t, e, r, n)) } else i = function (t, e, n) { let r; const s = e.directiveEnd; for (let i = 1 + e.directiveStylingLast; i < s; i++)r = Al(r, t[i].hostAttrs, n); return Al(r, e.attrs, n) }(t, e, r) } return void 0 !== i && (r ? e.residualClasses = i : e.residualStyles = i), n }(s, i, e, r), function (t, e, n, r, s, i) { let o = i ? e.classBindings : e.styleBindings, a = Ti(o), l = ki(o); t[r] = n; let c, u = !1; if (Array.isArray(n)) { const t = n; c = t[1], (null === c || Nn(t, c) > 0) && (u = !0) } else c = n; if (s) if (0 !== l) { const e = Ti(t[a + 1]); t[r + 1] = Oi(e, a), 0 !== e && (t[e + 1] = Ai(t[e + 1], r)), t[a + 1] = 131071 & t[a + 1] | r << 17 } else t[r + 1] = Oi(a, 0), 0 !== a && (t[a + 1] = Ai(t[a + 1], r)), a = r; else t[r + 1] = Oi(l, 0), 0 === a ? a = r : t[l + 1] = Ai(t[l + 1], r), l = r; u && (t[r + 1] = Pi(t[r + 1])), ll(t, c, r, !0), ll(t, c, r, !1), function (t, e, n, r, s) { const i = s ? t.residualClasses : t.residualStyles; null != i && "string" == typeof e && Nn(i, e) >= 0 && (n[r + 1] = Ii(n[r + 1])) }(e, c, t, r, i), o = Oi(a, l), i ? e.classBindings = o : e.styleBindings = o }(s, i, e, n, o, r) } } function kl(t, e, n, r, s) { let i = null; const o = n.directiveEnd; let a = n.directiveStylingLast; for (-1 === a ? a = n.directiveStart : a++; a < o && (i = e[a], r = Al(r, i.hostAttrs, s), i !== t);)a++; return null !== t && (n.directiveStylingLast = a), r } function Al(t, e, n) { const r = n ? 1 : 2; let s = -1; if (null !== e) for (let i = 0; i < e.length; i++) { const o = e[i]; "number" == typeof o ? s = o : s === r && (Array.isArray(t) || (t = void 0 === t ? [] : ["", t]), Dn(t, o, !!n || e[++i])) } return void 0 === t ? null : t } function Il(t, e, n) { Dn(t, e, Or(n)) } function Rl(t, e, n, r, s, i, o, a) { if (!(3 & e.type)) return; const l = t.data, c = l[a + 1]; Dl(1 == (1 & c) ? Ml(l, e, n, s, ki(c), o) : void 0) || (Dl(i) || 2 == (2 & c) && (i = Ml(l, null, n, s, a, o)), function (t, e, n, r, s) { const i = Rt(t); if (e) s ? i ? t.addClass(n, r) : n.classList.add(r) : i ? t.removeClass(n, r) : n.classList.remove(r); else { let e = -1 === r.indexOf("-") ? void 0 : Ps.DashCase; if (null == s) i ? t.removeStyle(n, r, e) : n.style.removeProperty(r); else { const o = "string" == typeof s && s.endsWith("!important"); o && (s = s.slice(0, -10), e |= Ps.Important), i ? t.setStyle(n, r, s, e) : n.style.setProperty(r, s, o ? "important" : "") } } }(r, o, Lt(xe(), n), s, i)) } function Ml(t, e, n, r, s, i) { const o = null === e; let a; for (; s > 0;) { const e = t[s], i = Array.isArray(e), l = i ? e[1] : e, c = null === l; let u = n[s + 1]; u === Si && (u = c ? $ : void 0); let h = c ? Ln(u, r) : l === r ? u : void 0; if (i && !Dl(h) && (h = Ln(e, r)), Dl(h) && (a = h, o)) return a; const d = t[s + 1]; s = o ? Ti(d) : ki(d) } if (null !== e) { let t = i ? e.residualClasses : e.residualStyles; null != t && (a = Ln(t, r)) } return a } function Dl(t) { return void 0 !== t } function Ll(t, e) { return 0 != (t.flags & (e ? 16 : 32)) } function Nl(t, e = "") { const n = Kt(), r = Yt(), s = t + dt, i = r.firstCreatePass ? Di(r, s, 1, e, null) : r.data[s], o = n[s] = Ns(n[11], e); ei(r, n, o, i), ee(i, !1) } function Fl(t) { return jl("", t, ""), Fl } function jl(t, e, n) { const r = Kt(), s = ua(r, t, e, n); return s !== Si && So(r, xe(), s), jl } function Ul(t, e, n, r, s) { const i = Kt(), o = ha(i, t, e, n, r, s); return o !== Si && So(i, xe(), o), Ul } function Vl(t, e, n, r, s, i, o) { const a = Kt(), l = da(a, t, e, n, r, s, i, o); return l !== Si && So(a, xe(), l), Vl } function Bl(t, e, n, r, s, i, o, a, l) { const c = Kt(), u = pa(c, t, e, n, r, s, i, o, a, l); return u !== Si && So(c, xe(), u), Bl } function ql(t, e, n, r, s, i, o, a, l, c, u) { const h = Kt(), d = fa(h, t, e, n, r, s, i, o, a, l, c, u); return d !== Si && So(h, xe(), d), ql } function $l(t, e, n, r, s, i, o, a, l, c, u, h, d) { const p = Kt(), f = ga(p, t, e, n, r, s, i, o, a, l, c, u, h, d); return f !== Si && So(p, xe(), f), $l } function zl(t, e, n, r, s, i, o, a, l, c, u, h, d, p, f) { const g = Kt(), m = ma(g, t, e, n, r, s, i, o, a, l, c, u, h, d, p, f); return m !== Si && So(g, xe(), m), zl } function Hl(t, e, n, r, s, i, o, a, l, c, u, h, d, p, f, g, m) { const _ = Kt(), y = _a(_, t, e, n, r, s, i, o, a, l, c, u, h, d, p, f, g, m); return y !== Si && So(_, xe(), y), Hl } function Gl(t) { const e = Kt(), n = ca(e, t); return n !== Si && So(e, xe(), n), Gl } function Zl(t, e, n) { Ol(Dn, Cl, ua(Kt(), t, e, n), !0) } function Wl(t, e, n, r, s) { Ol(Dn, Cl, ha(Kt(), t, e, n, r, s), !0) } function Kl(t, e, n, r, s, i, o) { Ol(Dn, Cl, da(Kt(), t, e, n, r, s, i, o), !0) } function Yl(t, e, n, r, s, i, o, a, l) { Ol(Dn, Cl, pa(Kt(), t, e, n, r, s, i, o, a, l), !0) } function Ql(t, e, n, r, s, i, o, a, l, c, u) { Ol(Dn, Cl, fa(Kt(), t, e, n, r, s, i, o, a, l, c, u), !0) } function Jl(t, e, n, r, s, i, o, a, l, c, u, h, d) { Ol(Dn, Cl, ga(Kt(), t, e, n, r, s, i, o, a, l, c, u, h, d), !0) } function Xl(t, e, n, r, s, i, o, a, l, c, u, h, d, p, f) { Ol(Dn, Cl, ma(Kt(), t, e, n, r, s, i, o, a, l, c, u, h, d, p, f), !0) } function tc(t, e, n, r, s, i, o, a, l, c, u, h, d, p, f, g, m) { Ol(Dn, Cl, _a(Kt(), t, e, n, r, s, i, o, a, l, c, u, h, d, p, f, g, m), !0) } function ec(t) { Ol(Dn, Cl, ca(Kt(), t), !0) } function nc(t, e, n) { wl(ua(Kt(), t, e, n)) } function rc(t, e, n, r, s) { wl(ha(Kt(), t, e, n, r, s)) } function sc(t, e, n, r, s, i, o) { wl(da(Kt(), t, e, n, r, s, i, o)) } function ic(t, e, n, r, s, i, o, a, l) { wl(pa(Kt(), t, e, n, r, s, i, o, a, l)) } function oc(t, e, n, r, s, i, o, a, l, c, u) { wl(fa(Kt(), t, e, n, r, s, i, o, a, l, c, u)) } function ac(t, e, n, r, s, i, o, a, l, c, u, h, d) { wl(ga(Kt(), t, e, n, r, s, i, o, a, l, c, u, h, d)) } function lc(t, e, n, r, s, i, o, a, l, c, u, h, d, p, f) { wl(ma(Kt(), t, e, n, r, s, i, o, a, l, c, u, h, d, p, f)) } function cc(t, e, n, r, s, i, o, a, l, c, u, h, d, p, f, g, m) { wl(_a(Kt(), t, e, n, r, s, i, o, a, l, c, u, h, d, p, f, g, m)) } function uc(t) { wl(ca(Kt(), t)) } function hc(t, e, n, r, s) { return xl(t, ua(Kt(), e, n, r), s, !1), hc } function dc(t, e, n, r, s, i, o) { return xl(t, ha(Kt(), e, n, r, s, i), o, !1), dc } function pc(t, e, n, r, s, i, o, a, l) { return xl(t, da(Kt(), e, n, r, s, i, o, a), l, !1), pc } function fc(t, e, n, r, s, i, o, a, l, c, u) { return xl(t, pa(Kt(), e, n, r, s, i, o, a, l, c), u, !1), fc } function gc(t, e, n, r, s, i, o, a, l, c, u, h, d) { return xl(t, fa(Kt(), e, n, r, s, i, o, a, l, c, u, h), d, !1), gc } function mc(t, e, n, r, s, i, o, a, l, c, u, h, d, p, f) { return xl(t, ga(Kt(), e, n, r, s, i, o, a, l, c, u, h, d, p), f, !1), mc } function _c(t, e, n, r, s, i, o, a, l, c, u, h, d, p, f, g, m) { return xl(t, ma(Kt(), e, n, r, s, i, o, a, l, c, u, h, d, p, f, g), m, !1), _c } function yc(t, e, n, r, s, i, o, a, l, c, u, h, d, p, f, g, m, _, y) { return xl(t, _a(Kt(), e, n, r, s, i, o, a, l, c, u, h, d, p, f, g, m, _), y, !1), yc } function vc(t, e, n) { return xl(t, ca(Kt(), e), n, !1), vc } function bc(t, e, n) { const r = Kt(); return sa(r, ce(), e) && Wi(Yt(), Te(), r, t, e, r[11], n, !0), bc } function wc(t, e, n) { const r = Kt(); if (sa(r, ce(), e)) { const s = Yt(), i = Te(); Wi(s, i, r, t, e, bo(fe(s.data), i, r), n, !0) } return wc } const Ec = void 0; var Sc = ["en", [["a", "p"], ["AM", "PM"], Ec], [["AM", "PM"], Ec, Ec], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], Ec, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], Ec, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", Ec, "{1} 'at' {0}", Ec], [".", ",", ";", "%", "+", "-", "E", "\xd7", "\u2030", "\u221e", "NaN", ":"], ["#,##0.###", "#,##0%", "\xa4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", function (t) { let e = Math.floor(Math.abs(t)), n = t.toString().replace(/^[^.]*\.?/, "").length; return 1 === e && 0 === n ? 1 : 5 }]; let Cc = {}; function xc(t) { const e = function (t) { return t.toLowerCase().replace(/_/g, "-") }(t); let n = Tc(e); if (n) return n; const r = e.split("-")[0]; if (n = Tc(r), n) return n; if ("en" === r) return Sc; throw new Error(`Missing locale data for the locale "${t}".`) } function Oc(t) { return xc(t)[Pc.PluralCase] } function Tc(t) { return t in Cc || (Cc[t] = B.ng && B.ng.common && B.ng.common.locales && B.ng.common.locales[t]), Cc[t] } var Pc = function (t) { return t[t.LocaleId = 0] = "LocaleId", t[t.DayPeriodsFormat = 1] = "DayPeriodsFormat", t[t.DayPeriodsStandalone = 2] = "DayPeriodsStandalone", t[t.DaysFormat = 3] = "DaysFormat", t[t.DaysStandalone = 4] = "DaysStandalone", t[t.MonthsFormat = 5] = "MonthsFormat", t[t.MonthsStandalone = 6] = "MonthsStandalone", t[t.Eras = 7] = "Eras", t[t.FirstDayOfWeek = 8] = "FirstDayOfWeek", t[t.WeekendRange = 9] = "WeekendRange", t[t.DateFormat = 10] = "DateFormat", t[t.TimeFormat = 11] = "TimeFormat", t[t.DateTimeFormat = 12] = "DateTimeFormat", t[t.NumberSymbols = 13] = "NumberSymbols", t[t.NumberFormats = 14] = "NumberFormats", t[t.CurrencyCode = 15] = "CurrencyCode", t[t.CurrencySymbol = 16] = "CurrencySymbol", t[t.CurrencyName = 17] = "CurrencyName", t[t.Currencies = 18] = "Currencies", t[t.Directionality = 19] = "Directionality", t[t.PluralCase = 20] = "PluralCase", t[t.ExtraData = 21] = "ExtraData", t }({}); const kc = ["zero", "one", "two", "few", "many"], Ac = "en-US", Ic = { marker: "element" }, Rc = { marker: "ICU" }; var Mc = function (t) { return t[t.SHIFT = 2] = "SHIFT", t[t.APPEND_EAGERLY = 1] = "APPEND_EAGERLY", t[t.COMMENT = 2] = "COMMENT", t }({}); let Dc = Ac; function Lc(t) { var e; null == (e = t) && b("Expected localeId to be defined", e, null, "!="), "string" == typeof t && (Dc = t.toLowerCase().replace(/_/g, "-")) } function Nc(t, e, n) { const r = e.insertBeforeIndex, s = Array.isArray(r) ? r[0] : r; return null === s ? Qs(t, 0, n) : Dt(n[s]) } function Fc(t, e, n, r, s) { const i = e.insertBeforeIndex; if (Array.isArray(i)) { let o = r, a = null; if (3 & e.type || (a = o, o = s), null !== o && 0 == (2 & e.flags)) for (let e = 1; e < i.length; e++)Gs(t, o, n[i[e]], a, !1) } } function jc(t, e) { if (t.push(e), t.length > 1) for (let n = t.length - 2; n >= 0; n--) { const r = t[n]; Uc(r) || Vc(r, e) && null === Bc(r) && qc(r, e.index) } } function Uc(t) { return !(64 & t.type) } function Vc(t, e) { return Uc(e) || t.index > e.index } function Bc(t) { const e = t.insertBeforeIndex; return Array.isArray(e) ? e[0] : e } function qc(t, e) { const n = t.insertBeforeIndex; Array.isArray(n) ? n[0] = e : (ti(Nc, Fc), t.insertBeforeIndex = e) } function $c(t, e) { const n = t.data[e]; return null === n || "string" == typeof n ? null : n.hasOwnProperty("currentCaseLViewIndex") ? n : n.value } function zc(t, e, n) { const r = Li(t, n, 64, null, null); return jc(e, r), r } function Hc(t, e) { const n = e[t.currentCaseLViewIndex]; return null === n ? n : n < 0 ? ~n : n } let Gc = 0, Zc = 0; function Wc(t, e, n, r) { const s = n[11]; let i, o = null; for (let a = 0; a < e.length; a++) { const l = e[a]; if ("string" == typeof l) { const t = e[++a]; null === n[t] && (n[t] = Ns(s, l)) } else if ("number" == typeof l) switch (1 & l) { case 0: const c = l >>> 17; let u, h; if (null === o && (o = c, i = Ks(s, r)), c === o ? (u = r, h = i) : (u = null, h = Dt(n[c])), null !== h) { const e = (131070 & l) >>> 1; Gs(s, h, n[e], u, !1); const r = $c(t, e); if (null !== r && "object" == typeof r) { const e = Hc(r, n); null !== e && Wc(t, r.create[e], n, n[r.anchorIdx]) } } break; case 1: const d = e[++a], p = e[++a]; so(s, Lt(l >>> 1, n), null, null, d, p, null); break; default: throw new Error(`Unable to determine the type of mutate operation for "${l}"`) } else switch (l) { case Rc: const t = e[++a], r = e[++a]; null === n[r] && gs(n[r] = js(s, t), n); break; case Ic: const i = e[++a], o = e[++a]; null === n[o] && gs(n[o] = Us(s, i, null), n) } } } function Kc(t, e, n, r, s) { for (let i = 0; i < n.length; i++) { const o = n[i], a = n[++i]; if (o & s) { let s = ""; for (let o = i + 1; o <= i + a; o++) { const i = n[o]; if ("string" == typeof i) s += i; else if ("number" == typeof i) if (i < 0) s += _(e[r - i]); else { const a = i >>> 2; switch (3 & i) { case 1: const i = n[++o], l = n[++o], c = t.data[a]; "string" == typeof c ? so(e[11], e[a], null, c, i, s, l) : Wi(t, c, e, i, s, e[11], l, !1); break; case 0: const u = e[a]; null !== u && Fs(e[11], u, s); break; case 2: Qc(t, $c(t, a), e, s); break; case 3: Yc(t, $c(t, a), r, e) } } } } else { const s = n[i + 1]; if (s > 0 && 3 == (3 & s)) { const n = $c(t, s >>> 2); e[n.currentCaseLViewIndex] < 0 && Yc(t, n, r, e) } } i += a } } function Yc(t, e, n, r) { let s = r[e.currentCaseLViewIndex]; if (null !== s) { let i = Gc; s < 0 && (s = r[e.currentCaseLViewIndex] = ~s, i = -1), Kc(t, r, e.update[s], n, i) } } function Qc(t, e, n, r) { const s = function (t, e) { let n = t.cases.indexOf(e); if (-1 === n) switch (t.type) { case 1: { const r = function (t, e) { const n = Oc(e)(parseInt(t, 10)), r = kc[n]; return void 0 !== r ? r : "other" }(e, Dc); n = t.cases.indexOf(r), -1 === n && "other" !== r && (n = t.cases.indexOf("other")); break } case 0: n = t.cases.indexOf("other") }return -1 === n ? null : n }(e, r); if (Hc(e, n) !== s && (Jc(t, e, n), n[e.currentCaseLViewIndex] = null === s ? null : ~s, null !== s)) { const r = n[e.anchorIdx]; r && Wc(t, e.create[s], n, r) } } function Jc(t, e, n) { let r = Hc(e, n); if (null !== r) { const s = e.remove[r]; for (let e = 0; e < s.length; e++) { const r = s[e]; if (r > 0) { const t = Lt(r, n); null !== t && ii(n[11], t) } else Jc(t, $c(t, ~r), n) } } } const Xc = /\ufffd(\d+):?\d*\ufffd/gi, tu = /({\s*\ufffd\d+:?\d*\ufffd\s*,\s*\S{6}\s*,[\s\S]*})/gi, eu = /\ufffd(\d+)\ufffd/, nu = /^\s*(\ufffd\d+:?\d*\ufffd)\s*,\s*(select|plural)\s*,/, ru = /\ufffd\/?\*(\d+:\d+)\ufffd/gi, su = /\ufffd(\/?[#*]\d+):?\d*\ufffd/gi, iu = /\uE500/g; function ou(t, e, n, r, s, i, o) { const a = Ni(t, r, 1, null); let l = a << Mc.SHIFT, c = te(); e === c && (c = null), null === c && (l |= Mc.APPEND_EAGERLY), o && (l |= Mc.COMMENT, void 0 === ks && (ks = function () { const t = []; let e, n, r = -1; function s(t, e) { r = 0; const s = Hc(t, e); n = null !== s ? t.remove[s] : $ } function i() { if (r < n.length) { const o = n[r++]; return o > 0 ? e[o] : (t.push(r, n), s(e[1].data[~o], e), i()) } return 0 === t.length ? null : (n = t.pop(), r = t.pop(), i()) } return function (n, r) { for (e = r; t.length;)t.pop(); return s(n.value, r), i } }())), s.push(l, null === i ? "" : i); const u = Li(t, a, o ? 32 : 1, null === i ? "" : i, null); jc(n, u); const h = u.index; return ee(u, !1), null !== c && e !== c && function (t, e) { let n = t.insertBeforeIndex; var r; null === n ? (ti(Nc, Fc), n = t.insertBeforeIndex = [null, e]) : ("Expecting array here", (r = Array.isArray(n)) != !0 && b("Expecting array here", r, true, "=="), n.push(e)) }(c, h), u } function au(t, e, n, r, s, i, o) { const a = o.match(Xc), l = ou(t, e, n, i, r, a ? null : o, !1); a && lu(s, o, l.index, null, 0, null) } function lu(t, e, n, r, s, i) { const o = t.length, a = o + 1; t.push(null, null); const l = o + 2, c = e.split(Xc); let u = 0; for (let h = 0; h < c.length; h++) { const e = c[h]; if (1 & h) { const n = s + parseInt(e, 10); t.push(-1 - n), u |= uu(n) } else "" !== e && t.push(e) } return t.push(n << 2 | (r ? 1 : 0)), r && t.push(r, i), t[o] = u, t[a] = t.length - l, u } function cu(t) { let e = 0; for (let n = 0; n < t.length; n++) { const r = t[n]; "number" == typeof r && r < 0 && e++ } return e } function uu(t) { return 1 << Math.min(t, 31) } function hu(t) { let e, n, r = "", s = 0, i = !1; for (; null !== (e = ru.exec(t));)i ? e[0] === `\ufffd/*${n}\ufffd` && (s = e.index, i = !1) : (r += t.substring(s, e.index + e[0].length), n = e[1], i = !0); return r += t.substr(s), r } function du(t, e, n, r, s, i) { let o = 0; const a = { type: s.type, currentCaseLViewIndex: Ni(t, e, 1, null), anchorIdx: i, cases: [], create: [], remove: [], update: [] }; !function (t, e, n) { t.push(uu(e.mainBinding), 2, -1 - e.mainBinding, n << 2 | 2) }(n, s, i), function (t, e, n) { const r = t.data[e]; null === r ? t.data[e] = n : r.value = n }(t, i, a); const l = s.values; for (let c = 0; c < l.length; c++) { const i = l[c], u = []; for (let t = 0; t < i.length; t++) { const e = i[t]; if ("string" != typeof e) { const n = u.push(e) - 1; i[t] = `\x3c!--\ufffd${n}\ufffd--\x3e` } } o = gu(t, a, e, n, r, s.cases[c], i.join(""), u) | o } o && function (t, e, n) { t.push(e, 1, n << 2 | 3) }(n, o, i) } function pu(t) { const e = [], n = []; let r = 1, s = 0; const i = fu(t = t.replace(nu, function (t, e, n) { return r = "select" === n ? 0 : 1, s = parseInt(e.substr(1), 10), "" })); for (let o = 0; o < i.length;) { let t = i[o++].trim(); 1 === r && (t = t.replace(/\s*(?:=)?(\w+)\s*/, "$1")), t.length && e.push(t); const s = fu(i[o++]); e.length > n.length && n.push(s) } return { type: r, mainBinding: s, cases: e, values: n } } function fu(t) { if (!t) return []; let e = 0; const n = [], r = [], s = /[{}]/g; let i; for (s.lastIndex = 0; i = s.exec(t);) { const s = i.index; if ("}" == i[0]) { if (n.pop(), 0 == n.length) { const n = t.substring(e, s); nu.test(n) ? r.push(pu(n)) : r.push(n), e = s + 1 } } else { if (0 == n.length) { const n = t.substring(e, s); r.push(n), e = s + 1 } n.push("{") } } const o = t.substring(e); return r.push(o), r } function gu(t, e, n, r, s, i, o, a) { const l = [], c = [], u = []; e.cases.push(i), e.create.push(l), e.remove.push(c), e.update.push(u); const h = Dr(It()).getInertBodyElement(o), d = ss(h) || h; return d ? mu(t, e, n, r, l, c, u, d, s, a, 0) : 0 } function mu(t, e, n, r, s, i, o, a, l, c, u) { let h = 0, d = a.firstChild; for (; d;) { const a = Ni(t, n, 1, null); switch (d.nodeType) { case Node.ELEMENT_NODE: const p = d, f = p.tagName.toLowerCase(); if (Zr.hasOwnProperty(f)) { vu(s, Ic, f, l, a), t.data[a] = f; const g = p.attributes; for (let t = 0; t < g.length; t++) { const e = g.item(t), n = e.name.toLowerCase(); e.value.match(Xc) ? Yr.hasOwnProperty(n) && lu(o, e.value, a, e.name, 0, Wr[n] ? Ur : Kr[n] ? Vr : null) : bu(s, a, e) } h = mu(t, e, n, r, s, i, o, d, a, c, u + 1) | h, _u(i, a, u) } break; case Node.TEXT_NODE: const g = d.textContent || "", m = g.match(Xc); vu(s, null, m ? "" : g, l, a), _u(i, a, u), m && (h = lu(o, g, a, null, 0, null) | h); break; case Node.COMMENT_NODE: const _ = eu.exec(d.textContent || ""); if (_) { const e = c[parseInt(_[1], 10)]; vu(s, Rc, "", l, a), du(t, n, r, l, e, a), yu(i, a, u) } }d = d.nextSibling } return h } function _u(t, e, n) { 0 === n && t.push(e) } function yu(t, e, n) { 0 === n && (t.push(~e), t.push(e)) } function vu(t, e, n, r, s) { null !== e && t.push(e), t.push(n, s, 0 | r << 17 | s << 1) } function bu(t, e, n) { t.push(e << 1 | 1, n.name, n.value) } const wu = /\[(\ufffd.+?\ufffd?)\]/, Eu = /\[(\ufffd.+?\ufffd?)\]|(\ufffd\/?\*\d+:\d+\ufffd)/g, Su = /({\s*)(VAR_(PLURAL|SELECT)(_\d+)?)(\s*,)/g, Cu = /{([A-Z0-9_]+)}/g, xu = /\ufffdI18N_EXP_(ICU(_\d+)?)\ufffd/g, Ou = /\/\*/, Tu = /\d+\:(\d+)/; function Pu(t, e, n = -1) { const r = Yt(), s = Kt(), i = dt + t, o = qt(r.consts, e), a = te(); r.firstCreatePass && function (t, e, n, r, s, i) { const o = te(), a = [], l = [], c = [[]], u = (h = s = function (t, e) { if (function (t) { return -1 === t }(e)) return hu(t); { const n = t.indexOf(`:${e}\ufffd`) + 2 + e.toString().length, r = t.search(new RegExp(`\ufffd\\/\\*\\d+:${e}\ufffd`)); return hu(t.substring(n, r)) } }(s, i), h.replace(iu, " ")).split(su); var h; for (let d = 0; d < u.length; d++) { let r = u[d]; if (0 == (1 & d)) { const i = fu(r); for (let r = 0; r < i.length; r++) { let u = i[r]; if (0 == (1 & r)) { const e = u; "" !== e && au(t, o, c[0], a, l, n, e) } else { const r = u; if ("object" != typeof r) throw new Error(`Unable to parse ICU expression in "${s}" message.`); du(t, n, l, e, r, ou(t, o, c[0], n, a, "", !0).index) } } } else { const e = 47 === r.charCodeAt(0), n = (r.charCodeAt(e ? 1 : 0), dt + Number.parseInt(r.substring(e ? 2 : 1))); if (e) c.shift(), ee(te(), !1); else { const e = zc(t, c[0], n); c.unshift([]), ee(e, !0) } } } t.data[r] = { create: a, update: l } }(r, null === a ? 0 : a.index, s, i, o, n); const l = r.data[i], c = Hs(r, a === s[6] ? null : a, s); !function (t, e, n, r) { const s = t[11]; for (let i = 0; i < e.length; i++) { const o = e[i++], a = e[i], l = (o & Mc.COMMENT) === Mc.COMMENT, c = (o & Mc.APPEND_EAGERLY) === Mc.APPEND_EAGERLY, u = o >>> Mc.SHIFT; let h = t[u]; null === h && (h = t[u] = l ? s.createComment(a) : Ns(s, a)), c && null !== n && Gs(s, n, h, r, !1) } }(s, l.create, c, a && 8 & a.type ? s[a.index] : null), he(!0) } function ku() { he(!1) } function Au(t, e, n) { Pu(t, e, n), ku() } function Iu(t, e) { const n = Yt(), r = qt(n.consts, e); !function (t, e, n) { const r = Jt().index, s = []; if (t.firstCreatePass && null === t.data[e]) { for (let t = 0; t < n.length; t += 2) { const e = n[t], i = n[t + 1]; if ("" !== i) { if (tu.test(i)) throw new Error(`ICU expressions are not supported in attributes. Message: "${i}".`); lu(s, i, r, e, cu(s), null) } } t.data[e] = s } }(n, t + dt, r) } function Ru(t) { return sa(Kt(), ce(), t) && (Gc |= 1 << Math.min(Zc, 31)), Zc++, Ru } function Mu(t) { !function (t, e, n) { if (Zc > 0) { const r = t.data[n]; Kc(t, e, Array.isArray(r) ? r : r.update, ae() - Zc - 1, Gc) } Gc = 0, Zc = 0 }(Yt(), Kt(), t + dt) } function Du(t, e = {}) { return function (t, e = {}) { let n = t; if (wu.test(t)) { const t = {}, e = [0]; n = n.replace(Eu, (n, r, s) => { const i = r || s, o = t[i] || []; if (o.length || (i.split("|").forEach(t => { const e = t.match(Tu), n = e ? parseInt(e[1], 10) : 0, r = Ou.test(t); o.push([n, r, t]) }), t[i] = o), !o.length) throw new Error(`i18n postprocess: unmatched placeholder - ${i}`); const a = e[e.length - 1]; let l = 0; for (let t = 0; t < o.length; t++)if (o[t][0] === a) { l = t; break } const [c, u, h] = o[l]; return u ? e.pop() : a !== c && e.push(c), o.splice(l, 1), h }) } return Object.keys(e).length ? (n = n.replace(Su, (t, n, r, s, i, o) => e.hasOwnProperty(r) ? `${n}${e[r]}${o}` : t), n = n.replace(Cu, (t, n) => e.hasOwnProperty(n) ? e[n] : t), n = n.replace(xu, (t, n) => { if (e.hasOwnProperty(n)) { const r = e[n]; if (!r.length) throw new Error(`i18n postprocess: unmatched ICU - ${t} with key: ${n}`); return r.shift() } return t }), n) : n }(t, e) } function Lu(t, e, n, r, s) { if (t = f(t), Array.isArray(t)) for (let i = 0; i < t.length; i++)Lu(t[i], e, n, r, s); else { const i = Yt(), o = Kt(); let a = jo(t) ? t : f(t.provide), l = Lo(t); const c = Jt(), u = 1048575 & c.providerIndexes, h = c.directiveStart, d = c.providerIndexes >> 20; if (jo(t) || !t.multi) { const r = new je(l, s, ka), p = ju(a, e, s ? u : u + d, h); -1 === p ? (tn(Ye(c, o), i, a), Nu(i, t, e.length), e.push(a), c.directiveStart++, c.directiveEnd++, s && (c.providerIndexes += 1048576), n.push(r), o.push(r)) : (n[p] = r, o[p] = r) } else { const p = ju(a, e, u + d, h), f = ju(a, e, u, u + d), g = p >= 0 && n[p], m = f >= 0 && n[f]; if (s && !m || !s && !g) { tn(Ye(c, o), i, a); const u = function (t, e, n, r, s) { const i = new je(t, n, ka); return i.multi = [], i.index = e, i.componentProviders = 0, Fu(i, s, r && !n), i }(s ? Vu : Uu, n.length, s, r, l); !s && m && (n[f].providerFactory = u), Nu(i, t, e.length, 0), e.push(a), c.directiveStart++, c.directiveEnd++, s && (c.providerIndexes += 1048576), n.push(u), o.push(u) } else Nu(i, t, p > -1 ? p : f, Fu(n[s ? f : p], l, !s && r)); !s && r && m && n[f].componentProviders++ } } } function Nu(t, e, n, r) { const s = jo(e); if (s || e.useClass) { const i = (e.useClass || e).prototype.ngOnDestroy; if (i) { const o = t.destroyHooks || (t.destroyHooks = []); if (!s && e.multi) { const t = o.indexOf(n); -1 === t ? o.push(n, [r, i]) : o[t + 1].push(r, i) } else o.push(n, i) } } } function Fu(t, e, n) { return n && t.componentProviders++, t.multi.push(e) - 1 } function ju(t, e, n, r) { for (let s = n; s < r; s++)if (e[s] === t) return s; return -1 } function Uu(t, e, n, r) { return Bu(this.multi, []) } function Vu(t, e, n, r) { const s = this.multi; let i; if (this.providerFactory) { const t = this.providerFactory.componentProviders, e = cn(n, n[1], this.providerFactory.index, r); i = e.slice(0, t), Bu(s, i); for (let n = t; n < e.length; n++)i.push(e[n]) } else i = [], Bu(s, i); return i } function Bu(t, e) { for (let n = 0; n < t.length; n++)e.push((0, t[n])()); return e } function qu(t, e = []) { return n => { n.providersResolver = (n, r) => function (t, e, n) { const r = Yt(); if (r.firstCreatePass) { const s = vt(t); Lu(n, r.data, r.blueprint, s, !0), Lu(e, r.data, r.blueprint, s, !1) } }(n, r ? r(t) : t, e) } } class $u { } class zu { resolveComponentFactory(t) { throw function (t) { const e = Error(`No component factory found for ${u(t)}. Did you add it to @NgModule.entryComponents?`); return e.ngComponent = t, e }(t) } } let Hu = (() => { class t { } return t.NULL = new zu, t })(); function Gu(...t) { } function Zu(t, e) { return new Ku(Nt(t, e)) } const Wu = function () { return Zu(Jt(), Kt()) }; let Ku = (() => { class t { constructor(t) { this.nativeElement = t } } return t.__NG_ELEMENT_ID__ = Wu, t })(); function Yu(t) { return t instanceof Ku ? t.nativeElement : t } class Qu { } let Ju = (() => { class t { } return t.__NG_ELEMENT_ID__ = () => Xu(), t })(); const Xu = function () { const t = Kt(), e = Ut(Jt().index, t); return function (t) { return t[11] }(ft(e) ? e : t) }; let th = (() => { class t { } return t.\u0275prov = w({ token: t, providedIn: "root", factory: () => null }), t })(); class eh { constructor(t) { this.full = t, this.major = t.split(".")[0], this.minor = t.split(".")[1], this.patch = t.split(".").slice(2).join(".") } } const nh = new eh("12.0.5"); class rh { constructor() { } supports(t) { return ta(t) } create(t) { return new ih(t) } } const sh = (t, e) => e; class ih { constructor(t) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = t || sh } forEachItem(t) { let e; for (e = this._itHead; null !== e; e = e._next)t(e) } forEachOperation(t) { let e = this._itHead, n = this._removalsHead, r = 0, s = null; for (; e || n;) { const i = !n || e && e.currentIndex < ch(n, r, s) ? e : n, o = ch(i, r, s), a = i.currentIndex; if (i === n) r--, n = n._nextRemoved; else if (e = e._next, null == i.previousIndex) r++; else { s || (s = []); const t = o - r, e = a - r; if (t != e) { for (let n = 0; n < t; n++) { const r = n < s.length ? s[n] : s[n] = 0, i = r + n; e <= i && i < t && (s[n] = r + 1) } s[i.previousIndex] = e - t } } o !== a && t(i, o, a) } } forEachPreviousItem(t) { let e; for (e = this._previousItHead; null !== e; e = e._nextPrevious)t(e) } forEachAddedItem(t) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded)t(e) } forEachMovedItem(t) { let e; for (e = this._movesHead; null !== e; e = e._nextMoved)t(e) } forEachRemovedItem(t) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved)t(e) } forEachIdentityChange(t) { let e; for (e = this._identityChangesHead; null !== e; e = e._nextIdentityChange)t(e) } diff(t) { if (null == t && (t = []), !ta(t)) throw new Error(`Error trying to diff '${u(t)}'. Only arrays and iterables are allowed`); return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let e, n, r, s = this._itHead, i = !1; if (Array.isArray(t)) { this.length = t.length; for (let e = 0; e < this.length; e++)n = t[e], r = this._trackByFn(e, n), null !== s && Object.is(s.trackById, r) ? (i && (s = this._verifyReinsertion(s, n, r, e)), Object.is(s.item, n) || this._addIdentityChange(s, n)) : (s = this._mismatch(s, n, r, e), i = !0), s = s._next } else e = 0, function (t, e) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++)e(t[n]); else { const n = t[Jo()](); let r; for (; !(r = n.next()).done;)e(r.value) } }(t, t => { r = this._trackByFn(e, t), null !== s && Object.is(s.trackById, r) ? (i && (s = this._verifyReinsertion(s, t, r, e)), Object.is(s.item, t) || this._addIdentityChange(s, t)) : (s = this._mismatch(s, t, r, e), i = !0), s = s._next, e++ }), this.length = e; return this._truncate(s), this.collection = t, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let t; for (t = this._previousItHead = this._itHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._additionsHead; null !== t; t = t._nextAdded)t.previousIndex = t.currentIndex; for (this._additionsHead = this._additionsTail = null, t = this._movesHead; null !== t; t = t._nextMoved)t.previousIndex = t.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(t, e, n, r) { let s; return null === t ? s = this._itTail : (s = t._prev, this._remove(t)), null !== (t = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(n, null)) ? (Object.is(t.item, e) || this._addIdentityChange(t, e), this._reinsertAfter(t, s, r)) : null !== (t = null === this._linkedRecords ? null : this._linkedRecords.get(n, r)) ? (Object.is(t.item, e) || this._addIdentityChange(t, e), this._moveAfter(t, s, r)) : t = this._addAfter(new oh(e, n), s, r), t } _verifyReinsertion(t, e, n, r) { let s = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(n, null); return null !== s ? t = this._reinsertAfter(s, t._prev, r) : t.currentIndex != r && (t.currentIndex = r, this._addToMoves(t, r)), t } _truncate(t) { for (; null !== t;) { const e = t._next; this._addToRemovals(this._unlink(t)), t = e } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(t, e, n) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(t); const r = t._prevRemoved, s = t._nextRemoved; return null === r ? this._removalsHead = s : r._nextRemoved = s, null === s ? this._removalsTail = r : s._prevRemoved = r, this._insertAfter(t, e, n), this._addToMoves(t, n), t } _moveAfter(t, e, n) { return this._unlink(t), this._insertAfter(t, e, n), this._addToMoves(t, n), t } _addAfter(t, e, n) { return this._insertAfter(t, e, n), this._additionsTail = null === this._additionsTail ? this._additionsHead = t : this._additionsTail._nextAdded = t, t } _insertAfter(t, e, n) { const r = null === e ? this._itHead : e._next; return t._next = r, t._prev = e, null === r ? this._itTail = t : r._prev = t, null === e ? this._itHead = t : e._next = t, null === this._linkedRecords && (this._linkedRecords = new lh), this._linkedRecords.put(t), t.currentIndex = n, t } _remove(t) { return this._addToRemovals(this._unlink(t)) } _unlink(t) { null !== this._linkedRecords && this._linkedRecords.remove(t); const e = t._prev, n = t._next; return null === e ? this._itHead = n : e._next = n, null === n ? this._itTail = e : n._prev = e, t } _addToMoves(t, e) { return t.previousIndex === e || (this._movesTail = null === this._movesTail ? this._movesHead = t : this._movesTail._nextMoved = t), t } _addToRemovals(t) { return null === this._unlinkedRecords && (this._unlinkedRecords = new lh), this._unlinkedRecords.put(t), t.currentIndex = null, t._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = t, t._prevRemoved = null) : (t._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = t), t } _addIdentityChange(t, e) { return t.item = e, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = t : this._identityChangesTail._nextIdentityChange = t, t } } class oh { constructor(t, e) { this.item = t, this.trackById = e, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class ah { constructor() { this._head = null, this._tail = null } add(t) { null === this._head ? (this._head = this._tail = t, t._nextDup = null, t._prevDup = null) : (this._tail._nextDup = t, t._prevDup = this._tail, t._nextDup = null, this._tail = t) } get(t, e) { let n; for (n = this._head; null !== n; n = n._nextDup)if ((null === e || e <= n.currentIndex) && Object.is(n.trackById, t)) return n; return null } remove(t) { const e = t._prevDup, n = t._nextDup; return null === e ? this._head = n : e._nextDup = n, null === n ? this._tail = e : n._prevDup = e, null === this._head } } class lh { constructor() { this.map = new Map } put(t) { const e = t.trackById; let n = this.map.get(e); n || (n = new ah, this.map.set(e, n)), n.add(t) } get(t, e) { const n = this.map.get(t); return n ? n.get(t, e) : null } remove(t) { const e = t.trackById; return this.map.get(e).remove(t) && this.map.delete(e), t } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function ch(t, e, n) { const r = t.previousIndex; if (null === r) return r; let s = 0; return n && r < n.length && (s = n[r]), r + e + s } class uh { constructor() { } supports(t) { return t instanceof Map || ea(t) } create() { return new hh } } class hh { constructor() { this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null } get isDirty() { return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead } forEachItem(t) { let e; for (e = this._mapHead; null !== e; e = e._next)t(e) } forEachPreviousItem(t) { let e; for (e = this._previousMapHead; null !== e; e = e._nextPrevious)t(e) } forEachChangedItem(t) { let e; for (e = this._changesHead; null !== e; e = e._nextChanged)t(e) } forEachAddedItem(t) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded)t(e) } forEachRemovedItem(t) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved)t(e) } diff(t) { if (t) { if (!(t instanceof Map || ea(t))) throw new Error(`Error trying to diff '${u(t)}'. Only maps and objects are allowed`) } else t = new Map; return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let e = this._mapHead; if (this._appendAfter = null, this._forEach(t, (t, n) => { if (e && e.key === n) this._maybeAddToChanges(e, t), this._appendAfter = e, e = e._next; else { const r = this._getOrCreateRecordForKey(n, t); e = this._insertBeforeOrAppend(e, r) } }), e) { e._prev && (e._prev._next = null), this._removalsHead = e; for (let t = e; null !== t; t = t._nextRemoved)t === this._mapHead && (this._mapHead = null), this._records.delete(t.key), t._nextRemoved = t._next, t.previousValue = t.currentValue, t.currentValue = null, t._prev = null, t._next = null } return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty } _insertBeforeOrAppend(t, e) { if (t) { const n = t._prev; return e._next = t, e._prev = n, t._prev = e, n && (n._next = e), t === this._mapHead && (this._mapHead = e), this._appendAfter = t, t } return this._appendAfter ? (this._appendAfter._next = e, e._prev = this._appendAfter) : this._mapHead = e, this._appendAfter = e, null } _getOrCreateRecordForKey(t, e) { if (this._records.has(t)) { const n = this._records.get(t); this._maybeAddToChanges(n, e); const r = n._prev, s = n._next; return r && (r._next = s), s && (s._prev = r), n._next = null, n._prev = null, n } const n = new dh(t); return this._records.set(t, n), n.currentValue = e, this._addToAdditions(n), n } _reset() { if (this.isDirty) { let t; for (this._previousMapHead = this._mapHead, t = this._previousMapHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._changesHead; null !== t; t = t._nextChanged)t.previousValue = t.currentValue; for (t = this._additionsHead; null != t; t = t._nextAdded)t.previousValue = t.currentValue; this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null } } _maybeAddToChanges(t, e) { Object.is(e, t.currentValue) || (t.previousValue = t.currentValue, t.currentValue = e, this._addToChanges(t)) } _addToAdditions(t) { null === this._additionsHead ? this._additionsHead = this._additionsTail = t : (this._additionsTail._nextAdded = t, this._additionsTail = t) } _addToChanges(t) { null === this._changesHead ? this._changesHead = this._changesTail = t : (this._changesTail._nextChanged = t, this._changesTail = t) } _forEach(t, e) { t instanceof Map ? t.forEach(e) : Object.keys(t).forEach(n => e(t[n], n)) } } class dh { constructor(t) { this.key = t, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null } } function ph() { return new fh([new rh]) } let fh = (() => { class t { constructor(t) { this.factories = t } static create(e, n) { if (null != n) { const t = n.factories.slice(); e = e.concat(t) } return new t(e) } static extend(e) { return { provide: t, useFactory: n => t.create(e, n || ph()), deps: [[t, new sr, new nr]] } } find(t) { const e = this.factories.find(e => e.supports(t)); if (null != e) return e; throw new Error(`Cannot find a differ supporting object '${t}' of type '${n = t, n.name || typeof n}'`); var n } } return t.\u0275prov = w({ token: t, providedIn: "root", factory: ph }), t })(); function gh() { return new mh([new uh]) } let mh = (() => { class t { constructor(t) { this.factories = t } static create(e, n) { if (n) { const t = n.factories.slice(); e = e.concat(t) } return new t(e) } static extend(e) { return { provide: t, useFactory: n => t.create(e, n || gh()), deps: [[t, new sr, new nr]] } } find(t) { const e = this.factories.find(e => e.supports(t)); if (e) return e; throw new Error(`Cannot find a differ supporting object '${t}'`) } } return t.\u0275prov = w({ token: t, providedIn: "root", factory: gh }), t })(); function _h(t, e, n, r, s = !1) { for (; null !== n;) { const i = e[n.index]; if (null !== i && r.push(Dt(i)), gt(i)) for (let t = pt; t < i.length; t++) { const e = i[t], n = e[1].firstChild; null !== n && _h(e[1], e, n, r) } const o = n.type; if (8 & o) _h(t, e, n.child, r); else if (32 & o) { const t = As(n, e); let s; for (; s = t();)r.push(s) } else if (16 & o) { const t = ri(e, n); if (Array.isArray(t)) r.push(...t); else { const n = Is(e[16]); _h(n[1], n, t, r, !0) } } n = s ? n.projectionNext : n.next } return r } class yh { constructor(t, e) { this._lView = t, this._cdRefInjectingView = e, this._appRef = null, this._attachedToViewContainer = !1 } get rootNodes() { const t = this._lView, e = t[1]; return _h(e, t, e.firstChild, []) } get context() { return this._lView[8] } set context(t) { this._lView[8] = t } get destroyed() { return 256 == (256 & this._lView[2]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const t = this._lView[3]; if (gt(t)) { const e = t[8], n = e ? e.indexOf(this) : -1; n > -1 && (Bs(t, n), Rn(e, n)) } this._attachedToViewContainer = !1 } qs(this._lView[1], this._lView) } onDestroy(t) { Gi(this._lView[1], this._lView, null, t) } markForCheck() { po(this._cdRefInjectingView || this._lView) } detach() { this._lView[2] &= -129 } reattach() { this._lView[2] |= 128 } detectChanges() { fo(this._lView[1], this._lView, this.context) } checkNoChanges() { !function (t, e, n) { ie(!0); try { fo(t, e, n) } finally { ie(!1) } }(this._lView[1], this._lView, this.context) } attachToViewContainerRef() { if (this._appRef) throw new Error("This view is already attached directly to the ApplicationRef!"); this._attachedToViewContainer = !0 } detachFromAppRef() { var t; this._appRef = null, ai(this._lView[1], t = this._lView, t[11], 2, null, null) } attachToAppRef(t) { if (this._attachedToViewContainer) throw new Error("This view is already attached to a ViewContainer!"); this._appRef = t } } class vh extends yh { constructor(t) { super(t), this._view = t } detectChanges() { go(this._view) } checkNoChanges() { !function (t) { ie(!0); try { go(t) } finally { ie(!1) } }(this._view) } get context() { return null } } const bh = function (t) { return function (t, e, n) { if (_t(t) && !n) { const n = Ut(t.index, e); return new yh(n, n) } return 47 & t.type ? new yh(e[16], e) : null }(Jt(), Kt(), 16 == (16 & t)) }; let wh = (() => { class t { } return t.__NG_ELEMENT_ID__ = bh, t })(); const Eh = [new uh], Sh = new fh([new rh]), Ch = new mh(Eh), xh = function () { return kh(Jt(), Kt()) }; let Oh = (() => { class t { } return t.__NG_ELEMENT_ID__ = xh, t })(); const Th = Oh, Ph = class extends Th { constructor(t, e, n) { super(), this._declarationLView = t, this._declarationTContainer = e, this.elementRef = n } createEmbeddedView(t) { const e = this._declarationTContainer.tViews, n = Mi(this._declarationLView, e, t, 16, null, e.declTNode, null, null, null, null); n[17] = this._declarationLView[this._declarationTContainer.index]; const r = this._declarationLView[19]; return null !== r && (n[19] = r.createEmbeddedView(e)), Fi(e, n, t), new yh(n) } }; function kh(t, e) { return 4 & t.type ? new Ph(e, t, Zu(t, e)) : null } class Ah { } class Ih { } const Rh = function () { return jh(Jt(), Kt()) }; let Mh = (() => { class t { } return t.__NG_ELEMENT_ID__ = Rh, t })(); const Dh = Mh, Lh = class extends Dh { constructor(t, e, n) { super(), this._lContainer = t, this._hostTNode = e, this._hostLView = n } get element() { return Zu(this._hostTNode, this._hostLView) } get injector() { return new dn(this._hostTNode, this._hostLView) } get parentInjector() { const t = Xe(this._hostTNode, this._hostLView); if (ze(t)) { const e = Ge(t, this._hostLView), n = He(t); return new dn(e[1].data[n + 8], e) } return new dn(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(t) { const e = Nh(this._lContainer); return null !== e && e[t] || null } get length() { return this._lContainer.length - pt } createEmbeddedView(t, e, n) { const r = t.createEmbeddedView(e || {}); return this.insert(r, n), r } createComponent(t, e, n, r, s) { const i = n || this.parentInjector; if (!s && null == t.ngModule && i) { const t = i.get(Ah, null); t && (s = t) } const o = t.create(i, r, void 0, s); return this.insert(o.hostView, e), o } insert(t, e) { const n = t._lView, r = n[1]; if (gt(n[3])) { const e = this.indexOf(t); if (-1 !== e) this.detach(e); else { const e = n[3], r = new Lh(e, e[6], e[3]); r.detach(r.indexOf(t)) } } const s = this._adjustIndex(e), i = this._lContainer; !function (t, e, n, r) { const s = pt + r, i = n.length; r > 0 && (n[s - 1][4] = e), r < i - pt ? (e[4] = n[s], In(n, pt + r, e)) : (n.push(e), e[4] = null), e[3] = n; const o = e[17]; null !== o && n !== o && function (t, e) { const n = t[9]; e[16] !== e[3][3][16] && (t[2] = !0), null === n ? t[9] = [e] : n.push(e) }(o, e); const a = e[19]; null !== a && a.insertView(t), e[2] |= 128 }(r, n, i, s); const o = si(s, i), a = n[11], l = Ks(a, i[7]); return null !== l && function (t, e, n, r, s, i) { r[0] = s, r[6] = e, ai(t, r, n, 1, s, i) }(r, i[6], a, n, l, o), t.attachToViewContainerRef(), In(Fh(i), s, t), t } move(t, e) { return this.insert(t, e) } indexOf(t) { const e = Nh(this._lContainer); return null !== e ? e.indexOf(t) : -1 } remove(t) { const e = this._adjustIndex(t, -1), n = Bs(this._lContainer, e); n && (Rn(Fh(this._lContainer), e), qs(n[1], n)) } detach(t) { const e = this._adjustIndex(t, -1), n = Bs(this._lContainer, e); return n && null != Rn(Fh(this._lContainer), e) ? new yh(n) : null } _adjustIndex(t, e = 0) { return null == t ? this.length + e : t } }; function Nh(t) { return t[8] } function Fh(t) { return t[8] || (t[8] = []) } function jh(t, e) { let n; const r = e[t.index]; if (gt(r)) n = r; else { let s; if (8 & t.type) s = Dt(r); else { const n = e[11]; s = n.createComment(""); const r = Nt(t, e); Gs(n, Ks(n, r), s, function (t, e) { return Rt(t) ? t.nextSibling(e) : e.nextSibling }(n, r), !1) } e[t.index] = n = ao(r, e, s, t), ho(e, n) } return new Lh(n, t, e) } const Uh = {}; class Vh extends Hu { constructor(t) { super(), this.ngModule = t } resolveComponentFactory(t) { const e = lt(t); return new $h(e, this.ngModule) } } function Bh(t) { const e = []; for (let n in t) t.hasOwnProperty(n) && e.push({ propName: t[n], templateName: n }); return e } const qh = new Cn("SCHEDULER_TOKEN", { providedIn: "root", factory: () => Ss }); class $h extends $u { constructor(t, e) { super(), this.componentDef = t, this.ngModule = e, this.componentType = t.type, this.selector = t.selectors.map(Ei).join(","), this.ngContentSelectors = t.ngContentSelectors ? t.ngContentSelectors : [], this.isBoundToModule = !!e } get inputs() { return Bh(this.componentDef.inputs) } get outputs() { return Bh(this.componentDef.outputs) } create(t, e, n, r) { const s = (r = r || this.ngModule) ? function (t, e) { return { get: (n, r, s) => { const i = t.get(n, Uh, s); return i !== Uh || r === Uh ? i : e.get(n, r, s) } } }(t, r.injector) : t, i = s.get(Qu, Mt), o = s.get(th, null), a = i.createRenderer(null, this.componentDef), l = this.componentDef.selectors[0][0] || "div", c = n ? function (t, e, n) { if (Rt(t)) return t.selectRootElement(e, n === N.ShadowDom); let r = "string" == typeof e ? t.querySelector(e) : e; return r.textContent = "", r }(a, n, this.componentDef.encapsulation) : Us(i.createRenderer(null, this.componentDef), l, function (t) { const e = t.toLowerCase(); return "svg" === e ? Tt : "math" === e ? Pt : null }(l)), u = this.componentDef.onPush ? 576 : 528, h = { components: [], scheduler: Ss, clean: _o, playerHandler: null, flags: 0 }, d = Hi(0, null, null, 1, 0, null, null, null, null, null), p = Mi(null, d, h, u, null, null, i, a, o, s); let f, g; ve(p); try { const t = function (t, e, n, r, s, i) { const o = n[1]; n[20] = t; const a = Di(o, 20, 2, "#host", null), l = a.mergedAttrs = e.hostAttrs; null !== l && (Co(a, l, !0), null !== t && (Ue(s, t, l), null !== a.classes && ui(s, t, a.classes), null !== a.styles && ci(s, t, a.styles))); const c = r.createRenderer(t, e), u = Mi(n, zi(e), null, e.onPush ? 64 : 16, n[20], a, r, c, null, null); return o.firstCreatePass && (tn(Ye(a, n), o, e.type), Ji(o, a), to(a, n.length, 1)), ho(n, u), n[20] = u }(c, this.componentDef, p, i, a); if (c) if (n) Ue(a, c, ["ng-version", nh.full]); else { const { attrs: t, classes: e } = function (t) { const e = [], n = []; let r = 1, s = 2; for (; r < t.length;) { let i = t[r]; if ("string" == typeof i) 2 === s ? "" !== i && e.push(i, t[++r]) : 8 === s && n.push(i); else { if (!_i(s)) break; s = i } r++ } return { attrs: e, classes: n } }(this.componentDef.selectors[0]); t && Ue(a, c, t), e && e.length > 0 && ui(a, c, e.join(" ")) } if (g = Ft(d, dt), void 0 !== e) { const t = g.projection = []; for (let n = 0; n < this.ngContentSelectors.length; n++) { const r = e[n]; t.push(null != r ? Array.from(r) : null) } } f = function (t, e, n, r, s) { const i = n[1], o = function (t, e, n) { const r = Jt(); t.firstCreatePass && (n.providersResolver && n.providersResolver(n), eo(t, r, e, Ni(t, e, 1, null), n)); const s = cn(e, t, r.directiveStart, r); gs(s, e); const i = Nt(r, e); return i && gs(i, e), s }(i, n, e); if (r.components.push(o), t[8] = o, s && s.forEach(t => t(o, e)), e.contentQueries) { const t = Jt(); e.contentQueries(1, o, t.directiveStart) } const a = Jt(); return !i.firstCreatePass || null === e.hostBindings && null === e.hostAttrs || (Oe(a.index), Yi(n[1], a, 0, a.directiveStart, a.directiveEnd, e), Qi(e, o)), o }(t, this.componentDef, p, h, [Bo]), Fi(d, p, null) } finally { Ce() } return new zh(this.componentType, f, Zu(g, p), p, g) } } class zh extends class { }{ constructor(t, e, n, r, s) { super(), this.location = n, this._rootLView = r, this._tNode = s, this.instance = e, this.hostView = this.changeDetectorRef = new vh(r), this.componentType = t } get injector() { return new dn(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(t) { this.hostView.onDestroy(t) } } function Hh(t, e, n, r) { return D(() => { const s = t; null !== e && (s.hasOwnProperty("decorators") && void 0 !== s.decorators ? s.decorators.push(...e) : s.decorators = e), null !== n && (s.ctorParameters = n), null !== r && (s.propDecorators = s.hasOwnProperty("propDecorators") && void 0 !== s.propDecorators ? Object.assign(Object.assign({}, s.propDecorators), r) : r) }) } const Gh = new Map; class Zh extends Ah { constructor(t, e) { super(), this._parent = e, this._bootstrapComponents = [], this.injector = this, this.destroyCbs = [], this.componentFactoryResolver = new Vh(this); const n = ht(t), r = t[W] || null; r && Lc(r), this._bootstrapComponents = Ts(n.bootstrap), this._r3Injector = Ro(t, e, [{ provide: Ah, useValue: this }, { provide: Hu, useValue: this.componentFactoryResolver }], u(t)), this._r3Injector._resolveInjectorDefTypes(), this.instance = this.get(t) } get(t, e = Vo.THROW_IF_NOT_FOUND, n = A.Default) { return t === Vo || t === Ah || t === xo ? this : this._r3Injector.get(t, e, n) } destroy() { const t = this._r3Injector; !t.destroyed && t.destroy(), this.destroyCbs.forEach(t => t()), this.destroyCbs = null } onDestroy(t) { this.destroyCbs.push(t) } } class Wh extends Ih { constructor(t) { super(), this.moduleType = t, null !== ht(t) && function (t) { const e = new Set; !function t(n) { const r = ht(n, !0), s = r.id; null !== s && (function (t, e, n) { if (e && e !== n) throw new Error(`Duplicate module registered for ${t} - ${u(e)} vs ${u(e.name)}`) }(s, Gh.get(s), n), Gh.set(s, n)); const i = Ts(r.imports); for (const o of i) e.has(o) || (e.add(o), t(o)) }(t) }(t) } create(t) { return new Zh(this.moduleType, t) } } function Kh(t, e, n) { const r = oe() + t, s = Kt(); return s[r] === Si ? na(s, r, n ? e.call(n) : e()) : ra(s, r) } function Yh(t, e, n, r) { return od(Kt(), oe(), t, e, n, r) } function Qh(t, e, n, r, s) { return ad(Kt(), oe(), t, e, n, r, s) } function Jh(t, e, n, r, s, i) { return ld(Kt(), oe(), t, e, n, r, s, i) } function Xh(t, e, n, r, s, i, o) { return cd(Kt(), oe(), t, e, n, r, s, i, o) } function td(t, e, n, r, s, i, o, a) { const l = oe() + t, c = Kt(), u = aa(c, l, n, r, s, i); return sa(c, l + 4, o) || u ? na(c, l + 5, a ? e.call(a, n, r, s, i, o) : e(n, r, s, i, o)) : ra(c, l + 5) } function ed(t, e, n, r, s, i, o, a, l) { const c = oe() + t, u = Kt(), h = aa(u, c, n, r, s, i); return ia(u, c + 4, o, a) || h ? na(u, c + 6, l ? e.call(l, n, r, s, i, o, a) : e(n, r, s, i, o, a)) : ra(u, c + 6) } function nd(t, e, n, r, s, i, o, a, l, c) { const u = oe() + t, h = Kt(); let d = aa(h, u, n, r, s, i); return oa(h, u + 4, o, a, l) || d ? na(h, u + 7, c ? e.call(c, n, r, s, i, o, a, l) : e(n, r, s, i, o, a, l)) : ra(h, u + 7) } function rd(t, e, n, r, s, i, o, a, l, c, u) { const h = oe() + t, d = Kt(), p = aa(d, h, n, r, s, i); return aa(d, h + 4, o, a, l, c) || p ? na(d, h + 8, u ? e.call(u, n, r, s, i, o, a, l, c) : e(n, r, s, i, o, a, l, c)) : ra(d, h + 8) } function sd(t, e, n, r) { return ud(Kt(), oe(), t, e, n, r) } function id(t, e) { const n = t[e]; return n === Si ? void 0 : n } function od(t, e, n, r, s, i) { const o = e + n; return sa(t, o, s) ? na(t, o + 1, i ? r.call(i, s) : r(s)) : id(t, o + 1) } function ad(t, e, n, r, s, i, o) { const a = e + n; return ia(t, a, s, i) ? na(t, a + 2, o ? r.call(o, s, i) : r(s, i)) : id(t, a + 2) } function ld(t, e, n, r, s, i, o, a) { const l = e + n; return oa(t, l, s, i, o) ? na(t, l + 3, a ? r.call(a, s, i, o) : r(s, i, o)) : id(t, l + 3) } function cd(t, e, n, r, s, i, o, a, l) { const c = e + n; return aa(t, c, s, i, o, a) ? na(t, c + 4, l ? r.call(l, s, i, o, a) : r(s, i, o, a)) : id(t, c + 4) } function ud(t, e, n, r, s, i) { let o = e + n, a = !1; for (let l = 0; l < s.length; l++)sa(t, o++, s[l]) && (a = !0); return a ? na(t, o, r.apply(i, s)) : id(t, o) } function hd(t, e) { const n = Yt(); let r; const s = t + dt; n.firstCreatePass ? (r = function (t, e) { if (e) for (let n = e.length - 1; n >= 0; n--) { const r = e[n]; if (t === r.name) return r } throw new m("302", `The pipe '${t}' could not be found!`) }(e, n.pipeRegistry), n.data[s] = r, r.onDestroy && (n.destroyHooks || (n.destroyHooks = [])).push(s, r.onDestroy)) : r = n.data[s]; const i = r.factory || (r.factory = bt(r.type)), o = R(ka); try { const t = We(!1), e = i(); return We(t), function (t, e, n, r) { n >= t.data.length && (t.data[n] = null, t.blueprint[n] = null), e[n] = r }(n, Kt(), s, e), e } finally { R(o) } } function dd(t, e, n) { const r = t + dt, s = Kt(), i = jt(s, r); return yd(s, _d(s, r) ? od(s, oe(), e, i.transform, n, i) : i.transform(n)) } function pd(t, e, n, r) { const s = t + dt, i = Kt(), o = jt(i, s); return yd(i, _d(i, s) ? ad(i, oe(), e, o.transform, n, r, o) : o.transform(n, r)) } function fd(t, e, n, r, s) { const i = t + dt, o = Kt(), a = jt(o, i); return yd(o, _d(o, i) ? ld(o, oe(), e, a.transform, n, r, s, a) : a.transform(n, r, s)) } function gd(t, e, n, r, s, i) { const o = t + dt, a = Kt(), l = jt(a, o); return yd(a, _d(a, o) ? cd(a, oe(), e, l.transform, n, r, s, i, l) : l.transform(n, r, s, i)) } function md(t, e, n) { const r = t + dt, s = Kt(), i = jt(s, r); return yd(s, _d(s, r) ? ud(s, oe(), e, i.transform, n, i) : i.transform.apply(i, n)) } function _d(t, e) { return t[1].data[e].pure } function yd(t, e) { return Xo.isWrapped(e) && (e = Xo.unwrap(e), t[ae()] = Si), e } function vd(t) { return e => { setTimeout(t, void 0, e) } } const bd = class extends r.xQ { constructor(t = !1) { super(), this.__isAsync = t } emit(t) { super.next(t) } subscribe(t, e, n) { var r, i, o; let a = t, l = e || (() => null), c = n; if (t && "object" == typeof t) { const e = t; a = null === (r = e.next) || void 0 === r ? void 0 : r.bind(e), l = null === (i = e.error) || void 0 === i ? void 0 : i.bind(e), c = null === (o = e.complete) || void 0 === o ? void 0 : o.bind(e) } this.__isAsync && (l = vd(l), a && (a = vd(a)), c && (c = vd(c))); const u = super.subscribe({ next: a, error: l, complete: c }); return t instanceof s.w && t.add(u), u } }; function wd() { return this._results[Jo()]() } class Ed { constructor(t = !1) { this._emitDistinctChangesOnly = t, this.dirty = !0, this._results = [], this._changesDetected = !1, this._changes = null, this.length = 0, this.first = void 0, this.last = void 0; const e = Jo(), n = Ed.prototype; n[e] || (n[e] = wd) } get changes() { return this._changes || (this._changes = new bd) } get(t) { return this._results[t] } map(t) { return this._results.map(t) } filter(t) { return this._results.filter(t) } find(t) { return this._results.find(t) } reduce(t, e) { return this._results.reduce(t, e) } forEach(t) { this._results.forEach(t) } some(t) { return this._results.some(t) } toArray() { return this._results.slice() } toString() { return this._results.toString() } reset(t, e) { const n = this; n.dirty = !1; const r = kn(t); (this._changesDetected = !function (t, e, n) { if (t.length !== e.length) return !1; for (let r = 0; r < t.length; r++) { let s = t[r], i = e[r]; if (n && (s = n(s), i = n(i)), i !== s) return !1 } return !0 }(n._results, r, e)) && (n._results = r, n.length = r.length, n.last = r[this.length - 1], n.first = r[0]) } notifyOnChanges() { !this._changes || !this._changesDetected && this._emitDistinctChangesOnly || this._changes.emit(this) } setDirty() { this.dirty = !0 } destroy() { this.changes.complete(), this.changes.unsubscribe() } } class Sd { constructor(t) { this.queryList = t, this.matches = null } clone() { return new Sd(this.queryList) } setDirty() { this.queryList.setDirty() } } class Cd { constructor(t = []) { this.queries = t } createEmbeddedView(t) { const e = t.queries; if (null !== e) { const n = null !== t.contentQueries ? t.contentQueries[0] : e.length, r = []; for (let t = 0; t < n; t++) { const n = e.getByIndex(t); r.push(this.queries[n.indexInDeclarationView].clone()) } return new Cd(r) } return null } insertView(t) { this.dirtyQueriesWithMatches(t) } detachView(t) { this.dirtyQueriesWithMatches(t) } dirtyQueriesWithMatches(t) { for (let e = 0; e < this.queries.length; e++)null !== jd(t, e).matches && this.queries[e].setDirty() } } class xd { constructor(t, e, n = null) { this.predicate = t, this.flags = e, this.read = n } } class Od { constructor(t = []) { this.queries = t } elementStart(t, e) { for (let n = 0; n < this.queries.length; n++)this.queries[n].elementStart(t, e) } elementEnd(t) { for (let e = 0; e < this.queries.length; e++)this.queries[e].elementEnd(t) } embeddedTView(t) { let e = null; for (let n = 0; n < this.length; n++) { const r = null !== e ? e.length : 0, s = this.getByIndex(n).embeddedTView(t, r); s && (s.indexInDeclarationView = n, null !== e ? e.push(s) : e = [s]) } return null !== e ? new Od(e) : null } template(t, e) { for (let n = 0; n < this.queries.length; n++)this.queries[n].template(t, e) } getByIndex(t) { return this.queries[t] } get length() { return this.queries.length } track(t) { this.queries.push(t) } } class Td { constructor(t, e = -1) { this.metadata = t, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = e } elementStart(t, e) { this.isApplyingToNode(e) && this.matchTNode(t, e) } elementEnd(t) { this._declarationNodeIndex === t.index && (this._appliesToNextNode = !1) } template(t, e) { this.elementStart(t, e) } embeddedTView(t, e) { return this.isApplyingToNode(t) ? (this.crossesNgTemplate = !0, this.addMatch(-t.index, e), new Td(this.metadata)) : null } isApplyingToNode(t) { if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) { const e = this._declarationNodeIndex; let n = t.parent; for (; null !== n && 8 & n.type && n.index !== e;)n = n.parent; return e === (null !== n ? n.index : -1) } return this._appliesToNextNode } matchTNode(t, e) { const n = this.metadata.predicate; if (Array.isArray(n)) for (let r = 0; r < n.length; r++) { const s = n[r]; this.matchTNodeWithReadOption(t, e, Pd(e, s)), this.matchTNodeWithReadOption(t, e, ln(e, t, s, !1, !1)) } else n === Oh ? 4 & e.type && this.matchTNodeWithReadOption(t, e, -1) : this.matchTNodeWithReadOption(t, e, ln(e, t, n, !1, !1)) } matchTNodeWithReadOption(t, e, n) { if (null !== n) { const r = this.metadata.read; if (null !== r) if (r === Ku || r === Mh || r === Oh && 4 & e.type) this.addMatch(e.index, -2); else { const n = ln(e, t, r, !1, !1); null !== n && this.addMatch(e.index, n) } else this.addMatch(e.index, n) } } addMatch(t, e) { null === this.matches ? this.matches = [t, e] : this.matches.push(t, e) } } function Pd(t, e) { const n = t.localNames; if (null !== n) for (let r = 0; r < n.length; r += 2)if (n[r] === e) return n[r + 1]; return null } function kd(t, e, n, r) { return -1 === n ? function (t, e) { return 11 & t.type ? Zu(t, e) : 4 & t.type ? kh(t, e) : null }(e, t) : -2 === n ? function (t, e, n) { return n === Ku ? Zu(e, t) : n === Oh ? kh(e, t) : n === Mh ? jh(e, t) : void 0 }(t, e, r) : cn(t, t[1], n, e) } function Ad(t, e, n, r) { const s = e[19].queries[r]; if (null === s.matches) { const r = t.data, i = n.matches, o = []; for (let t = 0; t < i.length; t += 2) { const s = i[t]; o.push(s < 0 ? null : kd(e, r[s], i[t + 1], n.metadata.read)) } s.matches = o } return s.matches } function Id(t, e, n, r) { const s = t.queries.getByIndex(n), i = s.matches; if (null !== i) { const o = Ad(t, e, s, n); for (let t = 0; t < i.length; t += 2) { const n = i[t]; if (n > 0) r.push(o[t / 2]); else { const s = i[t + 1], o = e[-n]; for (let t = pt; t < o.length; t++) { const e = o[t]; e[17] === e[3] && Id(e[1], e, s, r) } if (null !== o[9]) { const t = o[9]; for (let e = 0; e < t.length; e++) { const n = t[e]; Id(n[1], n, s, r) } } } } } return r } function Rd(t) { const e = Kt(), n = Yt(), r = ge(); me(r + 1); const s = jd(n, r); if (t.dirty && Vt(e) === (2 == (2 & s.metadata.flags))) { if (null === s.matches) t.reset([]); else { const i = s.crossesNgTemplate ? Id(n, e, r, []) : Ad(n, e, s, r); t.reset(i, Yu), t.notifyOnChanges() } return !0 } return !1 } function Md(t, e, n) { const r = Yt(); r.firstCreatePass && (Fd(r, new xd(t, e, n), -1), 2 == (2 & e) && (r.staticViewQueries = !0)), Nd(r, Kt(), e) } function Dd(t, e, n, r) { const s = Yt(); if (s.firstCreatePass) { const i = Jt(); Fd(s, new xd(e, n, r), i.index), function (t, e) { const n = t.contentQueries || (t.contentQueries = []); e !== (n.length ? n[n.length - 1] : -1) && n.push(t.queries.length - 1, e) }(s, t), 2 == (2 & n) && (s.staticContentQueries = !0) } Nd(s, Kt(), n) } function Ld() { return t = Kt(), e = ge(), t[19].queries[e].queryList; var t, e } function Nd(t, e, n) { const r = new Ed(4 == (4 & n)); Gi(t, e, r, r.destroy), null === e[19] && (e[19] = new Cd), e[19].queries.push(new Sd(r)) } function Fd(t, e, n) { null === t.queries && (t.queries = new Od), t.queries.track(new Td(e, n)) } function jd(t, e) { return t.queries.getByIndex(e) } function Ud(t, e) { return kh(t, e) } const Vd = (() => ({ "\u0275\u0275attribute": la, "\u0275\u0275attributeInterpolate1": ya, "\u0275\u0275attributeInterpolate2": va, "\u0275\u0275attributeInterpolate3": ba, "\u0275\u0275attributeInterpolate4": wa, "\u0275\u0275attributeInterpolate5": Ea, "\u0275\u0275attributeInterpolate6": Sa, "\u0275\u0275attributeInterpolate7": Ca, "\u0275\u0275attributeInterpolate8": xa, "\u0275\u0275attributeInterpolateV": Oa, "\u0275\u0275defineComponent": J, "\u0275\u0275defineDirective": ot, "\u0275\u0275defineInjectable": w, "\u0275\u0275defineInjector": E, "\u0275\u0275defineNgModule": rt, "\u0275\u0275definePipe": at, "\u0275\u0275directiveInject": ka, "\u0275\u0275getInheritedFactory": pn, "\u0275\u0275inject": Qn, "\u0275\u0275injectAttribute": gn, "\u0275\u0275invalidFactory": Aa, "\u0275\u0275invalidFactoryDep": Jn, "\u0275\u0275templateRefExtractor": Ud, "\u0275\u0275NgOnChangesFeature": Et, "\u0275\u0275ProvidersFeature": qu, "\u0275\u0275CopyDefinitionFeature": Yo, "\u0275\u0275InheritDefinitionFeature": $o, "\u0275\u0275nextContext": Wa, "\u0275\u0275namespaceHTML": Ae, "\u0275\u0275namespaceMathML": ke, "\u0275\u0275namespaceSVG": Pe, "\u0275\u0275enableBindings": Zt, "\u0275\u0275disableBindings": Wt, "\u0275\u0275elementStart": Ma, "\u0275\u0275elementEnd": Da, "\u0275\u0275element": La, "\u0275\u0275elementContainerStart": Na, "\u0275\u0275elementContainerEnd": Fa, "\u0275\u0275elementContainer": ja, "\u0275\u0275pureFunction0": Kh, "\u0275\u0275pureFunction1": Yh, "\u0275\u0275pureFunction2": Qh, "\u0275\u0275pureFunction3": Jh, "\u0275\u0275pureFunction4": Xh, "\u0275\u0275pureFunction5": td, "\u0275\u0275pureFunction6": ed, "\u0275\u0275pureFunction7": nd, "\u0275\u0275pureFunction8": rd, "\u0275\u0275pureFunctionV": sd, "\u0275\u0275getCurrentView": Ua, "\u0275\u0275restoreView": Qt, "\u0275\u0275listener": $a, "\u0275\u0275projection": Qa, "\u0275\u0275syntheticHostProperty": wc, "\u0275\u0275syntheticHostListener": za, "\u0275\u0275pipeBind1": dd, "\u0275\u0275pipeBind2": pd, "\u0275\u0275pipeBind3": fd, "\u0275\u0275pipeBind4": gd, "\u0275\u0275pipeBindV": md, "\u0275\u0275projectionDef": Ya, "\u0275\u0275hostProperty": bc, "\u0275\u0275property": Ia, "\u0275\u0275propertyInterpolate": Ja, "\u0275\u0275propertyInterpolate1": Xa, "\u0275\u0275propertyInterpolate2": tl, "\u0275\u0275propertyInterpolate3": el, "\u0275\u0275propertyInterpolate4": nl, "\u0275\u0275propertyInterpolate5": rl, "\u0275\u0275propertyInterpolate6": sl, "\u0275\u0275propertyInterpolate7": il, "\u0275\u0275propertyInterpolate8": ol, "\u0275\u0275propertyInterpolateV": al, "\u0275\u0275pipe": hd, "\u0275\u0275queryRefresh": Rd, "\u0275\u0275viewQuery": Md, "\u0275\u0275loadQuery": Ld, "\u0275\u0275contentQuery": Dd, "\u0275\u0275reference": Pa, "\u0275\u0275classMap": Sl, "\u0275\u0275classMapInterpolate1": Zl, "\u0275\u0275classMapInterpolate2": Wl, "\u0275\u0275classMapInterpolate3": Kl, "\u0275\u0275classMapInterpolate4": Yl, "\u0275\u0275classMapInterpolate5": Ql, "\u0275\u0275classMapInterpolate6": Jl, "\u0275\u0275classMapInterpolate7": Xl, "\u0275\u0275classMapInterpolate8": tc, "\u0275\u0275classMapInterpolateV": ec, "\u0275\u0275styleMap": wl, "\u0275\u0275styleMapInterpolate1": nc, "\u0275\u0275styleMapInterpolate2": rc, "\u0275\u0275styleMapInterpolate3": sc, "\u0275\u0275styleMapInterpolate4": ic, "\u0275\u0275styleMapInterpolate5": oc, "\u0275\u0275styleMapInterpolate6": ac, "\u0275\u0275styleMapInterpolate7": lc, "\u0275\u0275styleMapInterpolate8": cc, "\u0275\u0275styleMapInterpolateV": uc, "\u0275\u0275styleProp": vl, "\u0275\u0275stylePropInterpolate1": hc, "\u0275\u0275stylePropInterpolate2": dc, "\u0275\u0275stylePropInterpolate3": pc, "\u0275\u0275stylePropInterpolate4": fc, "\u0275\u0275stylePropInterpolate5": gc, "\u0275\u0275stylePropInterpolate6": mc, "\u0275\u0275stylePropInterpolate7": _c, "\u0275\u0275stylePropInterpolate8": yc, "\u0275\u0275stylePropInterpolateV": vc, "\u0275\u0275classProp": bl, "\u0275\u0275advance": Ci, "\u0275\u0275template": Ta, "\u0275\u0275text": Nl, "\u0275\u0275textInterpolate": Fl, "\u0275\u0275textInterpolate1": jl, "\u0275\u0275textInterpolate2": Ul, "\u0275\u0275textInterpolate3": Vl, "\u0275\u0275textInterpolate4": Bl, "\u0275\u0275textInterpolate5": ql, "\u0275\u0275textInterpolate6": $l, "\u0275\u0275textInterpolate7": zl, "\u0275\u0275textInterpolate8": Hl, "\u0275\u0275textInterpolateV": Gl, "\u0275\u0275i18n": Au, "\u0275\u0275i18nAttributes": Iu, "\u0275\u0275i18nExp": Ru, "\u0275\u0275i18nStart": Pu, "\u0275\u0275i18nEnd": ku, "\u0275\u0275i18nApply": Mu, "\u0275\u0275i18nPostprocess": Du, "\u0275\u0275resolveWindow": Cs, "\u0275\u0275resolveDocument": xs, "\u0275\u0275resolveBody": Os, "\u0275\u0275setComponentScope": X, "\u0275\u0275setNgModuleScope": st, "\u0275\u0275sanitizeHtml": os, "\u0275\u0275sanitizeStyle": as, "\u0275\u0275sanitizeResourceUrl": cs, "\u0275\u0275sanitizeScript": us, "\u0275\u0275sanitizeUrl": ls, "\u0275\u0275sanitizeUrlOrResourceUrl": ps, "\u0275\u0275trustConstantHtml": hs, "\u0275\u0275trustConstantResourceUrl": ds, forwardRef: p, resolveForwardRef: f }))(); const Bd = []; let qd = !1; function $d(t) { return Array.isArray(t) ? t.every($d) : !!f(t) } function zd(t, e) { const n = kn(e.declarations || $), r = Gd(t); n.forEach(e => { e.hasOwnProperty(z) ? Hd(lt(e), r) : e.hasOwnProperty(H) || e.hasOwnProperty(G) || (e.ngSelectorScope = t) }) } function Hd(t, e) { t.directiveDefs = () => Array.from(e.compilation.directives).map(t => t.hasOwnProperty(z) ? lt(t) : ct(t)).filter(t => !!t), t.pipeDefs = () => Array.from(e.compilation.pipes).map(t => ut(t)), t.schemas = e.schemas, t.tView = null } function Gd(t) { if (!Wd(t)) throw new Error(`${t.name} does not have a module def (\u0275mod property)`); const e = ht(t); if (null !== e.transitiveCompileScopes) return e.transitiveCompileScopes; const n = { schemas: e.schemas || null, compilation: { directives: new Set, pipes: new Set }, exported: { directives: new Set, pipes: new Set } }; return Ts(e.imports).forEach(t => { const e = t; if (!Wd(e)) throw new Error(`Importing ${e.name} which does not have a \u0275mod property`); const r = Gd(e); r.exported.directives.forEach(t => n.compilation.directives.add(t)), r.exported.pipes.forEach(t => n.compilation.pipes.add(t)) }), Ts(e.declarations).forEach(t => { ut(t) ? n.compilation.pipes.add(t) : n.compilation.directives.add(t) }), Ts(e.exports).forEach(t => { const e = t; if (Wd(e)) { const t = Gd(e); t.exported.directives.forEach(t => { n.compilation.directives.add(t), n.exported.directives.add(t) }), t.exported.pipes.forEach(t => { n.compilation.pipes.add(t), n.exported.pipes.add(t) }) } else ut(e) ? n.exported.pipes.add(e) : n.exported.directives.add(e) }), e.transitiveCompileScopes = n, n } function Zd(t) { return function (t) { return void 0 !== t.ngModule }(t) ? t.ngModule : t } function Wd(t) { return !!ht(t) } let Kd = 0; function Yd(t, e) { let n = null; Jd(t, e || {}), Object.defineProperty(t, H, { get: () => { if (null === n) { const r = Qd(t, e || {}); n = On().compileDirective(Vd, r.sourceMapUrl, r.metadata) } return n }, configurable: !1 }) } function Qd(t, e) { const n = t && t.name, r = `ng:///${n}/\u0275dir.js`, s = On(), i = tp(t, e); return i.typeSourceSpan = s.createParseSourceSpan("Directive", n, r), i.usesInheritance && ep(t), { metadata: i, sourceMapUrl: r } } function Jd(t, e) { let n = null; Object.defineProperty(t, K, { get: () => { if (null === n) { const r = Qd(t, e), s = On(); n = s.compileFactory(Vd, `ng:///${t.name}/\u0275fac.js`, { name: r.metadata.name, type: r.metadata.type, typeArgumentCount: 0, deps: lr(t), target: s.FactoryTarget.Directive }) } return n }, configurable: !1 }) } function Xd(t) { return Object.getPrototypeOf(t.prototype) === Object.prototype } function tp(t, e) { const n = ar(), r = n.ownPropMetadata(t); return { name: t.name, type: t, selector: void 0 !== e.selector ? e.selector : null, host: e.host || q, propMetadata: r, inputs: e.inputs || $, outputs: e.outputs || $, queries: rp(t, r, sp), lifecycle: { usesOnChanges: n.hasLifecycleHook(t, "ngOnChanges") }, typeSourceSpan: null, usesInheritance: !Xd(t), exportAs: (s = e.exportAs, void 0 === s ? null : ap(s)), providers: e.providers || null, viewQueries: rp(t, r, ip) }; var s } function ep(t) { const e = Object.prototype; let n = Object.getPrototypeOf(t.prototype).constructor; for (; n && n !== e;)ct(n) || lt(n) || !cp(n) || Yd(n, null), n = Object.getPrototypeOf(n) } function np(t, e) { return { propertyName: t, predicate: (n = e.selector, "string" == typeof n ? ap(n) : f(n)), descendants: e.descendants, first: e.first, read: e.read ? e.read : null, static: !!e.static, emitDistinctChangesOnly: !!e.emitDistinctChangesOnly }; var n } function rp(t, e, n) { const r = []; for (const s in e) if (e.hasOwnProperty(s)) { const i = e[s]; i.forEach(e => { if (n(e)) { if (!e.selector) throw new Error(`Can't construct a query for the property "${s}" of "${y(t)}" since the query selector wasn't defined.`); if (i.some(op)) throw new Error("Cannot combine @Input decorators with query decorators"); r.push(np(s, e)) } }) } return r } function sp(t) { const e = t.ngMetadataName; return "ContentChild" === e || "ContentChildren" === e } function ip(t) { const e = t.ngMetadataName; return "ViewChild" === e || "ViewChildren" === e } function op(t) { return "Input" === t.ngMetadataName } function ap(t) { return t.split(",").map(t => t.trim()) } const lp = ["ngOnChanges", "ngOnInit", "ngOnDestroy", "ngDoCheck", "ngAfterViewInit", "ngAfterViewChecked", "ngAfterContentInit", "ngAfterContentChecked"]; function cp(t) { const e = ar(); if (lp.some(n => e.hasLifecycleHook(t, n))) return !0; const n = e.propMetadata(t); for (const r in n) { const t = n[r]; for (let e = 0; e < t.length; e++) { const n = t[e], r = n.ngMetadataName; if (op(n) || sp(n) || ip(n) || "Output" === r || "HostBinding" === r || "HostListener" === r) return !0 } } return !1 } function up(t, e) { return { type: t, name: t.name, pipeName: e.name, pure: void 0 === e.pure || e.pure } } const hp = vn("Directive", (t = {}) => t, void 0, void 0, (t, e) => _p(t, e)), dp = vn("Component", (t = {}) => Object.assign({ changeDetection: L.Default }, t), hp, void 0, (t, e) => mp(t, e)), pp = vn("Pipe", t => Object.assign({ pure: !0 }, t), void 0, void 0, (t, e) => yp(t, e)), fp = En("Input", t => ({ bindingPropertyName: t })), gp = En("Output", t => ({ bindingPropertyName: t })), mp = function (t, e) { let n = null; !function (t, e) { hr(e) && (cr.set(t, e), ur.add(t)) }(t, e), Jd(t, e), Object.defineProperty(t, z, { get: () => { if (null === n) { const r = On(); if (hr(e)) { const n = [`Component '${t.name}' is not resolved:`]; throw e.templateUrl && n.push(` - templateUrl: ${e.templateUrl}`), e.styleUrls && e.styleUrls.length && n.push(` - styleUrls: ${JSON.stringify(e.styleUrls)}`), n.push("Did you run and wait for 'resolveComponentResources()'?"), new Error(n.join("\n")) } const s = null; let i = e.preserveWhitespaces; void 0 === i && (i = null !== s && void 0 !== s.preserveWhitespaces && s.preserveWhitespaces); let o = e.encapsulation; void 0 === o && (o = null !== s && void 0 !== s.defaultEncapsulation ? s.defaultEncapsulation : N.Emulated); const a = e.templateUrl || `ng:///${t.name}/template.html`, l = Object.assign(Object.assign({}, tp(t, e)), { typeSourceSpan: r.createParseSourceSpan("Component", t.name, a), template: e.template || "", preserveWhitespaces: i, styles: e.styles || $, animations: e.animations, directives: [], changeDetection: e.changeDetection, pipes: new Map, encapsulation: o, interpolation: e.interpolation, viewProviders: e.viewProviders || null }); Kd++; try { l.usesInheritance && ep(t), n = r.compileComponent(Vd, a, l) } finally { Kd-- } if (0 === Kd && function () { if (!qd) { qd = !0; try { for (let t = Bd.length - 1; t >= 0; t--) { const { moduleType: e, ngModule: n } = Bd[t]; n.declarations && n.declarations.every($d) && (Bd.splice(t, 1), zd(e, n)) } } finally { qd = !1 } } }(), void 0 !== t.ngSelectorScope) { const e = Gd(t.ngSelectorScope); Hd(n, e) } } return n }, configurable: !1 }) }, _p = Yd, yp = function (t, e) { let n = null, r = null; Object.defineProperty(t, K, { get: () => { if (null === r) { const n = up(t, e), s = On(); r = s.compileFactory(Vd, `ng:///${n.name}/\u0275fac.js`, { name: n.name, type: n.type, typeArgumentCount: 0, deps: lr(t), target: s.FactoryTarget.Pipe }) } return r }, configurable: !1 }), Object.defineProperty(t, G, { get: () => { if (null === n) { const r = up(t, e); n = On().compilePipe(Vd, `ng:///${r.name}/\u0275pipe.js`, r) } return n }, configurable: !1 }) }, vp = vn("NgModule", t => t, void 0, void 0, (t, e) => bp(t, e)), bp = function (t, e = {}) { !function (t, e, n = !1) { const r = kn(e.declarations || $); let s = null; Object.defineProperty(t, Z, { configurable: !0, get: () => (null === s && (s = On().compileNgModule(Vd, `ng:///${t.name}/\u0275mod.js`, { type: t, bootstrap: kn(e.bootstrap || $).map(f), declarations: r.map(f), imports: kn(e.imports || $).map(f).map(Zd), exports: kn(e.exports || $).map(f).map(Zd), schemas: e.schemas ? kn(e.schemas) : null, id: e.id || null }), s.schemas || (s.schemas = [])), s) }); let i = null; Object.defineProperty(t, K, { get: () => { if (null === i) { const e = On(); i = e.compileFactory(Vd, `ng:///${t.name}/\u0275fac.js`, { name: t.name, type: t, deps: lr(t), target: e.FactoryTarget.NgModule, typeArgumentCount: 0 }) } return i }, configurable: !1 }); let o = null; Object.defineProperty(t, T, { get: () => { if (null === o) { const n = { name: t.name, type: t, providers: e.providers || $, imports: [(e.imports || $).map(f), (e.exports || $).map(f)] }; o = On().compileInjector(Vd, `ng:///${t.name}/\u0275inj.js`, n) } return o }, configurable: !1 }) }(t, e), function (t, e) { Bd.push({ moduleType: t, ngModule: e }) }(t, e) }, wp = new Cn("Application Initializer"); let Ep = (() => { class t { constructor(t) { this.appInits = t, this.resolve = Gu, this.reject = Gu, this.initialized = !1, this.done = !1, this.donePromise = new Promise((t, e) => { this.resolve = t, this.reject = e }) } runInitializers() { if (this.initialized) return; const t = [], e = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let n = 0; n < this.appInits.length; n++) { const e = this.appInits[n](); if (Va(e)) t.push(e); else if (qa(e)) { const n = new Promise((t, n) => { e.subscribe({ complete: t, error: n }) }); t.push(n) } } Promise.all(t).then(() => { e() }).catch(t => { this.reject(t) }), 0 === t.length && e(), this.initialized = !0 } } return t.\u0275fac = function (e) { return new (e || t)(Qn(wp, 8)) }, t.\u0275prov = w({ token: t, factory: t.\u0275fac }), t })(); const Sp = new Cn("AppId"), Cp = { provide: Sp, useFactory: function () { return `${xp()}${xp()}${xp()}` }, deps: [] }; function xp() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const Op = new Cn("Platform Initializer"), Tp = new Cn("Platform ID"), Pp = new Cn("appBootstrapListener"); let kp = (() => { class t { log(t) { console.log(t) } warn(t) { console.warn(t) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = w({ token: t, factory: t.\u0275fac }), t })(); const Ap = new Cn("LocaleId"), Ip = new Cn("DefaultCurrencyCode"); class Rp { constructor(t, e) { this.ngModuleFactory = t, this.componentFactories = e } } const Mp = function (t) { return new Wh(t) }, Dp = Mp, Lp = function (t) { return Promise.resolve(Mp(t)) }, Np = function (t) { const e = Mp(t), n = Ts(ht(t).declarations).reduce((t, e) => { const n = lt(e); return n && t.push(new $h(n)), t }, []); return new Rp(e, n) }, Fp = Np, jp = function (t) { return Promise.resolve(Np(t)) }; let Up = (() => { class t { constructor() { this.compileModuleSync = Dp, this.compileModuleAsync = Lp, this.compileModuleAndAllComponentsSync = Fp, this.compileModuleAndAllComponentsAsync = jp } clearCache() { } clearCacheFor(t) { } getModuleId(t) { } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = w({ token: t, factory: t.\u0275fac }), t })(); const Vp = (() => Promise.resolve(0))(); function Bp(t) { "undefined" == typeof Zone ? Vp.then(() => { t && t.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", t) } class qp { constructor({ enableLongStackTrace: t = !1, shouldCoalesceEventChangeDetection: e = !1, shouldCoalesceRunChangeDetection: n = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new bd(!1), this.onMicrotaskEmpty = new bd(!1), this.onStable = new bd(!1), this.onError = new bd(!1), "undefined" == typeof Zone) throw new Error("In this configuration Angular requires Zone.js"); Zone.assertZonePatched(); const r = this; r._nesting = 0, r._outer = r._inner = Zone.current, Zone.TaskTrackingZoneSpec && (r._inner = r._inner.fork(new Zone.TaskTrackingZoneSpec)), t && Zone.longStackTraceZoneSpec && (r._inner = r._inner.fork(Zone.longStackTraceZoneSpec)), r.shouldCoalesceEventChangeDetection = !n && e, r.shouldCoalesceRunChangeDetection = n, r.lastRequestAnimationFrameId = -1, r.nativeRequestAnimationFrame = function () { let t = B.requestAnimationFrame, e = B.cancelAnimationFrame; if ("undefined" != typeof Zone && t && e) { const n = t[Zone.__symbol__("OriginalDelegate")]; n && (t = n); const r = e[Zone.__symbol__("OriginalDelegate")]; r && (e = r) } return { nativeRequestAnimationFrame: t, nativeCancelAnimationFrame: e } }().nativeRequestAnimationFrame, function (t) { const e = () => { !function (t) { t.isCheckStableRunning || -1 !== t.lastRequestAnimationFrameId || (t.lastRequestAnimationFrameId = t.nativeRequestAnimationFrame.call(B, () => { t.fakeTopEventTask || (t.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { t.lastRequestAnimationFrameId = -1, Hp(t), t.isCheckStableRunning = !0, zp(t), t.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), t.fakeTopEventTask.invoke() }), Hp(t)) }(t) }; t._inner = t._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (n, r, s, i, o, a) => { try { return Gp(t), n.invokeTask(s, i, o, a) } finally { (t.shouldCoalesceEventChangeDetection && "eventTask" === i.type || t.shouldCoalesceRunChangeDetection) && e(), Zp(t) } }, onInvoke: (n, r, s, i, o, a, l) => { try { return Gp(t), n.invoke(s, i, o, a, l) } finally { t.shouldCoalesceRunChangeDetection && e(), Zp(t) } }, onHasTask: (e, n, r, s) => { e.hasTask(r, s), n === r && ("microTask" == s.change ? (t._hasPendingMicrotasks = s.microTask, Hp(t), zp(t)) : "macroTask" == s.change && (t.hasPendingMacrotasks = s.macroTask)) }, onHandleError: (e, n, r, s) => (e.handleError(r, s), t.runOutsideAngular(() => t.onError.emit(s)), !1) }) }(r) } static isInAngularZone() { return !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!qp.isInAngularZone()) throw new Error("Expected to be in Angular Zone, but it is not!") } static assertNotInAngularZone() { if (qp.isInAngularZone()) throw new Error("Expected to not be in Angular Zone, but it is!") } run(t, e, n) { return this._inner.run(t, e, n) } runTask(t, e, n, r) { const s = this._inner, i = s.scheduleEventTask("NgZoneEvent: " + r, t, $p, Gu, Gu); try { return s.runTask(i, e, n) } finally { s.cancelTask(i) } } runGuarded(t, e, n) { return this._inner.runGuarded(t, e, n) } runOutsideAngular(t) { return this._outer.run(t) } } const $p = {}; function zp(t) { if (0 == t._nesting && !t.hasPendingMicrotasks && !t.isStable) try { t._nesting++, t.onMicrotaskEmpty.emit(null) } finally { if (t._nesting--, !t.hasPendingMicrotasks) try { t.runOutsideAngular(() => t.onStable.emit(null)) } finally { t.isStable = !0 } } } function Hp(t) { t.hasPendingMicrotasks = !!(t._hasPendingMicrotasks || (t.shouldCoalesceEventChangeDetection || t.shouldCoalesceRunChangeDetection) && -1 !== t.lastRequestAnimationFrameId) } function Gp(t) { t._nesting++, t.isStable && (t.isStable = !1, t.onUnstable.emit(null)) } function Zp(t) { t._nesting--, zp(t) } class Wp { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new bd, this.onMicrotaskEmpty = new bd, this.onStable = new bd, this.onError = new bd } run(t, e, n) { return t.apply(e, n) } runGuarded(t, e, n) { return t.apply(e, n) } runOutsideAngular(t) { return t() } runTask(t, e, n, r) { return t.apply(e, n) } } let Kp = (() => { class t { constructor(t) { this._ngZone = t, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, this._watchAngularEvents(), t.run(() => { this.taskTrackingZone = "undefined" == typeof Zone ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { qp.assertNotInAngularZone(), Bp(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) Bp(() => { for (; 0 !== this._callbacks.length;) { let t = this._callbacks.pop(); clearTimeout(t.timeoutId), t.doneCb(this._didWork) } this._didWork = !1 }); else { let t = this.getPendingTasks(); this._callbacks = this._callbacks.filter(e => !e.updateCb || !e.updateCb(t) || (clearTimeout(e.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(t => ({ source: t.source, creationLocation: t.creationLocation, data: t.data })) : [] } addCallback(t, e, n) { let r = -1; e && e > 0 && (r = setTimeout(() => { this._callbacks = this._callbacks.filter(t => t.timeoutId !== r), t(this._didWork, this.getPendingTasks()) }, e)), this._callbacks.push({ doneCb: t, timeoutId: r, updateCb: n }) } whenStable(t, e, n) { if (n && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'); this.addCallback(t, e, n), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } findProviders(t, e, n) { return [] } } return t.\u0275fac = function (e) { return new (e || t)(Qn(qp)) }, t.\u0275prov = w({ token: t, factory: t.\u0275fac }), t })(), Yp = (() => { class t { constructor() { this._applications = new Map, tf.addToWindow(this) } registerApplication(t, e) { this._applications.set(t, e) } unregisterApplication(t) { this._applications.delete(t) } unregisterAllApplications() { this._applications.clear() } getTestability(t) { return this._applications.get(t) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(t, e = !0) { return tf.findTestabilityInTree(this, t, e) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = w({ token: t, factory: t.\u0275fac }), t })(); class Qp { addToWindow(t) { } findTestabilityInTree(t, e, n) { return null } } function Jp(t) { tf = t } let Xp, tf = new Qp, ef = !0, nf = !1; function rf() { return nf = !0, ef } function sf() { if (nf) throw new Error("Cannot enable prod mode after platform setup."); ef = !1 } const of = new Cn("AllowMultipleToken"); class af { constructor(t, e) { this.name = t, this.token = e } } function lf(t, e, n = []) { const r = `Platform: ${e}`, s = new Cn(r); return (e = []) => { let i = cf(); if (!i || i.injector.get(of, !1)) if (t) t(n.concat(e).concat({ provide: s, useValue: !0 })); else { const t = n.concat(e).concat({ provide: s, useValue: !0 }, { provide: To, useValue: "platform" }); !function (t) { if (Xp && !Xp.destroyed && !Xp.injector.get(of, !1)) throw new Error("There can be only one platform. Destroy the previous one to create a new one."); Xp = t.get(uf); const e = t.get(Op, null); e && e.forEach(t => t()) }(Vo.create({ providers: t, name: r })) } return function (t) { const e = cf(); if (!e) throw new Error("No platform exists!"); if (!e.injector.get(t, null)) throw new Error("A platform with a different configuration has been created. Please destroy it first."); return e }(s) } } function cf() { return Xp && !Xp.destroyed ? Xp : null } let uf = (() => { class t { constructor(t) { this._injector = t, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(t, e) { const n = function (t, e) { let n; return n = "noop" === t ? new Wp : ("zone.js" === t ? void 0 : t) || new qp({ enableLongStackTrace: rf(), shouldCoalesceEventChangeDetection: !!(null == e ? void 0 : e.ngZoneEventCoalescing), shouldCoalesceRunChangeDetection: !!(null == e ? void 0 : e.ngZoneRunCoalescing) }), n }(e ? e.ngZone : void 0, { ngZoneEventCoalescing: e && e.ngZoneEventCoalescing || !1, ngZoneRunCoalescing: e && e.ngZoneRunCoalescing || !1 }), r = [{ provide: qp, useValue: n }]; return n.run(() => { const e = Vo.create({ providers: r, parent: this.injector, name: t.moduleType.name }), s = t.create(e), i = s.injector.get(bs, null); if (!i) throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?"); return n.runOutsideAngular(() => { const t = n.onError.subscribe({ next: t => { i.handleError(t) } }); s.onDestroy(() => { pf(this._modules, s), t.unsubscribe() }) }), function (t, e, n) { try { const r = n(); return Va(r) ? r.catch(n => { throw e.runOutsideAngular(() => t.handleError(n)), n }) : r } catch (r) { throw e.runOutsideAngular(() => t.handleError(r)), r } }(i, n, () => { const t = s.injector.get(Ep); return t.runInitializers(), t.donePromise.then(() => (Lc(s.injector.get(Ap, Ac) || Ac), this._moduleDoBootstrap(s), s)) }) }) } bootstrapModule(t, e = []) { const n = hf({}, e); return function (t, e, n) { const r = new Wh(n); return Promise.resolve(r) }(0, 0, t).then(t => this.bootstrapModuleFactory(t, n)) } _moduleDoBootstrap(t) { const e = t.injector.get(df); if (t._bootstrapComponents.length > 0) t._bootstrapComponents.forEach(t => e.bootstrap(t)); else { if (!t.instance.ngDoBootstrap) throw new Error(`The module ${u(t.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`); t.instance.ngDoBootstrap(e) } this._modules.push(t) } onDestroy(t) { this._destroyListeners.push(t) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new Error("The platform has already been destroyed!"); this._modules.slice().forEach(t => t.destroy()), this._destroyListeners.forEach(t => t()), this._destroyed = !0 } get destroyed() { return this._destroyed } } return t.\u0275fac = function (e) { return new (e || t)(Qn(Vo)) }, t.\u0275prov = w({ token: t, factory: t.\u0275fac }), t })(); function hf(t, e) { return Array.isArray(e) ? e.reduce(hf, t) : Object.assign(Object.assign({}, t), e) } let df = (() => { class t { constructor(t, e, n, r, s) { this._zone = t, this._injector = e, this._exceptionHandler = n, this._componentFactoryResolver = r, this._initStatus = s, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._stable = !0, this.componentTypes = [], this.components = [], this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const l = new i.y(t => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { t.next(this._stable), t.complete() }) }), c = new i.y(t => { let e; this._zone.runOutsideAngular(() => { e = this._zone.onStable.subscribe(() => { qp.assertNotInAngularZone(), Bp(() => { this._stable || this._zone.hasPendingMacrotasks || this._zone.hasPendingMicrotasks || (this._stable = !0, t.next(!0)) }) }) }); const n = this._zone.onUnstable.subscribe(() => { qp.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { t.next(!1) })) }); return () => { e.unsubscribe(), n.unsubscribe() } }); this.isStable = (0, o.T)(l, c.pipe((0, a.B)())) } bootstrap(t, e) { if (!this._initStatus.done) throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module."); let n; n = t instanceof $u ? t : this._componentFactoryResolver.resolveComponentFactory(t), this.componentTypes.push(n.componentType); const r = n.isBoundToModule ? void 0 : this._injector.get(Ah), s = n.create(Vo.NULL, [], e || n.selector, r), i = s.location.nativeElement, o = s.injector.get(Kp, null), a = o && s.injector.get(Yp); return o && a && a.registerApplication(i, o), s.onDestroy(() => { this.detachView(s.hostView), pf(this.components, s), a && a.unregisterApplication(i) }), this._loadComponent(s), s } tick() { if (this._runningTick) throw new Error("ApplicationRef.tick is called recursively"); try { this._runningTick = !0; for (let t of this._views) t.detectChanges() } catch (t) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(t)) } finally { this._runningTick = !1 } } attachView(t) { const e = t; this._views.push(e), e.attachToAppRef(this) } detachView(t) { const e = t; pf(this._views, e), e.detachFromAppRef() } _loadComponent(t) { this.attachView(t.hostView), this.tick(), this.components.push(t), this._injector.get(Pp, []).concat(this._bootstrapListeners).forEach(e => e(t)) } ngOnDestroy() { this._views.slice().forEach(t => t.destroy()), this._onMicrotaskEmptySubscription.unsubscribe() } get viewCount() { return this._views.length } } return t.\u0275fac = function (e) { return new (e || t)(Qn(qp), Qn(Vo), Qn(bs), Qn(Hu), Qn(Ep)) }, t.\u0275prov = w({ token: t, factory: t.\u0275fac }), t })(); function pf(t, e) { const n = t.indexOf(e); n > -1 && t.splice(n, 1) } class ff { } class gf { } const mf = { factoryPathPrefix: "", factoryPathSuffix: ".ngfactory" }; let _f = (() => { class t { constructor(t, e) { this._compiler = t, this._config = e || mf } load(t) { return this.loadAndCompile(t) } loadAndCompile(t) { let [e, r] = t.split("#"); return void 0 === r && (r = "default"), n(8255)(e).then(t => t[r]).then(t => yf(t, e, r)).then(t => this._compiler.compileModuleAsync(t)) } loadFactory(t) { let [e, r] = t.split("#"), s = "NgFactory"; return void 0 === r && (r = "default", s = ""), n(8255)(this._config.factoryPathPrefix + e + this._config.factoryPathSuffix).then(t => t[r + s]).then(t => yf(t, e, r)) } } return t.\u0275fac = function (e) { return new (e || t)(Qn(Up), Qn(gf, 8)) }, t.\u0275prov = w({ token: t, factory: t.\u0275fac }), t })(); function yf(t, e, n) { if (!t) throw new Error(`Cannot find '${n}' in '${e}'`); return t } const vf = function (t) { return null }, bf = lf(null, "core", [{ provide: Tp, useValue: "unknown" }, { provide: uf, deps: [Vo] }, { provide: Yp, deps: [] }, { provide: kp, deps: [] }]), wf = [{ provide: df, useClass: df, deps: [qp, Vo, bs, Hu, Ep] }, { provide: qh, deps: [qp], useFactory: function (t) { let e = []; return t.onStable.subscribe(() => { for (; e.length;)e.pop()() }), function (t) { e.push(t) } } }, { provide: Ep, useClass: Ep, deps: [[new nr, wp]] }, { provide: Up, useClass: Up, deps: [] }, Cp, { provide: fh, useFactory: function () { return Sh }, deps: [] }, { provide: mh, useFactory: function () { return Ch }, deps: [] }, { provide: Ap, useFactory: function (t) { return Lc(t = t || "undefined" != typeof $localize && $localize.locale || Ac), t }, deps: [[new er(Ap), new nr, new sr]] }, { provide: Ip, useValue: "USD" }]; let Ef = (() => { class t { constructor(t) { } } return t.\u0275fac = function (e) { return new (e || t)(Qn(df)) }, t.\u0275mod = rt({ type: t }), t.\u0275inj = E({ providers: wf }), t })() }, 9474: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => { "use strict"; __webpack_require__.d(__webpack_exports__, { FT: () => StoreDevtoolsModule }); var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5366), _ngrx_store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2294), rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(653), rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8318), rxjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(878), rxjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(1906), rxjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(8489), rxjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(6019), rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1055), rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3835), rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(9996), rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(436), rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(2707), rxjs_operators__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(7701), rxjs_operators__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(7727), rxjs_operators__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(611), rxjs_operators__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(5416), rxjs_operators__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(4689), rxjs_operators__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(4698), rxjs_operators__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(45), rxjs_operators__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(2728), rxjs_operators__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(2023); class StoreDevtoolsConfig { constructor() { this.maxAge = !1 } } const STORE_DEVTOOLS_CONFIG = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.OlP("@ngrx/store-devtools Options"), INITIAL_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.OlP("@ngrx/store-devtools Initial Config"); function noMonitor() { return null } const DEFAULT_NAME = "NgRx Store DevTools"; function createConfig(t) { const e = { maxAge: !1, monitor: noMonitor, actionSanitizer: void 0, stateSanitizer: void 0, name: DEFAULT_NAME, serialize: !1, logOnly: !1, autoPause: !1, features: { pause: !0, lock: !0, persist: !0, export: !0, import: "custom", jump: !0, skip: !0, reorder: !0, dispatch: !0, test: !0 } }, n = "function" == typeof t ? t() : t, r = Object.assign({}, e, { features: n.features || !!n.logOnly && { pause: !0, export: !0, test: !0 } || e.features }, n); if (r.maxAge && r.maxAge < 2) throw new Error(`Devtools 'maxAge' cannot be less than 2, got ${r.maxAge}`); return r } const PERFORM_ACTION = "PERFORM_ACTION", REFRESH = "REFRESH", RESET = "RESET", ROLLBACK = "ROLLBACK", COMMIT = "COMMIT", SWEEP = "SWEEP", TOGGLE_ACTION = "TOGGLE_ACTION", SET_ACTIONS_ACTIVE = "SET_ACTIONS_ACTIVE", JUMP_TO_STATE = "JUMP_TO_STATE", JUMP_TO_ACTION = "JUMP_TO_ACTION", IMPORT_STATE = "IMPORT_STATE", LOCK_CHANGES = "LOCK_CHANGES", PAUSE_RECORDING = "PAUSE_RECORDING"; class PerformAction { constructor(t, e) { if (this.action = t, this.timestamp = e, this.type = PERFORM_ACTION, void 0 === t.type) throw new Error('Actions may not have an undefined "type" property. Have you misspelled a constant?') } } class Refresh { constructor() { this.type = REFRESH } } class Reset { constructor(t) { this.timestamp = t, this.type = RESET } } class Rollback { constructor(t) { this.timestamp = t, this.type = ROLLBACK } } class Commit { constructor(t) { this.timestamp = t, this.type = COMMIT } } class Sweep { constructor() { this.type = SWEEP } } class ToggleAction { constructor(t) { this.id = t, this.type = TOGGLE_ACTION } } class SetActionsActive { constructor(t, e, n = !0) { this.start = t, this.end = e, this.active = n, this.type = SET_ACTIONS_ACTIVE } } class JumpToState { constructor(t) { this.index = t, this.type = JUMP_TO_STATE } } class JumpToAction { constructor(t) { this.actionId = t, this.type = JUMP_TO_ACTION } } class ImportState { constructor(t) { this.nextLiftedState = t, this.type = IMPORT_STATE } } class LockChanges { constructor(t) { this.status = t, this.type = LOCK_CHANGES } } class PauseRecording { constructor(t) { this.status = t, this.type = PAUSE_RECORDING } } let DevtoolsDispatcher = (() => { class t extends _ngrx_store__WEBPACK_IMPORTED_MODULE_1__.UO { } return t.\u0275fac = function () { let e; return function (n) { return (e || (e = _angular_core__WEBPACK_IMPORTED_MODULE_0__.n5z(t)))(n || t) } }(), t.\u0275prov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Yz7({ token: t, factory: t.\u0275fac }), t })(); function difference(t, e) { return t.filter(t => e.indexOf(t) < 0) } function unliftState(t) { const { computedStates: e, currentStateIndex: n } = t; if (n >= e.length) { const { state: t } = e[e.length - 1]; return t } const { state: r } = e[n]; return r } function unliftAction(t) { return t.actionsById[t.nextActionId - 1] } function liftAction(t) { return new PerformAction(t, +Date.now()) } function sanitizeActions(t, e) { return Object.keys(e).reduce((n, r) => { const s = Number(r); return n[s] = sanitizeAction(t, e[s], s), n }, {}) } function sanitizeAction(t, e, n) { return Object.assign(Object.assign({}, e), { action: t(e.action, n) }) } function sanitizeStates(t, e) { return e.map((e, n) => ({ state: sanitizeState(t, e.state, n), error: e.error })) } function sanitizeState(t, e, n) { return t(e, n) } function shouldFilterActions(t) { return t.predicate || t.actionsSafelist || t.actionsBlocklist } function filterLiftedState(t, e, n, r) { const s = [], i = {}, o = []; return t.stagedActionIds.forEach((a, l) => { const c = t.actionsById[a]; c && (l && isActionFiltered(t.computedStates[l], c, e, n, r) || (i[a] = c, s.push(a), o.push(t.computedStates[l]))) }), Object.assign(Object.assign({}, t), { stagedActionIds: s, actionsById: i, computedStates: o }) } function isActionFiltered(t, e, n, r, s) { const i = n && !n(t, e.action), o = r && !e.action.type.match(r.map(t => escapeRegExp(t)).join("|")), a = s && e.action.type.match(s.map(t => escapeRegExp(t)).join("|")); return i || o || a } function escapeRegExp(t) { return t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") } const ExtensionActionTypes = { START: "START", DISPATCH: "DISPATCH", STOP: "STOP", ACTION: "ACTION" }, REDUX_DEVTOOLS_EXTENSION = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.OlP("@ngrx/store-devtools Redux Devtools Extension"); let DevtoolsExtension = (() => { class DevtoolsExtension { constructor(t, e, n) { this.config = e, this.dispatcher = n, this.devtoolsExtension = t, this.createActionStreams() } notify(t, e) { if (this.devtoolsExtension) if (t.type === PERFORM_ACTION) { if (e.isLocked || e.isPaused) return; const n = unliftState(e); if (shouldFilterActions(this.config) && isActionFiltered(n, t, this.config.predicate, this.config.actionsSafelist, this.config.actionsBlocklist)) return; const r = this.config.stateSanitizer ? sanitizeState(this.config.stateSanitizer, n, e.currentStateIndex) : n, s = this.config.actionSanitizer ? sanitizeAction(this.config.actionSanitizer, t, e.nextActionId) : t; this.sendToReduxDevtools(() => this.extensionConnection.send(s, r)) } else { const t = Object.assign(Object.assign({}, e), { stagedActionIds: e.stagedActionIds, actionsById: this.config.actionSanitizer ? sanitizeActions(this.config.actionSanitizer, e.actionsById) : e.actionsById, computedStates: this.config.stateSanitizer ? sanitizeStates(this.config.stateSanitizer, e.computedStates) : e.computedStates }); this.sendToReduxDevtools(() => this.devtoolsExtension.send(null, t, this.getExtensionConfig(this.config))) } } createChangesObservable() { return this.devtoolsExtension ? new rxjs__WEBPACK_IMPORTED_MODULE_3__.y(t => { const e = this.devtoolsExtension.connect(this.getExtensionConfig(this.config)); return this.extensionConnection = e, e.init(), e.subscribe(e => t.next(e)), e.unsubscribe }) : rxjs__WEBPACK_IMPORTED_MODULE_2__.E } createActionStreams() { const t = this.createChangesObservable().pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.B)()), e = t.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.h)(t => t.type === ExtensionActionTypes.START)), n = t.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.h)(t => t.type === ExtensionActionTypes.STOP)), r = t.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.h)(t => t.type === ExtensionActionTypes.DISPATCH), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.U)(t => this.unwrapAction(t.payload)), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.b)(t => t.type === IMPORT_STATE ? this.dispatcher.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.h)(t => t.type === _ngrx_store__WEBPACK_IMPORTED_MODULE_1__.wb), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.V)(1e3), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.b)(1e3), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.U)(() => t), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.K)(() => (0, rxjs__WEBPACK_IMPORTED_MODULE_11__.of)(t)), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_12__.q)(1)) : (0, rxjs__WEBPACK_IMPORTED_MODULE_11__.of)(t))), s = t.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.h)(t => t.type === ExtensionActionTypes.ACTION), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.U)(t => this.unwrapAction(t.payload))).pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_13__.R)(n)), i = r.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_13__.R)(n)); this.start$ = e.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_13__.R)(n)), this.actions$ = this.start$.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_14__.w)(() => s)), this.liftedActions$ = this.start$.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_14__.w)(() => i)) } unwrapAction(action) { return "string" == typeof action ? eval(`(${action})`) : action } getExtensionConfig(t) { var e; const n = { name: t.name, features: t.features, serialize: t.serialize, autoPause: null !== (e = t.autoPause) && void 0 !== e && e }; return !1 !== t.maxAge && (n.maxAge = t.maxAge), n } sendToReduxDevtools(t) { try { t() } catch (e) { console.warn("@ngrx/store-devtools: something went wrong inside the redux devtools", e) } } } return DevtoolsExtension.\u0275fac = function (t) { return new (t || DevtoolsExtension)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.LFG(REDUX_DEVTOOLS_EXTENSION), _angular_core__WEBPACK_IMPORTED_MODULE_0__.LFG(STORE_DEVTOOLS_CONFIG), _angular_core__WEBPACK_IMPORTED_MODULE_0__.LFG(DevtoolsDispatcher)) }, DevtoolsExtension.\u0275prov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Yz7({ token: DevtoolsExtension, factory: DevtoolsExtension.\u0275fac }), DevtoolsExtension })(); const INIT_ACTION = { type: _ngrx_store__WEBPACK_IMPORTED_MODULE_1__.qg }, RECOMPUTE = "@ngrx/store-devtools/recompute", RECOMPUTE_ACTION = { type: RECOMPUTE }; function computeNextEntry(t, e, n, r, s) { if (r) return { state: n, error: "Interrupted by an error up the chain" }; let i, o = n; try { o = t(n, e) } catch (a) { i = a.toString(), s.handleError(a) } return { state: o, error: i } } function recomputeStates(t, e, n, r, s, i, o, a, l) { if (e >= t.length && t.length === i.length) return t; const c = t.slice(0, e), u = i.length - (l ? 1 : 0); for (let h = e; h < u; h++) { const t = i[h], e = s[t].action, l = c[h - 1], u = l ? l.state : r, d = l ? l.error : void 0, p = o.indexOf(t) > -1 ? l : computeNextEntry(n, e, u, d, a); c.push(p) } return l && c.push(t[t.length - 1]), c } function liftInitialState(t, e) { return { monitorState: e(void 0, {}), nextActionId: 1, actionsById: { 0: liftAction(INIT_ACTION) }, stagedActionIds: [0], skippedActionIds: [], committedState: t, currentStateIndex: 0, computedStates: [], isLocked: !1, isPaused: !1 } } function liftReducerWith(t, e, n, r, s = {}) { return i => (o, a) => { let { monitorState: l, actionsById: c, nextActionId: u, stagedActionIds: h, skippedActionIds: d, committedState: p, currentStateIndex: f, computedStates: g, isLocked: m, isPaused: _ } = o || e; function y(t) { let e = t, n = h.slice(1, e + 1); for (let r = 0; r < n.length; r++) { if (g[r + 1].error) { e = r, n = h.slice(1, e + 1); break } delete c[n[r]] } d = d.filter(t => -1 === n.indexOf(t)), h = [0, ...h.slice(e + 1)], p = g[e].state, g = g.slice(e), f = f > e ? f - e : 0 } function v() { c = { 0: liftAction(INIT_ACTION) }, u = 1, h = [0], d = [], p = g[f].state, f = 0, g = [] } o || (c = Object.create(c)); let b = 0; switch (a.type) { case LOCK_CHANGES: m = a.status, b = 1 / 0; break; case PAUSE_RECORDING: _ = a.status, _ ? (h = [...h, u], c[u] = new PerformAction({ type: "@ngrx/devtools/pause" }, +Date.now()), u++, b = h.length - 1, g = g.concat(g[g.length - 1]), f === h.length - 2 && f++, b = 1 / 0) : v(); break; case RESET: c = { 0: liftAction(INIT_ACTION) }, u = 1, h = [0], d = [], p = t, f = 0, g = []; break; case COMMIT: v(); break; case ROLLBACK: c = { 0: liftAction(INIT_ACTION) }, u = 1, h = [0], d = [], f = 0, g = []; break; case TOGGLE_ACTION: { const { id: t } = a, e = d.indexOf(t); d = -1 === e ? [t, ...d] : d.filter(e => e !== t), b = h.indexOf(t); break } case SET_ACTIONS_ACTIVE: { const { start: t, end: e, active: n } = a, r = []; for (let s = t; s < e; s++)r.push(s); d = n ? difference(d, r) : [...d, ...r], b = h.indexOf(t); break } case JUMP_TO_STATE: f = a.index, b = 1 / 0; break; case JUMP_TO_ACTION: { const t = h.indexOf(a.actionId); -1 !== t && (f = t), b = 1 / 0; break } case SWEEP: h = difference(h, d), d = [], f = Math.min(f, h.length - 1); break; case PERFORM_ACTION: { if (m) return o || e; if (_ || o && isActionFiltered(o.computedStates[f], a, s.predicate, s.actionsSafelist, s.actionsBlocklist)) { const t = g[g.length - 1]; g = [...g.slice(0, -1), computeNextEntry(i, a.action, t.state, t.error, n)], b = 1 / 0; break } s.maxAge && h.length === s.maxAge && y(1), f === h.length - 1 && f++; const t = u++; c[t] = a, h = [...h, t], b = h.length - 1; break } case IMPORT_STATE: ({ monitorState: l, actionsById: c, nextActionId: u, stagedActionIds: h, skippedActionIds: d, committedState: p, currentStateIndex: f, computedStates: g, isLocked: m, isPaused: _ } = a.nextLiftedState); break; case _ngrx_store__WEBPACK_IMPORTED_MODULE_1__.qg: b = 0, s.maxAge && h.length > s.maxAge && (g = recomputeStates(g, b, i, p, c, h, d, n, _), y(h.length - s.maxAge), b = 1 / 0); break; case _ngrx_store__WEBPACK_IMPORTED_MODULE_1__.wb: if (g.filter(t => t.error).length > 0) b = 0, s.maxAge && h.length > s.maxAge && (g = recomputeStates(g, b, i, p, c, h, d, n, _), y(h.length - s.maxAge), b = 1 / 0); else { if (!_ && !m) { f === h.length - 1 && f++; const t = u++; c[t] = new PerformAction(a, +Date.now()), h = [...h, t], b = h.length - 1, g = recomputeStates(g, b, i, p, c, h, d, n, _) } g = g.map(t => Object.assign(Object.assign({}, t), { state: i(t.state, RECOMPUTE_ACTION) })), f = h.length - 1, s.maxAge && h.length > s.maxAge && y(h.length - s.maxAge), b = 1 / 0 } break; default: b = 1 / 0 }return g = recomputeStates(g, b, i, p, c, h, d, n, _), l = r(l, a), { monitorState: l, actionsById: c, nextActionId: u, stagedActionIds: h, skippedActionIds: d, committedState: p, currentStateIndex: f, computedStates: g, isLocked: m, isPaused: _ } } } let StoreDevtools = (() => { class t { constructor(t, e, n, r, s, i, o, a) { const l = liftInitialState(o, a.monitor), c = liftReducerWith(o, l, i, a.monitor, a), u = (0, rxjs__WEBPACK_IMPORTED_MODULE_15__.T)((0, rxjs__WEBPACK_IMPORTED_MODULE_15__.T)(e.asObservable().pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_16__.T)(1)), r.actions$).pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.U)(liftAction)), t, r.liftedActions$).pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_17__.QV)(rxjs__WEBPACK_IMPORTED_MODULE_18__.N)), h = n.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.U)(c)), d = new rxjs__WEBPACK_IMPORTED_MODULE_19__.t(1), p = u.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_20__.M)(h), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_21__.R)(({ state: t }, [e, n]) => { let s = n(t, e); return e.type !== PERFORM_ACTION && shouldFilterActions(a) && (s = filterLiftedState(s, a.predicate, a.actionsSafelist, a.actionsBlocklist)), r.notify(e, s), { state: s, action: e } }, { state: l, action: null })).subscribe(({ state: t, action: e }) => { d.next(t), e.type === PERFORM_ACTION && s.next(e.action) }), f = r.start$.subscribe(() => { this.refresh() }), g = d.asObservable(), m = g.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.U)(unliftState)); this.extensionStartSubscription = f, this.stateSubscription = p, this.dispatcher = t, this.liftedState = g, this.state = m } dispatch(t) { this.dispatcher.next(t) } next(t) { this.dispatcher.next(t) } error(t) { } complete() { } performAction(t) { this.dispatch(new PerformAction(t, +Date.now())) } refresh() { this.dispatch(new Refresh) } reset() { this.dispatch(new Reset(+Date.now())) } rollback() { this.dispatch(new Rollback(+Date.now())) } commit() { this.dispatch(new Commit(+Date.now())) } sweep() { this.dispatch(new Sweep) } toggleAction(t) { this.dispatch(new ToggleAction(t)) } jumpToAction(t) { this.dispatch(new JumpToAction(t)) } jumpToState(t) { this.dispatch(new JumpToState(t)) } importState(t) { this.dispatch(new ImportState(t)) } lockChanges(t) { this.dispatch(new LockChanges(t)) } pauseRecording(t) { this.dispatch(new PauseRecording(t)) } } return t.\u0275fac = function (e) { return new (e || t)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.LFG(DevtoolsDispatcher), _angular_core__WEBPACK_IMPORTED_MODULE_0__.LFG(_ngrx_store__WEBPACK_IMPORTED_MODULE_1__.UO), _angular_core__WEBPACK_IMPORTED_MODULE_0__.LFG(_ngrx_store__WEBPACK_IMPORTED_MODULE_1__.n$), _angular_core__WEBPACK_IMPORTED_MODULE_0__.LFG(DevtoolsExtension), _angular_core__WEBPACK_IMPORTED_MODULE_0__.LFG(_ngrx_store__WEBPACK_IMPORTED_MODULE_1__.Y$), _angular_core__WEBPACK_IMPORTED_MODULE_0__.LFG(_angular_core__WEBPACK_IMPORTED_MODULE_0__.qLn), _angular_core__WEBPACK_IMPORTED_MODULE_0__.LFG(_ngrx_store__WEBPACK_IMPORTED_MODULE_1__.Y6), _angular_core__WEBPACK_IMPORTED_MODULE_0__.LFG(STORE_DEVTOOLS_CONFIG)) }, t.\u0275prov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Yz7({ token: t, factory: t.\u0275fac }), t })(); const IS_EXTENSION_OR_MONITOR_PRESENT = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.OlP("@ngrx/store-devtools Is Devtools Extension or Monitor Present"); function createIsExtensionOrMonitorPresent(t, e) { return Boolean(t) || e.monitor !== noMonitor } function createReduxDevtoolsExtension() { const t = "__REDUX_DEVTOOLS_EXTENSION__"; return "object" == typeof window && void 0 !== window[t] ? window[t] : null } function createStateObservable(t) { return t.state } let StoreDevtoolsModule = (() => { class t { static instrument(e = {}) { return { ngModule: t, providers: [DevtoolsExtension, DevtoolsDispatcher, StoreDevtools, { provide: INITIAL_OPTIONS, useValue: e }, { provide: IS_EXTENSION_OR_MONITOR_PRESENT, deps: [REDUX_DEVTOOLS_EXTENSION, STORE_DEVTOOLS_CONFIG], useFactory: createIsExtensionOrMonitorPresent }, { provide: REDUX_DEVTOOLS_EXTENSION, useFactory: createReduxDevtoolsExtension }, { provide: STORE_DEVTOOLS_CONFIG, deps: [INITIAL_OPTIONS], useFactory: createConfig }, { provide: _ngrx_store__WEBPACK_IMPORTED_MODULE_1__.FR, deps: [StoreDevtools], useFactory: createStateObservable }, { provide: _ngrx_store__WEBPACK_IMPORTED_MODULE_1__.mK, useExisting: DevtoolsDispatcher }] } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = _angular_core__WEBPACK_IMPORTED_MODULE_0__.oAB({ type: t }), t.\u0275inj = _angular_core__WEBPACK_IMPORTED_MODULE_0__.cJS({}), t })() }, 2294: (t, e, n) => { "use strict"; n.d(e, { UO: () => b, qg: () => v, Y6: () => C, mK: () => Z, n$: () => G, Y$: () => Q, FR: () => X, yh: () => rt, CK: () => Ct, Aw: () => xt, cr: () => St, wb: () => W, qC: () => z, PH: () => _ }); var r = n(5366), s = n(8512), i = n(8318), o = n(5959), a = n(8489), l = n(6673); class c { constructor(t, e) { this.compare = t, this.keySelector = e } call(t, e) { return e.subscribe(new u(t, this.compare, this.keySelector)) } } class u extends l.L { constructor(t, e, n) { super(t), this.keySelector = n, this.hasKey = !1, "function" == typeof e && (this.compare = e) } compare(t, e) { return t === e } _next(t) { let e; try { const { keySelector: n } = this; e = n ? n(t) : t } catch (r) { return this.destination.error(r) } let n = !1; if (this.hasKey) try { const { compare: t } = this; n = t(this.key, e) } catch (r) { return this.destination.error(r) } else this.hasKey = !0; n || (this.key = e, this.destination.next(t)) } } var h = n(45), d = n(2728), p = n(2023), f = n(3588), g = n(9996); const m = {}; function _(t, e) { if (m[t] = (m[t] || 0) + 1, "function" == typeof e) return y(t, (...n) => Object.assign(Object.assign({}, e(...n)), { type: t })); switch (e ? e._as : "empty") { case "empty": return y(t, () => ({ type: t })); case "props": return y(t, e => Object.assign(Object.assign({}, e), { type: t })); default: throw new Error("Unexpected config.") } } function y(t, e) { return Object.defineProperty(e, "type", { value: t, writable: !1 }) } const v = "@ngrx/store/init"; let b = (() => { class t extends s.X { constructor() { super({ type: v }) } next(t) { if ("function" == typeof t) throw new TypeError("\n        Dispatch expected an object, instead it received a function.\n        If you're using the createAction function, make sure to invoke the function\n        before dispatching the action. For example, someAction should be someAction()."); if (void 0 === t) throw new TypeError("Actions must be objects"); if (void 0 === t.type) throw new TypeError("Actions must have a type property"); super.next(t) } complete() { } ngOnDestroy() { super.complete() } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(); const w = [b], E = new r.OlP("@ngrx/store Internal Root Guard"), S = new r.OlP("@ngrx/store Internal Initial State"), C = new r.OlP("@ngrx/store Initial State"), x = new r.OlP("@ngrx/store Reducer Factory"), O = new r.OlP("@ngrx/store Internal Reducer Factory Provider"), T = new r.OlP("@ngrx/store Initial Reducers"), P = new r.OlP("@ngrx/store Internal Initial Reducers"), k = new r.OlP("@ngrx/store Store Features"), A = new r.OlP("@ngrx/store Internal Store Reducers"), I = new r.OlP("@ngrx/store Internal Feature Reducers"), R = new r.OlP("@ngrx/store Internal Feature Configs"), M = new r.OlP("@ngrx/store Internal Store Features"), D = new r.OlP("@ngrx/store Internal Feature Reducers Token"), L = new r.OlP("@ngrx/store Feature Reducers"), N = new r.OlP("@ngrx/store User Provided Meta Reducers"), F = new r.OlP("@ngrx/store Meta Reducers"), j = new r.OlP("@ngrx/store Internal Resolved Meta Reducers"), U = new r.OlP("@ngrx/store User Runtime Checks Config"), V = new r.OlP("@ngrx/store Internal User Runtime Checks Config"), B = new r.OlP("@ngrx/store Internal Runtime Checks"), q = new r.OlP("@ngrx/store Check if Action types are unique"); function $(t, e = {}) { const n = Object.keys(t), r = {}; for (let i = 0; i < n.length; i++) { const e = n[i]; "function" == typeof t[e] && (r[e] = t[e]) } const s = Object.keys(r); return function (t, n) { t = void 0 === t ? e : t; let i = !1; const o = {}; for (let e = 0; e < s.length; e++) { const a = s[e], l = t[a], c = (0, r[a])(l, n); o[a] = c, i = i || c !== l } return i ? o : t } } function z(...t) { return function (e) { if (0 === t.length) return e; const n = t[t.length - 1]; return t.slice(0, -1).reduceRight((t, e) => e(t), n(e)) } } function H(t, e) { return Array.isArray(e) && e.length > 0 && (t = z.apply(null, [...e, t])), (e, n) => { const r = t(e); return (t, e) => r(t = void 0 === t ? n : t, e) } } class G extends i.y { } class Z extends b { } const W = "@ngrx/store/update-reducers"; let K = (() => { class t extends s.X { constructor(t, e, n, r) { super(r(n, e)), this.dispatcher = t, this.initialState = e, this.reducers = n, this.reducerFactory = r } addFeature(t) { this.addFeatures([t]) } addFeatures(t) { const e = t.reduce((t, { reducers: e, reducerFactory: n, metaReducers: r, initialState: s, key: i }) => { const o = "function" == typeof e ? function (t) { const e = Array.isArray(t) && t.length > 0 ? z(...t) : t => t; return (t, n) => (t = e(t), (e, r) => t(e = void 0 === e ? n : e, r)) }(r)(e, s) : H(n, r)(e, s); return t[i] = o, t }, {}); this.addReducers(e) } removeFeature(t) { this.removeFeatures([t]) } removeFeatures(t) { this.removeReducers(t.map(t => t.key)) } addReducer(t, e) { this.addReducers({ [t]: e }) } addReducers(t) { this.reducers = Object.assign(Object.assign({}, this.reducers), t), this.updateReducers(Object.keys(t)) } removeReducer(t) { this.removeReducers([t]) } removeReducers(t) { t.forEach(t => { var e, n; this.reducers = (e = this.reducers, n = t, Object.keys(e).filter(t => t !== n).reduce((t, n) => Object.assign(t, { [n]: e[n] }), {})) }), this.updateReducers(t) } updateReducers(t) { this.next(this.reducerFactory(this.reducers, this.initialState)), this.dispatcher.next({ type: W, features: t }) } ngOnDestroy() { this.complete() } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(Z), r.LFG(C), r.LFG(T), r.LFG(x)) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(); const Y = [K, { provide: G, useExisting: K }, { provide: Z, useExisting: b }]; let Q = (() => { class t extends o.xQ { ngOnDestroy() { this.complete() } } return t.\u0275fac = function () { let e; return function (n) { return (e || (e = r.n5z(t)))(n || t) } }(), t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(); const J = [Q]; class X extends i.y { } let tt = (() => { class t extends s.X { constructor(t, e, n, r) { super(r); const s = t.pipe((0, h.QV)(a.N)).pipe((0, d.M)(e)).pipe((0, p.R)(et, { state: r })); this.stateSubscription = s.subscribe(({ state: t, action: e }) => { this.next(t), n.next(e) }) } ngOnDestroy() { this.stateSubscription.unsubscribe(), this.complete() } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(b), r.LFG(G), r.LFG(Q), r.LFG(C)) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t.INIT = v, t })(); function et(t = { state: void 0 }, [e, n]) { const { state: r } = t; return { state: n(r, e), action: e } } const nt = [tt, { provide: X, useExisting: tt }]; let rt = (() => { class t extends i.y { constructor(t, e, n) { super(), this.actionsObserver = e, this.reducerManager = n, this.source = t } select(t, ...e) { return it.call(null, t, ...e)(this) } lift(e) { const n = new t(this, this.actionsObserver, this.reducerManager); return n.operator = e, n } dispatch(t) { this.actionsObserver.next(t) } next(t) { this.actionsObserver.next(t) } error(t) { this.actionsObserver.error(t) } complete() { this.actionsObserver.complete() } addReducer(t, e) { this.reducerManager.addReducer(t, e) } removeReducer(t) { this.reducerManager.removeReducer(t) } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(X), r.LFG(b), r.LFG(K)) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(); const st = [rt]; function it(t, e, ...n) { return function (r) { let s; if ("string" == typeof t) { const i = [e, ...n].filter(Boolean); s = r.pipe((0, f.j)(t, ...i)) } else { if ("function" != typeof t) throw new TypeError(`Unexpected type '${typeof t}' in select operator, expected 'string' or 'function'`); s = r.pipe((0, g.U)(n => t(n, e))) } return s.pipe(t => t.lift(new c(void 0, void 0))) } } const ot = "https://ngrx.io/guide/store/configuration/runtime-checks"; function at(t) { return void 0 === t } function lt(t) { return null === t } function ct(t) { return Array.isArray(t) } function ut(t) { return "object" == typeof t && null !== t } function ht(t) { return "function" == typeof t } function dt(t) { Object.freeze(t); const e = ht(t); return Object.getOwnPropertyNames(t).forEach(n => { if (!n.startsWith("\u0275") && function (t, e) { return Object.prototype.hasOwnProperty.call(t, e) }(t, n) && (!e || "caller" !== n && "callee" !== n && "arguments" !== n)) { const e = t[n]; !ut(e) && !ht(e) || Object.isFrozen(e) || dt(e) } }), t } function pt(t, e = []) { return (at(t) || lt(t)) && 0 === e.length ? { path: ["root"], value: t } : Object.keys(t).reduce((n, r) => { if (n) return n; const s = t[r]; return function (t) { return ht(t) && t.hasOwnProperty("\u0275cmp") }(s) ? n : !(at(s) || lt(s) || function (t) { return "number" == typeof t }(s) || function (t) { return "boolean" == typeof t }(s) || function (t) { return "string" == typeof t }(s) || ct(s)) && (function (t) { if (!function (t) { return ut(t) && !ct(t) }(t)) return !1; const e = Object.getPrototypeOf(t); return e === Object.prototype || null === e }(s) ? pt(s, [...e, r]) : { path: [...e, r], value: s }) }, !1) } function ft(t, e) { if (!1 === t) return; const n = t.path.join("."), r = new Error(`Detected unserializable ${e} at "${n}". ${ot}#strict${e}serializability`); throw r.value = t.value, r.unserializablePath = n, r } function gt(t) { return (0, r.X6Q)() ? Object.assign({ strictStateSerializability: !1, strictActionSerializability: !1, strictStateImmutability: !0, strictActionImmutability: !0, strictActionWithinNgZone: !1, strictActionTypeUniqueness: !1 }, t) : { strictStateSerializability: !1, strictActionSerializability: !1, strictStateImmutability: !1, strictActionImmutability: !1, strictActionWithinNgZone: !1, strictActionTypeUniqueness: !1 } } function mt({ strictActionSerializability: t, strictStateSerializability: e }) { return n => t || e ? function (t, e) { return function (n, r) { e.action(r) && ft(pt(r), "action"); const s = t(n, r); return e.state() && ft(pt(s), "state"), s } }(n, { action: e => t && !yt(e), state: () => e }) : n } function _t({ strictActionImmutability: t, strictStateImmutability: e }) { return n => t || e ? function (t, e) { return function (n, r) { const s = e.action(r) ? dt(r) : r, i = t(n, s); return e.state() ? dt(i) : i } }(n, { action: e => t && !yt(e), state: () => e }) : n } function yt(t) { return t.type.startsWith("@ngrx") } function vt({ strictActionWithinNgZone: t }) { return e => t ? function (t, e) { return function (n, s) { if (e.action(s) && !r.R0b.isInAngularZone()) throw new Error(`Action '${s.type}' running outside NgZone. ${ot}#strictactionwithinngzone`); return t(n, s) } }(e, { action: e => t && !yt(e) }) : e } function bt() { return [{ provide: q, multi: !0, deps: [B], useFactory: Et }] } function wt(t) { return t } function Et(t) { if (!t.strictActionTypeUniqueness) return; const e = Object.entries(m).filter(([, t]) => t > 1).map(([t]) => t); if (e.length) throw new Error(`Action types are registered more than once, ${e.map(t => `"${t}"`).join(", ")}. ${ot}#strictactiontypeuniqueness`) } let St = (() => { class t { constructor(t, e, n, r, s, i) { } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(b), r.LFG(G), r.LFG(Q), r.LFG(rt), r.LFG(E, 8), r.LFG(q, 8)) }, t.\u0275mod = r.oAB({ type: t }), t.\u0275inj = r.cJS({}), t })(), Ct = (() => { class t { constructor(t, e, n, r, s) { this.features = t, this.featureReducers = e, this.reducerManager = n; const i = t.map((t, n) => { const r = e.shift()[n]; return Object.assign(Object.assign({}, t), { reducers: r, initialState: kt(t.initialState) }) }); n.addFeatures(i) } ngOnDestroy() { this.reducerManager.removeFeatures(this.features) } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(M), r.LFG(L), r.LFG(K), r.LFG(St), r.LFG(q, 8)) }, t.\u0275mod = r.oAB({ type: t }), t.\u0275inj = r.cJS({}), t })(), xt = (() => { class t { static forRoot(t, e = {}) { return { ngModule: St, providers: [{ provide: E, useFactory: It, deps: [[rt, new r.FiY, new r.tp0]] }, { provide: S, useValue: e.initialState }, { provide: C, useFactory: kt, deps: [S] }, { provide: P, useValue: t }, { provide: A, useExisting: t instanceof r.OlP ? t : P }, { provide: T, deps: [r.zs3, P, [new r.tBr(A)]], useFactory: Ot }, { provide: N, useValue: e.metaReducers ? e.metaReducers : [] }, { provide: j, deps: [F, N], useFactory: At }, { provide: O, useValue: e.reducerFactory ? e.reducerFactory : $ }, { provide: x, deps: [O, j], useFactory: H }, w, Y, J, nt, st, (n = e.runtimeChecks, [{ provide: V, useValue: n }, { provide: U, useFactory: wt, deps: [V] }, { provide: B, deps: [U], useFactory: gt }, { provide: F, multi: !0, deps: [B], useFactory: _t }, { provide: F, multi: !0, deps: [B], useFactory: mt }, { provide: F, multi: !0, deps: [B], useFactory: vt }]), bt()] }; var n } static forFeature(t, e, n = {}) { return { ngModule: Ct, providers: [{ provide: R, multi: !0, useValue: t instanceof Object ? {} : n }, { provide: k, multi: !0, useValue: { key: t instanceof Object ? t.name : t, reducerFactory: n instanceof r.OlP || !n.reducerFactory ? $ : n.reducerFactory, metaReducers: n instanceof r.OlP || !n.metaReducers ? [] : n.metaReducers, initialState: n instanceof r.OlP || !n.initialState ? void 0 : n.initialState } }, { provide: M, deps: [r.zs3, R, k], useFactory: Tt }, { provide: I, multi: !0, useValue: t instanceof Object ? t.reducer : e }, { provide: D, multi: !0, useExisting: e instanceof r.OlP ? e : I }, { provide: L, multi: !0, deps: [r.zs3, I, [new r.tBr(D)]], useFactory: Pt }, bt()] } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = r.oAB({ type: t }), t.\u0275inj = r.cJS({}), t })(); function Ot(t, e) { return e instanceof r.OlP ? t.get(e) : e } function Tt(t, e, n) { return n.map((n, s) => { if (e[s] instanceof r.OlP) { const r = t.get(e[s]); return { key: n.key, reducerFactory: r.reducerFactory ? r.reducerFactory : $, metaReducers: r.metaReducers ? r.metaReducers : [], initialState: r.initialState } } return n }) } function Pt(t, e) { return e.map(e => e instanceof r.OlP ? t.get(e) : e) } function kt(t) { return "function" == typeof t ? t() : t } function At(t, e) { return t.concat(e) } function It(t) { if (t) throw new TypeError("StoreModule.forRoot() called twice. Feature modules should use StoreModule.forFeature() instead."); return "guarded" } }, 8512: (t, e, n) => { "use strict"; n.d(e, { X: () => i }); var r = n(5959), s = n(3895); class i extends r.xQ { constructor(t) { super(), this._value = t } get value() { return this.getValue() } _subscribe(t) { const e = super._subscribe(t); return e && !e.closed && t.next(this._value), e } getValue() { if (this.hasError) throw this.thrownError; if (this.closed) throw new s.N; return this._value } next(t) { super.next(this._value = t) } } }, 3103: (t, e, n) => { "use strict"; n.d(e, { P: () => o }); var r = n(653), s = n(878), i = n(1225); let o = (() => { class t { constructor(t, e, n) { this.kind = t, this.value = e, this.error = n, this.hasValue = "N" === t } observe(t) { switch (this.kind) { case "N": return t.next && t.next(this.value); case "E": return t.error && t.error(this.error); case "C": return t.complete && t.complete() } } do(t, e, n) { switch (this.kind) { case "N": return t && t(this.value); case "E": return e && e(this.error); case "C": return n && n() } } accept(t, e, n) { return t && "function" == typeof t.next ? this.observe(t) : this.do(t, e, n) } toObservable() { switch (this.kind) { case "N": return (0, s.of)(this.value); case "E": return (0, i._)(this.error); case "C": return (0, r.c)() }throw new Error("unexpected notification kind value") } static createNext(e) { return void 0 !== e ? new t("N", e) : t.undefinedValueNotification } static createError(e) { return new t("E", void 0, e) } static createComplete() { return t.completeNotification } } return t.completeNotification = new t("C"), t.undefinedValueNotification = new t("N", void 0), t })() }, 8318: (t, e, n) => { "use strict"; n.d(e, { y: () => c }); var r = n(6673), s = n(5331), i = n(7498), o = n(6197), a = n(3392), l = n(1484); let c = (() => { class t { constructor(t) { this._isScalar = !1, t && (this._subscribe = t) } lift(e) { const n = new t; return n.source = this, n.operator = e, n } subscribe(t, e, n) { const { operator: o } = this, a = function (t, e, n) { if (t) { if (t instanceof r.L) return t; if (t[s.b]) return t[s.b]() } return t || e || n ? new r.L(t, e, n) : new r.L(i.c) }(t, e, n); if (a.add(o ? o.call(a, this.source) : this.source || l.v.useDeprecatedSynchronousErrorHandling && !a.syncErrorThrowable ? this._subscribe(a) : this._trySubscribe(a)), l.v.useDeprecatedSynchronousErrorHandling && a.syncErrorThrowable && (a.syncErrorThrowable = !1, a.syncErrorThrown)) throw a.syncErrorValue; return a } _trySubscribe(t) { try { return this._subscribe(t) } catch (e) { l.v.useDeprecatedSynchronousErrorHandling && (t.syncErrorThrown = !0, t.syncErrorValue = e), function (t) { for (; t;) { const { closed: e, destination: n, isStopped: s } = t; if (e || s) return !1; t = n && n instanceof r.L ? n : null } return !0 }(t) ? t.error(e) : console.warn(e) } } forEach(t, e) { return new (e = u(e))((e, n) => { let r; r = this.subscribe(e => { try { t(e) } catch (s) { n(s), r && r.unsubscribe() } }, n, e) }) } _subscribe(t) { const { source: e } = this; return e && e.subscribe(t) } [o.L]() { return this } pipe(...t) { return 0 === t.length ? this : (0 === (e = t).length ? a.y : 1 === e.length ? e[0] : function (t) { return e.reduce((t, e) => e(t), t) })(this); var e } toPromise(t) { return new (t = u(t))((t, e) => { let n; this.subscribe(t => n = t, t => e(t), () => t(n)) }) } } return t.create = e => new t(e), t })(); function u(t) { if (t || (t = l.v.Promise || Promise), !t) throw new Error("no Promise impl found"); return t } }, 7498: (t, e, n) => { "use strict"; n.d(e, { c: () => i }); var r = n(1484), s = n(4294); const i = { closed: !0, next(t) { }, error(t) { if (r.v.useDeprecatedSynchronousErrorHandling) throw t; (0, s.z)(t) }, complete() { } } }, 9829: (t, e, n) => { "use strict"; n.d(e, { L: () => s }); var r = n(6673); class s extends r.L { notifyNext(t, e, n, r, s) { this.destination.next(e) } notifyError(t, e) { this.destination.error(t) } notifyComplete(t) { this.destination.complete() } } }, 6019: (t, e, n) => { "use strict"; n.d(e, { t: () => c }); var r = n(5959), s = n(8489), i = n(7570), o = n(45), a = n(3895), l = n(9291); class c extends r.xQ { constructor(t = Number.POSITIVE_INFINITY, e = Number.POSITIVE_INFINITY, n) { super(), this.scheduler = n, this._events = [], this._infiniteTimeWindow = !1, this._bufferSize = t < 1 ? 1 : t, this._windowTime = e < 1 ? 1 : e, e === Number.POSITIVE_INFINITY ? (this._infiniteTimeWindow = !0, this.next = this.nextInfiniteTimeWindow) : this.next = this.nextTimeWindow } nextInfiniteTimeWindow(t) { if (!this.isStopped) { const e = this._events; e.push(t), e.length > this._bufferSize && e.shift() } super.next(t) } nextTimeWindow(t) { this.isStopped || (this._events.push(new u(this._getNow(), t)), this._trimBufferThenGetEvents()), super.next(t) } _subscribe(t) { const e = this._infiniteTimeWindow, n = e ? this._events : this._trimBufferThenGetEvents(), r = this.scheduler, s = n.length; let c; if (this.closed) throw new a.N; if (this.isStopped || this.hasError ? c = i.w.EMPTY : (this.observers.push(t), c = new l.W(this, t)), r && t.add(t = new o.ht(t, r)), e) for (let i = 0; i < s && !t.closed; i++)t.next(n[i]); else for (let i = 0; i < s && !t.closed; i++)t.next(n[i].value); return this.hasError ? t.error(this.thrownError) : this.isStopped && t.complete(), c } _getNow() { return (this.scheduler || s.c).now() } _trimBufferThenGetEvents() { const t = this._getNow(), e = this._bufferSize, n = this._windowTime, r = this._events, s = r.length; let i = 0; for (; i < s && !(t - r[i].time < n);)i++; return s > e && (i = Math.max(i, s - e)), i > 0 && r.splice(0, i), r } } class u { constructor(t, e) { this.time = t, this.value = e } } }, 5959: (t, e, n) => { "use strict"; n.d(e, { Yc: () => c, xQ: () => u }); var r = n(8318), s = n(6673), i = n(7570), o = n(3895), a = n(9291), l = n(5331); class c extends s.L { constructor(t) { super(t), this.destination = t } } let u = (() => { class t extends r.y { constructor() { super(), this.observers = [], this.closed = !1, this.isStopped = !1, this.hasError = !1, this.thrownError = null } [l.b]() { return new c(this) } lift(t) { const e = new h(this, this); return e.operator = t, e } next(t) { if (this.closed) throw new o.N; if (!this.isStopped) { const { observers: e } = this, n = e.length, r = e.slice(); for (let s = 0; s < n; s++)r[s].next(t) } } error(t) { if (this.closed) throw new o.N; this.hasError = !0, this.thrownError = t, this.isStopped = !0; const { observers: e } = this, n = e.length, r = e.slice(); for (let s = 0; s < n; s++)r[s].error(t); this.observers.length = 0 } complete() { if (this.closed) throw new o.N; this.isStopped = !0; const { observers: t } = this, e = t.length, n = t.slice(); for (let r = 0; r < e; r++)n[r].complete(); this.observers.length = 0 } unsubscribe() { this.isStopped = !0, this.closed = !0, this.observers = null } _trySubscribe(t) { if (this.closed) throw new o.N; return super._trySubscribe(t) } _subscribe(t) { if (this.closed) throw new o.N; return this.hasError ? (t.error(this.thrownError), i.w.EMPTY) : this.isStopped ? (t.complete(), i.w.EMPTY) : (this.observers.push(t), new a.W(this, t)) } asObservable() { const t = new r.y; return t.source = this, t } } return t.create = (t, e) => new h(t, e), t })(); class h extends u { constructor(t, e) { super(), this.destination = t, this.source = e } next(t) { const { destination: e } = this; e && e.next && e.next(t) } error(t) { const { destination: e } = this; e && e.error && this.destination.error(t) } complete() { const { destination: t } = this; t && t.complete && this.destination.complete() } _subscribe(t) { const { source: e } = this; return e ? this.source.subscribe(t) : i.w.EMPTY } } }, 9291: (t, e, n) => { "use strict"; n.d(e, { W: () => s }); var r = n(7570); class s extends r.w { constructor(t, e) { super(), this.subject = t, this.subscriber = e, this.closed = !1 } unsubscribe() { if (this.closed) return; this.closed = !0; const t = this.subject, e = t.observers; if (this.subject = null, !e || 0 === e.length || t.isStopped || t.closed) return; const n = e.indexOf(this.subscriber); -1 !== n && e.splice(n, 1) } } }, 6673: (t, e, n) => { "use strict"; n.d(e, { L: () => c }); var r = n(5024), s = n(7498), i = n(7570), o = n(5331), a = n(1484), l = n(4294); class c extends i.w { constructor(t, e, n) { switch (super(), this.syncErrorValue = null, this.syncErrorThrown = !1, this.syncErrorThrowable = !1, this.isStopped = !1, arguments.length) { case 0: this.destination = s.c; break; case 1: if (!t) { this.destination = s.c; break } if ("object" == typeof t) { t instanceof c ? (this.syncErrorThrowable = t.syncErrorThrowable, this.destination = t, t.add(this)) : (this.syncErrorThrowable = !0, this.destination = new u(this, t)); break } default: this.syncErrorThrowable = !0, this.destination = new u(this, t, e, n) } } [o.b]() { return this } static create(t, e, n) { const r = new c(t, e, n); return r.syncErrorThrowable = !1, r } next(t) { this.isStopped || this._next(t) } error(t) { this.isStopped || (this.isStopped = !0, this._error(t)) } complete() { this.isStopped || (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe()) } _next(t) { this.destination.next(t) } _error(t) { this.destination.error(t), this.unsubscribe() } _complete() { this.destination.complete(), this.unsubscribe() } _unsubscribeAndRecycle() { const { _parentOrParents: t } = this; return this._parentOrParents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parentOrParents = t, this } } class u extends c { constructor(t, e, n, i) { let o; super(), this._parentSubscriber = t; let a = this; (0, r.m)(e) ? o = e : e && (o = e.next, n = e.error, i = e.complete, e !== s.c && (a = Object.create(e), (0, r.m)(a.unsubscribe) && this.add(a.unsubscribe.bind(a)), a.unsubscribe = this.unsubscribe.bind(this))), this._context = a, this._next = o, this._error = n, this._complete = i } next(t) { if (!this.isStopped && this._next) { const { _parentSubscriber: e } = this; a.v.useDeprecatedSynchronousErrorHandling && e.syncErrorThrowable ? this.__tryOrSetError(e, this._next, t) && this.unsubscribe() : this.__tryOrUnsub(this._next, t) } } error(t) { if (!this.isStopped) { const { _parentSubscriber: e } = this, { useDeprecatedSynchronousErrorHandling: n } = a.v; if (this._error) n && e.syncErrorThrowable ? (this.__tryOrSetError(e, this._error, t), this.unsubscribe()) : (this.__tryOrUnsub(this._error, t), this.unsubscribe()); else if (e.syncErrorThrowable) n ? (e.syncErrorValue = t, e.syncErrorThrown = !0) : (0, l.z)(t), this.unsubscribe(); else { if (this.unsubscribe(), n) throw t; (0, l.z)(t) } } } complete() { if (!this.isStopped) { const { _parentSubscriber: t } = this; if (this._complete) { const e = () => this._complete.call(this._context); a.v.useDeprecatedSynchronousErrorHandling && t.syncErrorThrowable ? (this.__tryOrSetError(t, e), this.unsubscribe()) : (this.__tryOrUnsub(e), this.unsubscribe()) } else this.unsubscribe() } } __tryOrUnsub(t, e) { try { t.call(this._context, e) } catch (n) { if (this.unsubscribe(), a.v.useDeprecatedSynchronousErrorHandling) throw n; (0, l.z)(n) } } __tryOrSetError(t, e, n) { if (!a.v.useDeprecatedSynchronousErrorHandling) throw new Error("bad call"); try { e.call(this._context, n) } catch (r) { return a.v.useDeprecatedSynchronousErrorHandling ? (t.syncErrorValue = r, t.syncErrorThrown = !0, !0) : ((0, l.z)(r), !0) } return !1 } _unsubscribe() { const { _parentSubscriber: t } = this; this._context = null, this._parentSubscriber = null, t.unsubscribe() } } }, 7570: (t, e, n) => { "use strict"; n.d(e, { w: () => a }); var r = n(8470), s = n(2056), i = n(5024); const o = (() => { function t(t) { return Error.call(this), this.message = t ? `${t.length} errors occurred during unsubscription:\n${t.map((t, e) => `${e + 1}) ${t.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = t, this } return t.prototype = Object.create(Error.prototype), t })(); let a = (() => { class t { constructor(t) { this.closed = !1, this._parentOrParents = null, this._subscriptions = null, t && (this._ctorUnsubscribe = !0, this._unsubscribe = t) } unsubscribe() { let e; if (this.closed) return; let { _parentOrParents: n, _ctorUnsubscribe: a, _unsubscribe: c, _subscriptions: u } = this; if (this.closed = !0, this._parentOrParents = null, this._subscriptions = null, n instanceof t) n.remove(this); else if (null !== n) for (let t = 0; t < n.length; ++t)n[t].remove(this); if ((0, i.m)(c)) { a && (this._unsubscribe = void 0); try { c.call(this) } catch (h) { e = h instanceof o ? l(h.errors) : [h] } } if ((0, r.k)(u)) { let t = -1, n = u.length; for (; ++t < n;) { const n = u[t]; if ((0, s.K)(n)) try { n.unsubscribe() } catch (h) { e = e || [], h instanceof o ? e = e.concat(l(h.errors)) : e.push(h) } } } if (e) throw new o(e) } add(e) { let n = e; if (!e) return t.EMPTY; switch (typeof e) { case "function": n = new t(e); case "object": if (n === this || n.closed || "function" != typeof n.unsubscribe) return n; if (this.closed) return n.unsubscribe(), n; if (!(n instanceof t)) { const e = n; n = new t, n._subscriptions = [e] } break; default: throw new Error("unrecognized teardown " + e + " added to Subscription.") }let { _parentOrParents: r } = n; if (null === r) n._parentOrParents = this; else if (r instanceof t) { if (r === this) return n; n._parentOrParents = [r, this] } else { if (-1 !== r.indexOf(this)) return n; r.push(this) } const s = this._subscriptions; return null === s ? this._subscriptions = [n] : s.push(n), n } remove(t) { const e = this._subscriptions; if (e) { const n = e.indexOf(t); -1 !== n && e.splice(n, 1) } } } var e; return t.EMPTY = ((e = new t).closed = !0, e), t })(); function l(t) { return t.reduce((t, e) => t.concat(e instanceof o ? e.errors : e), []) } }, 1484: (t, e, n) => { "use strict"; n.d(e, { v: () => s }); let r = !1; const s = { Promise: void 0, set useDeprecatedSynchronousErrorHandling(t) { if (t) { const t = new Error; console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + t.stack) } else r && console.log("RxJS: Back to a better error behavior. Thank you. <3"); r = t }, get useDeprecatedSynchronousErrorHandling() { return r } } }, 6882: (t, e, n) => { "use strict"; n.d(e, { IY: () => o, Ds: () => a, ft: () => l }); var r = n(6673), s = n(8318), i = n(6015); class o extends r.L { constructor(t) { super(), this.parent = t } _next(t) { this.parent.notifyNext(t) } _error(t) { this.parent.notifyError(t), this.unsubscribe() } _complete() { this.parent.notifyComplete(), this.unsubscribe() } } class a extends r.L { notifyNext(t) { this.destination.next(t) } notifyError(t) { this.destination.error(t) } notifyComplete() { this.destination.complete() } } function l(t, e) { if (e.closed) return; if (t instanceof s.y) return t.subscribe(e); let n; try { n = (0, i.s)(t)(e) } catch (r) { e.error(r) } return n } }, 2875: (t, e, n) => { "use strict"; n.d(e, { c: () => a, N: () => l }); var r = n(5959), s = n(8318), i = n(7570), o = n(1564); class a extends s.y { constructor(t, e) { super(), this.source = t, this.subjectFactory = e, this._refCount = 0, this._isComplete = !1 } _subscribe(t) { return this.getSubject().subscribe(t) } getSubject() { const t = this._subject; return t && !t.isStopped || (this._subject = this.subjectFactory()), this._subject } connect() { let t = this._connection; return t || (this._isComplete = !1, t = this._connection = new i.w, t.add(this.source.subscribe(new c(this.getSubject(), this))), t.closed && (this._connection = null, t = i.w.EMPTY)), t } refCount() { return (0, o.x)()(this) } } const l = (() => { const t = a.prototype; return { operator: { value: null }, _refCount: { value: 0, writable: !0 }, _subject: { value: null, writable: !0 }, _connection: { value: null, writable: !0 }, _subscribe: { value: t._subscribe }, _isComplete: { value: t._isComplete, writable: !0 }, getSubject: { value: t.getSubject }, connect: { value: t.connect }, refCount: { value: t.refCount } } })(); class c extends r.Yc { constructor(t, e) { super(t), this.connectable = e } _error(t) { this._unsubscribe(), super._error(t) } _complete() { this.connectable._isComplete = !0, this._unsubscribe(), super._complete() } _unsubscribe() { const t = this.connectable; if (t) { this.connectable = null; const e = t._connection; t._refCount = 0, t._subject = null, t._connection = null, e && e.unsubscribe() } } } }, 653: (t, e, n) => { "use strict"; n.d(e, { E: () => s, c: () => i }); var r = n(8318); const s = new r.y(t => t.complete()); function i(t) { return t ? function (t) { return new r.y(e => t.schedule(() => e.complete())) }(t) : s } }, 9764: (t, e, n) => { "use strict"; n.d(e, { D: () => h }); var r = n(8318), s = n(6015), i = n(7570), o = n(6197), a = n(2570), l = n(5686), c = n(5168), u = n(9653); function h(t, e) { return e ? function (t, e) { if (null != t) { if (function (t) { return t && "function" == typeof t[o.L] }(t)) return function (t, e) { return new r.y(n => { const r = new i.w; return r.add(e.schedule(() => { const s = t[o.L](); r.add(s.subscribe({ next(t) { r.add(e.schedule(() => n.next(t))) }, error(t) { r.add(e.schedule(() => n.error(t))) }, complete() { r.add(e.schedule(() => n.complete())) } })) })), r }) }(t, e); if ((0, c.t)(t)) return function (t, e) { return new r.y(n => { const r = new i.w; return r.add(e.schedule(() => t.then(t => { r.add(e.schedule(() => { n.next(t), r.add(e.schedule(() => n.complete())) })) }, t => { r.add(e.schedule(() => n.error(t))) }))), r }) }(t, e); if ((0, u.z)(t)) return (0, a.r)(t, e); if (function (t) { return t && "function" == typeof t[l.hZ] }(t) || "string" == typeof t) return function (t, e) { if (!t) throw new Error("Iterable cannot be null"); return new r.y(n => { const r = new i.w; let s; return r.add(() => { s && "function" == typeof s.return && s.return() }), r.add(e.schedule(() => { s = t[l.hZ](), r.add(e.schedule(function () { if (n.closed) return; let t, e; try { const n = s.next(); t = n.value, e = n.done } catch (r) { return void n.error(r) } e ? n.complete() : (n.next(t), this.schedule()) })) })), r }) }(t, e) } throw new TypeError((null !== t && typeof t || t) + " is not observable") }(t, e) : t instanceof r.y ? t : new r.y((0, s.s)(t)) } }, 9342: (t, e, n) => { "use strict"; n.d(e, { n: () => o }); var r = n(8318), s = n(625), i = n(2570); function o(t, e) { return e ? (0, i.r)(t, e) : new r.y((0, s.V)(t)) } }, 1906: (t, e, n) => { "use strict"; n.d(e, { T: () => a }); var r = n(8318), s = n(6163), i = n(7471), o = n(9342); function a(...t) { let e = Number.POSITIVE_INFINITY, n = null, a = t[t.length - 1]; return (0, s.K)(a) ? (n = t.pop(), t.length > 1 && "number" == typeof t[t.length - 1] && (e = t.pop())) : "number" == typeof a && (e = t.pop()), null === n && 1 === t.length && t[0] instanceof r.y ? t[0] : (0, i.J)(e)((0, o.n)(t, n)) } }, 878: (t, e, n) => { "use strict"; n.d(e, { of: () => o }); var r = n(6163), s = n(9342), i = n(2570); function o(...t) { let e = t[t.length - 1]; return (0, r.K)(e) ? (t.pop(), (0, i.r)(t, e)) : (0, s.n)(t) } }, 1225: (t, e, n) => { "use strict"; n.d(e, { _: () => s }); var r = n(8318); function s(t, e) { return new r.y(e ? n => e.schedule(i, 0, { error: t, subscriber: n }) : e => e.error(t)) } function i({ error: t, subscriber: e }) { e.error(t) } }, 7727: (t, e, n) => { "use strict"; n.d(e, { K: () => s }); var r = n(6882); function s(t) { return function (e) { const n = new i(t), r = e.lift(n); return n.caught = r } } class i { constructor(t) { this.selector = t } call(t, e) { return e.subscribe(new o(t, this.selector, this.caught)) } } class o extends r.Ds { constructor(t, e, n) { super(t), this.selector = e, this.caught = n } error(t) { if (!this.isStopped) { let n; try { n = this.selector(t, this.caught) } catch (e) { return void super.error(e) } this._unsubscribeAndRecycle(); const s = new r.IY(this); this.add(s); const i = (0, r.ft)(n, s); i !== s && this.add(i) } } } }, 436: (t, e, n) => { "use strict"; n.d(e, { b: () => s }); var r = n(3982); function s(t, e) { return (0, r.zg)(t, e, 1) } }, 7701: (t, e, n) => { "use strict"; n.d(e, { b: () => i }); var r = n(6673), s = n(8569); function i(t, e = s.P) { return n => n.lift(new o(t, e)) } class o { constructor(t, e) { this.dueTime = t, this.scheduler = e } call(t, e) { return e.subscribe(new a(t, this.dueTime, this.scheduler)) } } class a extends r.L { constructor(t, e, n) { super(t), this.dueTime = e, this.scheduler = n, this.debouncedSubscription = null, this.lastValue = null, this.hasValue = !1 } _next(t) { this.clearDebounce(), this.lastValue = t, this.hasValue = !0, this.add(this.debouncedSubscription = this.scheduler.schedule(l, this.dueTime, this)) } _complete() { this.debouncedNext(), this.destination.complete() } debouncedNext() { if (this.clearDebounce(), this.hasValue) { const { lastValue: t } = this; this.lastValue = null, this.hasValue = !1, this.destination.next(t) } } clearDebounce() { const t = this.debouncedSubscription; null !== t && (this.remove(t), t.unsubscribe(), this.debouncedSubscription = null) } } function l(t) { t.debouncedNext() } }, 3835: (t, e, n) => { "use strict"; n.d(e, { h: () => s }); var r = n(6673); function s(t, e) { return function (n) { return n.lift(new i(t, e)) } } class i { constructor(t, e) { this.predicate = t, this.thisArg = e } call(t, e) { return e.subscribe(new o(t, this.predicate, this.thisArg)) } } class o extends r.L { constructor(t, e, n) { super(t), this.predicate = e, this.thisArg = n, this.count = 0 } _next(t) { let e; try { e = this.predicate.call(this.thisArg, t, this.count++) } catch (n) { return void this.destination.error(n) } e && this.destination.next(t) } } }, 9996: (t, e, n) => { "use strict"; n.d(e, { U: () => s }); var r = n(6673); function s(t, e) { return function (n) { if ("function" != typeof t) throw new TypeError("argument is not a function. Are you looking for `mapTo()`?"); return n.lift(new i(t, e)) } } class i { constructor(t, e) { this.project = t, this.thisArg = e } call(t, e) { return e.subscribe(new o(t, this.project, this.thisArg)) } } class o extends r.L { constructor(t, e, n) { super(t), this.project = e, this.count = 0, this.thisArg = n || this } _next(t) { let e; try { e = this.project.call(this.thisArg, t, this.count++) } catch (n) { return void this.destination.error(n) } this.destination.next(e) } } }, 7471: (t, e, n) => { "use strict"; n.d(e, { J: () => i }); var r = n(3982), s = n(3392); function i(t = Number.POSITIVE_INFINITY) { return (0, r.zg)(s.y, t) } }, 3982: (t, e, n) => { "use strict"; n.d(e, { zg: () => o }); var r = n(9996), s = n(9764), i = n(6882); function o(t, e, n = Number.POSITIVE_INFINITY) { return "function" == typeof e ? i => i.pipe(o((n, i) => (0, s.D)(t(n, i)).pipe((0, r.U)((t, r) => e(n, t, i, r))), n)) : ("number" == typeof e && (n = e), e => e.lift(new a(t, n))) } class a { constructor(t, e = Number.POSITIVE_INFINITY) { this.project = t, this.concurrent = e } call(t, e) { return e.subscribe(new l(t, this.project, this.concurrent)) } } class l extends i.Ds { constructor(t, e, n = Number.POSITIVE_INFINITY) { super(t), this.project = e, this.concurrent = n, this.hasCompleted = !1, this.buffer = [], this.active = 0, this.index = 0 } _next(t) { this.active < this.concurrent ? this._tryNext(t) : this.buffer.push(t) } _tryNext(t) { let e; const n = this.index++; try { e = this.project(t, n) } catch (r) { return void this.destination.error(r) } this.active++, this._innerSub(e) } _innerSub(t) { const e = new i.IY(this), n = this.destination; n.add(e); const r = (0, i.ft)(t, e); r !== e && n.add(r) } _complete() { this.hasCompleted = !0, 0 === this.active && 0 === this.buffer.length && this.destination.complete(), this.unsubscribe() } notifyNext(t) { this.destination.next(t) } notifyComplete() { const t = this.buffer; this.active--, t.length > 0 ? this._next(t.shift()) : 0 === this.active && this.hasCompleted && this.destination.complete() } } }, 45: (t, e, n) => { "use strict"; n.d(e, { QV: () => i, ht: () => a }); var r = n(6673), s = n(3103); function i(t, e = 0) { return function (n) { return n.lift(new o(t, e)) } } class o { constructor(t, e = 0) { this.scheduler = t, this.delay = e } call(t, e) { return e.subscribe(new a(t, this.scheduler, this.delay)) } } class a extends r.L { constructor(t, e, n = 0) { super(t), this.scheduler = e, this.delay = n } static dispatch(t) { const { notification: e, destination: n } = t; e.observe(n), this.unsubscribe() } scheduleMessage(t) { this.destination.add(this.scheduler.schedule(a.dispatch, this.delay, new l(t, this.destination))) } _next(t) { this.scheduleMessage(s.P.createNext(t)) } _error(t) { this.scheduleMessage(s.P.createError(t)), this.unsubscribe() } _complete() { this.scheduleMessage(s.P.createComplete()), this.unsubscribe() } } class l { constructor(t, e) { this.notification = t, this.destination = e } } }, 3588: (t, e, n) => { "use strict"; n.d(e, { j: () => s }); var r = n(9996); function s(...t) { const e = t.length; if (0 === e) throw new Error("list of properties cannot be empty."); return n => (0, r.U)(function (t, e) { return n => { let r = n; for (let s = 0; s < e; s++) { const e = null != r ? r[t[s]] : void 0; if (void 0 === e) return; r = e } return r } }(t, e))(n) } }, 1564: (t, e, n) => { "use strict"; n.d(e, { x: () => s }); var r = n(6673); function s() { return function (t) { return t.lift(new i(t)) } } class i { constructor(t) { this.connectable = t } call(t, e) { const { connectable: n } = this; n._refCount++; const r = new o(t, n), s = e.subscribe(r); return r.closed || (r.connection = n.connect()), s } } class o extends r.L { constructor(t, e) { super(t), this.connectable = e } _unsubscribe() { const { connectable: t } = this; if (!t) return void (this.connection = null); this.connectable = null; const e = t._refCount; if (e <= 0) return void (this.connection = null); if (t._refCount = e - 1, e > 1) return void (this.connection = null); const { connection: n } = this, r = t._connection; this.connection = null, !r || n && r !== n || r.unsubscribe() } } }, 2023: (t, e, n) => { "use strict"; n.d(e, { R: () => s }); var r = n(6673); function s(t, e) { let n = !1; return arguments.length >= 2 && (n = !0), function (r) { return r.lift(new i(t, e, n)) } } class i { constructor(t, e, n = !1) { this.accumulator = t, this.seed = e, this.hasSeed = n } call(t, e) { return e.subscribe(new o(t, this.accumulator, this.seed, this.hasSeed)) } } class o extends r.L { constructor(t, e, n, r) { super(t), this.accumulator = e, this._seed = n, this.hasSeed = r, this.index = 0 } get seed() { return this._seed } set seed(t) { this.hasSeed = !0, this._seed = t } _next(t) { if (this.hasSeed) return this._tryNext(t); this.seed = t, this.destination.next(t) } _tryNext(t) { const e = this.index++; let n; try { n = this.accumulator(this.seed, t, e) } catch (r) { this.destination.error(r) } this.seed = n, this.destination.next(n) } } }, 1055: (t, e, n) => { "use strict"; n.d(e, { B: () => a }); var r = n(2875), s = n(1564), i = n(5959); function o() { return new i.xQ } function a() { return t => { return (0, s.x)()((e = o, function (t) { let n; n = "function" == typeof e ? e : function () { return e }; const s = Object.create(t, r.N); return s.source = t, s.subjectFactory = n, s })(t)); var e } } }, 4698: (t, e, n) => { "use strict"; n.d(e, { T: () => s }); var r = n(6673); function s(t) { return e => e.lift(new i(t)) } class i { constructor(t) { this.total = t } call(t, e) { return e.subscribe(new o(t, this.total)) } } class o extends r.L { constructor(t, e) { super(t), this.total = e, this.count = 0 } _next(t) { ++this.count > this.total && this.destination.next(t) } } }, 4689: (t, e, n) => { "use strict"; n.d(e, { w: () => o }); var r = n(9996), s = n(9764), i = n(6882); function o(t, e) { return "function" == typeof e ? n => n.pipe(o((n, i) => (0, s.D)(t(n, i)).pipe((0, r.U)((t, r) => e(n, t, i, r))))) : e => e.lift(new a(t)) } class a { constructor(t) { this.project = t } call(t, e) { return e.subscribe(new l(t, this.project)) } } class l extends i.Ds { constructor(t, e) { super(t), this.project = e, this.index = 0 } _next(t) { let e; const n = this.index++; try { e = this.project(t, n) } catch (r) { return void this.destination.error(r) } this._innerSub(e) } _innerSub(t) { const e = this.innerSubscription; e && e.unsubscribe(); const n = new i.IY(this), r = this.destination; r.add(n), this.innerSubscription = (0, i.ft)(t, n), this.innerSubscription !== n && r.add(this.innerSubscription) } _complete() { const { innerSubscription: t } = this; t && !t.closed || super._complete(), this.unsubscribe() } _unsubscribe() { this.innerSubscription = void 0 } notifyComplete() { this.innerSubscription = void 0, this.isStopped && super._complete() } notifyNext(t) { this.destination.next(t) } } }, 611: (t, e, n) => { "use strict"; n.d(e, { q: () => o }); var r = n(6673), s = n(8402), i = n(653); function o(t) { return e => 0 === t ? (0, i.c)() : e.lift(new a(t)) } class a { constructor(t) { if (this.total = t, this.total < 0) throw new s.W } call(t, e) { return e.subscribe(new l(t, this.total)) } } class l extends r.L { constructor(t, e) { super(t), this.total = e, this.count = 0 } _next(t) { const e = this.total, n = ++this.count; n <= e && (this.destination.next(t), n === e && (this.destination.complete(), this.unsubscribe())) } } }, 5416: (t, e, n) => { "use strict"; n.d(e, { R: () => s }); var r = n(6882); function s(t) { return e => e.lift(new i(t)) } class i { constructor(t) { this.notifier = t } call(t, e) { const n = new o(t), s = (0, r.ft)(this.notifier, new r.IY(n)); return s && !n.seenValue ? (n.add(s), e.subscribe(n)) : n } } class o extends r.Ds { constructor(t) { super(t), this.seenValue = !1 } notifyNext() { this.seenValue = !0, this.complete() } notifyComplete() { } } }, 2707: (t, e, n) => { "use strict"; n.d(e, { V: () => c }); var r = n(8569); const s = (() => { function t() { return Error.call(this), this.message = "Timeout has occurred", this.name = "TimeoutError", this } return t.prototype = Object.create(Error.prototype), t })(); var i = n(6882); class o { constructor(t, e, n, r) { this.waitFor = t, this.absoluteTimeout = e, this.withObservable = n, this.scheduler = r } call(t, e) { return e.subscribe(new a(t, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler)) } } class a extends i.Ds { constructor(t, e, n, r, s) { super(t), this.absoluteTimeout = e, this.waitFor = n, this.withObservable = r, this.scheduler = s, this.scheduleTimeout() } static dispatchTimeout(t) { const { withObservable: e } = t; t._unsubscribeAndRecycle(), t.add((0, i.ft)(e, new i.IY(t))) } scheduleTimeout() { const { action: t } = this; t ? this.action = t.schedule(this, this.waitFor) : this.add(this.action = this.scheduler.schedule(a.dispatchTimeout, this.waitFor, this)) } _next(t) { this.absoluteTimeout || this.scheduleTimeout(), super._next(t) } _unsubscribe() { this.action = void 0, this.scheduler = null, this.withObservable = null } } var l = n(1225); function c(t, e = r.P) { return function (t, e, n = r.P) { return r => { let s = (i = t) instanceof Date && !isNaN(+i); var i; let a = s ? +t - n.now() : Math.abs(t); return r.lift(new o(a, s, e, n)) } }(t, (0, l._)(new s), e) } }, 2728: (t, e, n) => { "use strict"; n.d(e, { M: () => i }); var r = n(9829), s = n(7e3); function i(...t) { return e => { let n; return "function" == typeof t[t.length - 1] && (n = t.pop()), e.lift(new o(t, n)) } } class o { constructor(t, e) { this.observables = t, this.project = e } call(t, e) { return e.subscribe(new a(t, this.observables, this.project)) } } class a extends r.L { constructor(t, e, n) { super(t), this.observables = e, this.project = n, this.toRespond = []; const r = e.length; this.values = new Array(r); for (let s = 0; s < r; s++)this.toRespond.push(s); for (let i = 0; i < r; i++)this.add((0, s.D)(this, e[i], void 0, i)) } notifyNext(t, e, n) { this.values[n] = e; const r = this.toRespond; if (r.length > 0) { const t = r.indexOf(n); -1 !== t && r.splice(t, 1) } } notifyComplete() { } _next(t) { if (0 === this.toRespond.length) { const e = [t, ...this.values]; this.project ? this._tryProject(e) : this.destination.next(e) } } _tryProject(t) { let e; try { e = this.project.apply(this, t) } catch (n) { return void this.destination.error(n) } this.destination.next(e) } } }, 2570: (t, e, n) => { "use strict"; n.d(e, { r: () => i }); var r = n(8318), s = n(7570); function i(t, e) { return new r.y(n => { const r = new s.w; let i = 0; return r.add(e.schedule(function () { i !== t.length ? (n.next(t[i++]), n.closed || r.add(this.schedule())) : n.complete() })), r }) } }, 8277: (t, e, n) => { "use strict"; n.d(e, { o: () => i }); var r = n(7570); class s extends r.w { constructor(t, e) { super() } schedule(t, e = 0) { return this } } class i extends s { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e, this.pending = !1 } schedule(t, e = 0) { if (this.closed) return this; this.state = t; const n = this.id, r = this.scheduler; return null != n && (this.id = this.recycleAsyncId(r, n, e)), this.pending = !0, this.delay = e, this.id = this.id || this.requestAsyncId(r, this.id, e), this } requestAsyncId(t, e, n = 0) { return setInterval(t.flush.bind(t, this), n) } recycleAsyncId(t, e, n = 0) { if (null !== n && this.delay === n && !1 === this.pending) return e; clearInterval(e) } execute(t, e) { if (this.closed) return new Error("executing a cancelled action"); this.pending = !1; const n = this._execute(t, e); if (n) return n; !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null)) } _execute(t, e) { let n, r = !1; try { this.work(t) } catch (s) { r = !0, n = !!s && s || new Error(s) } if (r) return this.unsubscribe(), n } _unsubscribe() { const t = this.id, e = this.scheduler, n = e.actions, r = n.indexOf(this); this.work = null, this.state = null, this.pending = !1, this.scheduler = null, -1 !== r && n.splice(r, 1), null != t && (this.id = this.recycleAsyncId(e, t, null)), this.delay = null } } }, 1098: (t, e, n) => { "use strict"; n.d(e, { v: () => s }); let r = (() => { class t { constructor(e, n = t.now) { this.SchedulerAction = e, this.now = n } schedule(t, e = 0, n) { return new this.SchedulerAction(this, t).schedule(n, e) } } return t.now = () => Date.now(), t })(); class s extends r { constructor(t, e = r.now) { super(t, () => s.delegate && s.delegate !== this ? s.delegate.now() : e()), this.actions = [], this.active = !1, this.scheduled = void 0 } schedule(t, e = 0, n) { return s.delegate && s.delegate !== this ? s.delegate.schedule(t, e, n) : super.schedule(t, e, n) } flush(t) { const { actions: e } = this; if (this.active) return void e.push(t); let n; this.active = !0; do { if (n = t.execute(t.state, t.delay)) break } while (t = e.shift()); if (this.active = !1, n) { for (; t = e.shift();)t.unsubscribe(); throw n } } } }, 8569: (t, e, n) => { "use strict"; n.d(e, { P: () => s }); var r = n(8277); const s = new (n(1098).v)(r.o) }, 8489: (t, e, n) => { "use strict"; n.d(e, { c: () => l, N: () => a }); var r = n(8277); class s extends r.o { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e } schedule(t, e = 0) { return e > 0 ? super.schedule(t, e) : (this.delay = e, this.state = t, this.scheduler.flush(this), this) } execute(t, e) { return e > 0 || this.closed ? super.execute(t, e) : this._execute(t, e) } requestAsyncId(t, e, n = 0) { return null !== n && n > 0 || null === n && this.delay > 0 ? super.requestAsyncId(t, e, n) : t.flush(this) } } var i = n(1098); class o extends i.v { } const a = new o(s), l = a }, 5686: (t, e, n) => { "use strict"; function r() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" } n.d(e, { hZ: () => s }); const s = r() }, 6197: (t, e, n) => { "use strict"; n.d(e, { L: () => r }); const r = (() => "function" == typeof Symbol && Symbol.observable || "@@observable")() }, 5331: (t, e, n) => { "use strict"; n.d(e, { b: () => r }); const r = (() => "function" == typeof Symbol ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random())() }, 8402: (t, e, n) => { "use strict"; n.d(e, { W: () => r }); const r = (() => { function t() { return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", this } return t.prototype = Object.create(Error.prototype), t })() }, 3895: (t, e, n) => { "use strict"; n.d(e, { N: () => r }); const r = (() => { function t() { return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", this } return t.prototype = Object.create(Error.prototype), t })() }, 4294: (t, e, n) => { "use strict"; function r(t) { setTimeout(() => { throw t }, 0) } n.d(e, { z: () => r }) }, 3392: (t, e, n) => { "use strict"; function r(t) { return t } n.d(e, { y: () => r }) }, 8470: (t, e, n) => { "use strict"; n.d(e, { k: () => r }); const r = (() => Array.isArray || (t => t && "number" == typeof t.length))() }, 9653: (t, e, n) => { "use strict"; n.d(e, { z: () => r }); const r = t => t && "number" == typeof t.length && "function" != typeof t }, 5024: (t, e, n) => { "use strict"; function r(t) { return "function" == typeof t } n.d(e, { m: () => r }) }, 2056: (t, e, n) => { "use strict"; function r(t) { return null !== t && "object" == typeof t } n.d(e, { K: () => r }) }, 5168: (t, e, n) => { "use strict"; function r(t) { return !!t && "function" != typeof t.subscribe && "function" == typeof t.then } n.d(e, { t: () => r }) }, 6163: (t, e, n) => { "use strict"; function r(t) { return t && "function" == typeof t.schedule } n.d(e, { K: () => r }) }, 6015: (t, e, n) => { "use strict"; n.d(e, { s: () => u }); var r = n(625), s = n(4294), i = n(5686), o = n(6197), a = n(9653), l = n(5168), c = n(2056); const u = t => { if (t && "function" == typeof t[o.L]) return u = t, t => { const e = u[o.L](); if ("function" != typeof e.subscribe) throw new TypeError("Provided object does not correctly implement Symbol.observable"); return e.subscribe(t) }; if ((0, a.z)(t)) return (0, r.V)(t); if ((0, l.t)(t)) return n = t, t => (n.then(e => { t.closed || (t.next(e), t.complete()) }, e => t.error(e)).then(null, s.z), t); if (t && "function" == typeof t[i.hZ]) return e = t, t => { const n = e[i.hZ](); for (; ;) { let e; try { e = n.next() } catch (r) { return t.error(r), t } if (e.done) { t.complete(); break } if (t.next(e.value), t.closed) break } return "function" == typeof n.return && t.add(() => { n.return && n.return() }), t }; { const e = (0, c.K)(t) ? "an invalid object" : `'${t}'`; throw new TypeError(`You provided ${e} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`) } var e, n, u } }, 625: (t, e, n) => { "use strict"; n.d(e, { V: () => r }); const r = t => e => { for (let n = 0, r = t.length; n < r && !e.closed; n++)e.next(t[n]); e.complete() } }, 7e3: (t, e, n) => { "use strict"; n.d(e, { D: () => a }); var r = n(6673); class s extends r.L { constructor(t, e, n) { super(), this.parent = t, this.outerValue = e, this.outerIndex = n, this.index = 0 } _next(t) { this.parent.notifyNext(this.outerValue, t, this.outerIndex, this.index++, this) } _error(t) { this.parent.notifyError(t, this), this.unsubscribe() } _complete() { this.parent.notifyComplete(this), this.unsubscribe() } } var i = n(6015), o = n(8318); function a(t, e, n, r, a = new s(t, n, r)) { if (!a.closed) return e instanceof o.y ? e.subscribe(a) : (0, i.s)(e)(a) } }, 5252: (t, e, n) => { "use strict"; var r = n(5366); let s = null; function i() { return s } const o = new r.OlP("DocumentToken"); let a = (() => { class t { historyGo(t) { throw new Error("Not implemented") } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = (0, r.Yz7)({ factory: l, token: t, providedIn: "platform" }), t })(); function l() { return (0, r.LFG)(u) } const c = new r.OlP("Location Initialized"); let u = (() => { class t extends a { constructor(t) { super(), this._doc = t, this._init() } _init() { this.location = window.location, this._history = window.history } getBaseHrefFromDOM() { return i().getBaseHref(this._doc) } onPopState(t) { const e = i().getGlobalEventTarget(this._doc, "window"); return e.addEventListener("popstate", t, !1), () => e.removeEventListener("popstate", t) } onHashChange(t) { const e = i().getGlobalEventTarget(this._doc, "window"); return e.addEventListener("hashchange", t, !1), () => e.removeEventListener("hashchange", t) } get href() { return this.location.href } get protocol() { return this.location.protocol } get hostname() { return this.location.hostname } get port() { return this.location.port } get pathname() { return this.location.pathname } get search() { return this.location.search } get hash() { return this.location.hash } set pathname(t) { this.location.pathname = t } pushState(t, e, n) { h() ? this._history.pushState(t, e, n) : this.location.hash = n } replaceState(t, e, n) { h() ? this._history.replaceState(t, e, n) : this.location.hash = n } forward() { this._history.forward() } back() { this._history.back() } historyGo(t = 0) { this._history.go(t) } getState() { return this._history.state } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(o)) }, t.\u0275prov = (0, r.Yz7)({ factory: d, token: t, providedIn: "platform" }), t })(); function h() { return !!window.history.pushState } function d() { return new u((0, r.LFG)(o)) } function p(t, e) { if (0 == t.length) return e; if (0 == e.length) return t; let n = 0; return t.endsWith("/") && n++, e.startsWith("/") && n++, 2 == n ? t + e.substring(1) : 1 == n ? t + e : t + "/" + e } function f(t) { const e = t.match(/#|\?|$/), n = e && e.index || t.length; return t.slice(0, n - ("/" === t[n - 1] ? 1 : 0)) + t.slice(n) } function g(t) { return t && "?" !== t[0] ? "?" + t : t } let m = (() => { class t { historyGo(t) { throw new Error("Not implemented") } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = (0, r.Yz7)({ factory: _, token: t, providedIn: "root" }), t })(); function _(t) { const e = (0, r.LFG)(o).location; return new v((0, r.LFG)(a), e && e.origin || "") } const y = new r.OlP("appBaseHref"); let v = (() => { class t extends m { constructor(t, e) { if (super(), this._platformLocation = t, this._removeListenerFns = [], null == e && (e = this._platformLocation.getBaseHrefFromDOM()), null == e) throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document."); this._baseHref = e } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(t) { this._removeListenerFns.push(this._platformLocation.onPopState(t), this._platformLocation.onHashChange(t)) } getBaseHref() { return this._baseHref } prepareExternalUrl(t) { return p(this._baseHref, t) } path(t = !1) { const e = this._platformLocation.pathname + g(this._platformLocation.search), n = this._platformLocation.hash; return n && t ? `${e}${n}` : e } pushState(t, e, n, r) { const s = this.prepareExternalUrl(n + g(r)); this._platformLocation.pushState(t, e, s) } replaceState(t, e, n, r) { const s = this.prepareExternalUrl(n + g(r)); this._platformLocation.replaceState(t, e, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } historyGo(t = 0) { var e, n; null === (n = (e = this._platformLocation).historyGo) || void 0 === n || n.call(e, t) } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(a), r.LFG(y, 8)) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(), b = (() => { class t extends m { constructor(t, e) { super(), this._platformLocation = t, this._baseHref = "", this._removeListenerFns = [], null != e && (this._baseHref = e) } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(t) { this._removeListenerFns.push(this._platformLocation.onPopState(t), this._platformLocation.onHashChange(t)) } getBaseHref() { return this._baseHref } path(t = !1) { let e = this._platformLocation.hash; return null == e && (e = "#"), e.length > 0 ? e.substring(1) : e } prepareExternalUrl(t) { const e = p(this._baseHref, t); return e.length > 0 ? "#" + e : e } pushState(t, e, n, r) { let s = this.prepareExternalUrl(n + g(r)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.pushState(t, e, s) } replaceState(t, e, n, r) { let s = this.prepareExternalUrl(n + g(r)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.replaceState(t, e, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } historyGo(t = 0) { var e, n; null === (n = (e = this._platformLocation).historyGo) || void 0 === n || n.call(e, t) } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(a), r.LFG(y, 8)) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(), w = (() => { class t { constructor(t, e) { this._subject = new r.vpe, this._urlChangeListeners = [], this._platformStrategy = t; const n = this._platformStrategy.getBaseHref(); this._platformLocation = e, this._baseHref = f(S(n)), this._platformStrategy.onPopState(t => { this._subject.emit({ url: this.path(!0), pop: !0, state: t.state, type: t.type }) }) } path(t = !1) { return this.normalize(this._platformStrategy.path(t)) } getState() { return this._platformLocation.getState() } isCurrentPathEqualTo(t, e = "") { return this.path() == this.normalize(t + g(e)) } normalize(e) { return t.stripTrailingSlash(function (t, e) { return t && e.startsWith(t) ? e.substring(t.length) : e }(this._baseHref, S(e))) } prepareExternalUrl(t) { return t && "/" !== t[0] && (t = "/" + t), this._platformStrategy.prepareExternalUrl(t) } go(t, e = "", n = null) { this._platformStrategy.pushState(n, "", t, e), this._notifyUrlChangeListeners(this.prepareExternalUrl(t + g(e)), n) } replaceState(t, e = "", n = null) { this._platformStrategy.replaceState(n, "", t, e), this._notifyUrlChangeListeners(this.prepareExternalUrl(t + g(e)), n) } forward() { this._platformStrategy.forward() } back() { this._platformStrategy.back() } historyGo(t = 0) { var e, n; null === (n = (e = this._platformStrategy).historyGo) || void 0 === n || n.call(e, t) } onUrlChange(t) { this._urlChangeListeners.push(t), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe(t => { this._notifyUrlChangeListeners(t.url, t.state) })) } _notifyUrlChangeListeners(t = "", e) { this._urlChangeListeners.forEach(n => n(t, e)) } subscribe(t, e, n) { return this._subject.subscribe({ next: t, error: e, complete: n }) } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(m), r.LFG(a)) }, t.normalizeQueryParams = g, t.joinWithSlash = p, t.stripTrailingSlash = f, t.\u0275prov = (0, r.Yz7)({ factory: E, token: t, providedIn: "root" }), t })(); function E() { return new w((0, r.LFG)(m), (0, r.LFG)(a)) } function S(t) { return t.replace(/\/index.html$/, "") } var C = function (t) { return t[t.Decimal = 0] = "Decimal", t[t.Percent = 1] = "Percent", t[t.Currency = 2] = "Currency", t[t.Scientific = 3] = "Scientific", t }({}), x = function (t) { return t[t.Zero = 0] = "Zero", t[t.One = 1] = "One", t[t.Two = 2] = "Two", t[t.Few = 3] = "Few", t[t.Many = 4] = "Many", t[t.Other = 5] = "Other", t }({}), O = function (t) { return t[t.Decimal = 0] = "Decimal", t[t.Group = 1] = "Group", t[t.List = 2] = "List", t[t.PercentSign = 3] = "PercentSign", t[t.PlusSign = 4] = "PlusSign", t[t.MinusSign = 5] = "MinusSign", t[t.Exponential = 6] = "Exponential", t[t.SuperscriptingExponent = 7] = "SuperscriptingExponent", t[t.PerMille = 8] = "PerMille", t[t[1 / 0] = 9] = "Infinity", t[t.NaN = 10] = "NaN", t[t.TimeSeparator = 11] = "TimeSeparator", t[t.CurrencyDecimal = 12] = "CurrencyDecimal", t[t.CurrencyGroup = 13] = "CurrencyGroup", t }({}); function T(t, e) { const n = (0, r.cg1)(t), s = n[r.wAp.NumberSymbols][e]; if (void 0 === s) { if (e === O.CurrencyDecimal) return n[r.wAp.NumberSymbols][O.Decimal]; if (e === O.CurrencyGroup) return n[r.wAp.NumberSymbols][O.Group] } return s } const P = r.kL8, k = /^(\d+)?\.((\d+)(-(\d+))?)?$/, A = ".", I = "0"; function R(t) { const e = parseInt(t); if (isNaN(e)) throw new Error("Invalid integer literal when parsing " + t); return e } class M { } let D = (() => { class t extends M { constructor(t) { super(), this.locale = t } getPluralCategory(t, e) { switch (P(e || this.locale)(t)) { case x.Zero: return "zero"; case x.One: return "one"; case x.Two: return "two"; case x.Few: return "few"; case x.Many: return "many"; default: return "other" } } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(r.soG)) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(); function L(t, e) { e = encodeURIComponent(e); for (const n of t.split(";")) { const t = n.indexOf("="), [r, s] = -1 == t ? [n, ""] : [n.slice(0, t), n.slice(t + 1)]; if (r.trim() === e) return decodeURIComponent(s) } return null } class N { constructor(t, e, n, r) { this.$implicit = t, this.ngForOf = e, this.index = n, this.count = r } get first() { return 0 === this.index } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 == 0 } get odd() { return !this.even } } let F = (() => { class t { constructor(t, e, n) { this._viewContainer = t, this._template = e, this._differs = n, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null } set ngForOf(t) { this._ngForOf = t, this._ngForOfDirty = !0 } set ngForTrackBy(t) { this._trackByFn = t } get ngForTrackBy() { return this._trackByFn } set ngForTemplate(t) { t && (this._template = t) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; const n = this._ngForOf; if (!this._differ && n) try { this._differ = this._differs.find(n).create(this.ngForTrackBy) } catch (e) { throw new Error(`Cannot find a differ supporting object '${n}' of type '${t = n, t.name || typeof t}'. NgFor only supports binding to Iterables such as Arrays.`) } } var t; if (this._differ) { const t = this._differ.diff(this._ngForOf); t && this._applyChanges(t) } } _applyChanges(t) { const e = []; t.forEachOperation((t, n, r) => { if (null == t.previousIndex) { const n = this._viewContainer.createEmbeddedView(this._template, new N(null, this._ngForOf, -1, -1), null === r ? void 0 : r), s = new j(t, n); e.push(s) } else if (null == r) this._viewContainer.remove(null === n ? void 0 : n); else if (null !== n) { const s = this._viewContainer.get(n); this._viewContainer.move(s, r); const i = new j(t, s); e.push(i) } }); for (let n = 0; n < e.length; n++)this._perViewChange(e[n].view, e[n].record); for (let n = 0, r = this._viewContainer.length; n < r; n++) { const t = this._viewContainer.get(n); t.context.index = n, t.context.count = r, t.context.ngForOf = this._ngForOf } t.forEachIdentityChange(t => { this._viewContainer.get(t.currentIndex).context.$implicit = t.item }) } _perViewChange(t, e) { t.context.$implicit = e.item } static ngTemplateContextGuard(t, e) { return !0 } } return t.\u0275fac = function (e) { return new (e || t)(r.Y36(r.s_b), r.Y36(r.Rgc), r.Y36(r.ZZ4)) }, t.\u0275dir = r.lG2({ type: t, selectors: [["", "ngFor", "", "ngForOf", ""]], inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" } }), t })(); class j { constructor(t, e) { this.record = t, this.view = e } } let U = (() => { class t { constructor(t, e) { this._viewContainer = t, this._context = new V, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = e } set ngIf(t) { this._context.$implicit = this._context.ngIf = t, this._updateView() } set ngIfThen(t) { B("ngIfThen", t), this._thenTemplateRef = t, this._thenViewRef = null, this._updateView() } set ngIfElse(t) { B("ngIfElse", t), this._elseTemplateRef = t, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } static ngTemplateContextGuard(t, e) { return !0 } } return t.\u0275fac = function (e) { return new (e || t)(r.Y36(r.s_b), r.Y36(r.Rgc)) }, t.\u0275dir = r.lG2({ type: t, selectors: [["", "ngIf", ""]], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" } }), t })(); class V { constructor() { this.$implicit = null, this.ngIf = null } } function B(t, e) { if (e && !e.createEmbeddedView) throw new Error(`${t} must be a TemplateRef, but received '${(0, r.AaK)(e)}'.`) } function q(t, e) { return Error(`InvalidPipeArgument: '${e}' for pipe '${(0, r.AaK)(t)}'`) } class $ { createSubscription(t, e) { return t.subscribe({ next: e, error: t => { throw t } }) } dispose(t) { t.unsubscribe() } onDestroy(t) { t.unsubscribe() } } class z { createSubscription(t, e) { return t.then(e, t => { throw t }) } dispose(t) { } onDestroy(t) { } } const H = new z, G = new $; let Z = (() => { class t { constructor(t) { this._ref = t, this._latestValue = null, this._subscription = null, this._obj = null, this._strategy = null } ngOnDestroy() { this._subscription && this._dispose() } transform(t) { return this._obj ? t !== this._obj ? (this._dispose(), this.transform(t)) : this._latestValue : (t && this._subscribe(t), this._latestValue) } _subscribe(t) { this._obj = t, this._strategy = this._selectStrategy(t), this._subscription = this._strategy.createSubscription(t, e => this._updateLatestValue(t, e)) } _selectStrategy(e) { if ((0, r.QGY)(e)) return H; if ((0, r.F4k)(e)) return G; throw q(t, e) } _dispose() { this._strategy.dispose(this._subscription), this._latestValue = null, this._subscription = null, this._obj = null } _updateLatestValue(t, e) { t === this._obj && (this._latestValue = e, this._ref.markForCheck()) } } return t.\u0275fac = function (e) { return new (e || t)(r.Y36(r.sBO, 16)) }, t.\u0275pipe = r.Yjl({ name: "async", type: t, pure: !1 }), t })(), W = (() => { class t { constructor(t) { this._locale = t } transform(e, n, s) { if (!function (t) { return !(null == t || "" === t || t != t) }(e)) return null; s = s || this._locale; try { return function (t, e, n) { return function (t, e, n, r, s, i, o = !1) { let a = "", l = !1; if (isFinite(t)) { let c = function (t) { let e, n, r, s, i, o = Math.abs(t) + "", a = 0; for ((n = o.indexOf(A)) > -1 && (o = o.replace(A, "")), (r = o.search(/e/i)) > 0 ? (n < 0 && (n = r), n += +o.slice(r + 1), o = o.substring(0, r)) : n < 0 && (n = o.length), r = 0; o.charAt(r) === I; r++); if (r === (i = o.length)) e = [0], n = 1; else { for (i--; o.charAt(i) === I;)i--; for (n -= r, e = [], s = 0; r <= i; r++, s++)e[s] = Number(o.charAt(r)) } return n > 22 && (e = e.splice(0, 21), a = n - 1, n = 1), { digits: e, exponent: a, integerLen: n } }(t); o && (c = function (t) { if (0 === t.digits[0]) return t; const e = t.digits.length - t.integerLen; return t.exponent ? t.exponent += 2 : (0 === e ? t.digits.push(0, 0) : 1 === e && t.digits.push(0), t.integerLen += 2), t }(c)); let u = e.minInt, h = e.minFrac, d = e.maxFrac; if (i) { const t = i.match(k); if (null === t) throw new Error(`${i} is not a valid digit info`); const e = t[1], n = t[3], r = t[5]; null != e && (u = R(e)), null != n && (h = R(n)), null != r ? d = R(r) : null != n && h > d && (d = h) } !function (t, e, n) { if (e > n) throw new Error(`The minimum number of digits after fraction (${e}) is higher than the maximum (${n}).`); let r = t.digits, s = r.length - t.integerLen; const i = Math.min(Math.max(e, s), n); let o = i + t.integerLen, a = r[o]; if (o > 0) { r.splice(Math.max(t.integerLen, o)); for (let t = o; t < r.length; t++)r[t] = 0 } else { s = Math.max(0, s), t.integerLen = 1, r.length = Math.max(1, o = i + 1), r[0] = 0; for (let t = 1; t < o; t++)r[t] = 0 } if (a >= 5) if (o - 1 < 0) { for (let e = 0; e > o; e--)r.unshift(0), t.integerLen++; r.unshift(1), t.integerLen++ } else r[o - 1]++; for (; s < Math.max(0, i); s++)r.push(0); let l = 0 !== i; const c = e + t.integerLen, u = r.reduceRight(function (t, e, n, r) { return r[n] = (e += t) < 10 ? e : e - 10, l && (0 === r[n] && n >= c ? r.pop() : l = !1), e >= 10 ? 1 : 0 }, 0); u && (r.unshift(u), t.integerLen++) }(c, h, d); let p = c.digits, f = c.integerLen; const g = c.exponent; let m = []; for (l = p.every(t => !t); f < u; f++)p.unshift(0); for (; f < 0; f++)p.unshift(0); f > 0 ? m = p.splice(f, p.length) : (m = p, p = [0]); const _ = []; for (p.length >= e.lgSize && _.unshift(p.splice(-e.lgSize, p.length).join("")); p.length > e.gSize;)_.unshift(p.splice(-e.gSize, p.length).join("")); p.length && _.unshift(p.join("")), a = _.join(T(n, r)), m.length && (a += T(n, s) + m.join("")), g && (a += T(n, O.Exponential) + "+" + g) } else a = T(n, O.Infinity); return a = t < 0 && !l ? e.negPre + a + e.negSuf : e.posPre + a + e.posSuf, a }(t, function (t, e = "-") { const n = { minInt: 1, minFrac: 0, maxFrac: 0, posPre: "", posSuf: "", negPre: "", negSuf: "", gSize: 0, lgSize: 0 }, r = t.split(";"), s = r[0], i = r[1], o = -1 !== s.indexOf(A) ? s.split(A) : [s.substring(0, s.lastIndexOf(I) + 1), s.substring(s.lastIndexOf(I) + 1)], a = o[0], l = o[1] || ""; n.posPre = a.substr(0, a.indexOf("#")); for (let u = 0; u < l.length; u++) { const t = l.charAt(u); t === I ? n.minFrac = n.maxFrac = u + 1 : "#" === t ? n.maxFrac = u + 1 : n.posSuf += t } const c = a.split(","); if (n.gSize = c[1] ? c[1].length : 0, n.lgSize = c[2] || c[1] ? (c[2] || c[1]).length : 0, i) { const t = s.length - n.posPre.length - n.posSuf.length, e = i.indexOf("#"); n.negPre = i.substr(0, e).replace(/'/g, ""), n.negSuf = i.substr(e + t).replace(/'/g, "") } else n.negPre = e + n.posPre, n.negSuf = n.posSuf; return n }(function (t, e) { return (0, r.cg1)(t)[r.wAp.NumberFormats][e] }(e, C.Decimal), T(e, O.MinusSign)), e, O.Group, O.Decimal, n) }(function (t) { if ("string" == typeof t && !isNaN(Number(t) - parseFloat(t))) return Number(t); if ("number" != typeof t) throw new Error(`${t} is not a number`); return t }(e), s, n) } catch (i) { throw q(t, i.message) } } } return t.\u0275fac = function (e) { return new (e || t)(r.Y36(r.soG, 16)) }, t.\u0275pipe = r.Yjl({ name: "number", type: t, pure: !0 }), t })(), K = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = r.oAB({ type: t }), t.\u0275inj = r.cJS({ providers: [{ provide: M, useClass: D }] }), t })(), Y = (() => { class t { } return t.\u0275prov = (0, r.Yz7)({ token: t, providedIn: "root", factory: () => new Q((0, r.LFG)(o), window) }), t })(); class Q { constructor(t, e) { this.document = t, this.window = e, this.offset = () => [0, 0] } setOffset(t) { this.offset = Array.isArray(t) ? () => t : t } getScrollPosition() { return this.supportsScrolling() ? [this.window.pageXOffset, this.window.pageYOffset] : [0, 0] } scrollToPosition(t) { this.supportsScrolling() && this.window.scrollTo(t[0], t[1]) } scrollToAnchor(t) { if (!this.supportsScrolling()) return; const e = function (t, e) { const n = t.getElementById(e) || t.getElementsByName(e)[0]; if (n) return n; if ("function" == typeof t.createTreeWalker && t.body && (t.body.createShadowRoot || t.body.attachShadow)) { const n = t.createTreeWalker(t.body, NodeFilter.SHOW_ELEMENT); let r = n.currentNode; for (; r;) { const t = r.shadowRoot; if (t) { const n = t.getElementById(e) || t.querySelector(`[name="${e}"]`); if (n) return n } r = n.nextNode() } } return null }(this.document, t); e && (this.scrollToElement(e), this.attemptFocus(e)) } setHistoryScrollRestoration(t) { if (this.supportScrollRestoration()) { const e = this.window.history; e && e.scrollRestoration && (e.scrollRestoration = t) } } scrollToElement(t) { const e = t.getBoundingClientRect(), n = e.left + this.window.pageXOffset, r = e.top + this.window.pageYOffset, s = this.offset(); this.window.scrollTo(n - s[0], r - s[1]) } attemptFocus(t) { return t.focus(), this.document.activeElement === t } supportScrollRestoration() { try { if (!this.supportsScrolling()) return !1; const t = J(this.window.history) || J(Object.getPrototypeOf(this.window.history)); return !(!t || !t.writable && !t.set) } catch (t) { return !1 } } supportsScrolling() { try { return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window } catch (t) { return !1 } } } function J(t) { return Object.getOwnPropertyDescriptor(t, "scrollRestoration") } class X { } class tt extends class extends class { }{ constructor() { super(...arguments), this.supportsDOMEvents = !0 } }{ static makeCurrent() { var t; t = new tt, s || (s = t) } onAndCancel(t, e, n) { return t.addEventListener(e, n, !1), () => { t.removeEventListener(e, n, !1) } } dispatchEvent(t, e) { t.dispatchEvent(e) } remove(t) { t.parentNode && t.parentNode.removeChild(t) } createElement(t, e) { return (e = e || this.getDefaultDocument()).createElement(t) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(t) { return t.nodeType === Node.ELEMENT_NODE } isShadowRoot(t) { return t instanceof DocumentFragment } getGlobalEventTarget(t, e) { return "window" === e ? window : "document" === e ? t : "body" === e ? t.body : null } getBaseHref(t) { const e = (nt = nt || document.querySelector("base"), nt ? nt.getAttribute("href") : null); return null == e ? null : function (t) { et = et || document.createElement("a"), et.setAttribute("href", t); const e = et.pathname; return "/" === e.charAt(0) ? e : `/${e}` }(e) } resetBaseElement() { nt = null } getUserAgent() { return window.navigator.userAgent } getCookie(t) { return L(document.cookie, t) } } let et, nt = null; const rt = new r.OlP("TRANSITION_ID"), st = [{ provide: r.ip1, useFactory: function (t, e, n) { return () => { n.get(r.CZH).donePromise.then(() => { const n = i(); Array.prototype.slice.apply(e.querySelectorAll("style[ng-transition]")).filter(e => e.getAttribute("ng-transition") === t).forEach(t => n.remove(t)) }) } }, deps: [rt, o, r.zs3], multi: !0 }]; class it { static init() { (0, r.VLi)(new it) } addToWindow(t) { r.dqk.getAngularTestability = (e, n = !0) => { const r = t.findTestabilityInTree(e, n); if (null == r) throw new Error("Could not find testability for element."); return r }, r.dqk.getAllAngularTestabilities = () => t.getAllTestabilities(), r.dqk.getAllAngularRootElements = () => t.getAllRootElements(), r.dqk.frameworkStabilizers || (r.dqk.frameworkStabilizers = []), r.dqk.frameworkStabilizers.push(t => { const e = r.dqk.getAllAngularTestabilities(); let n = e.length, s = !1; const i = function (e) { s = s || e, n--, 0 == n && t(s) }; e.forEach(function (t) { t.whenStable(i) }) }) } findTestabilityInTree(t, e, n) { if (null == e) return null; const r = t.getTestability(e); return null != r ? r : n ? i().isShadowRoot(e) ? this.findTestabilityInTree(t, e.host, !0) : this.findTestabilityInTree(t, e.parentElement, !0) : null } } let ot = (() => { class t { build() { return new XMLHttpRequest } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(); const at = new r.OlP("EventManagerPlugins"); let lt = (() => { class t { constructor(t, e) { this._zone = e, this._eventNameToPlugin = new Map, t.forEach(t => t.manager = this), this._plugins = t.slice().reverse() } addEventListener(t, e, n) { return this._findPluginFor(e).addEventListener(t, e, n) } addGlobalEventListener(t, e, n) { return this._findPluginFor(e).addGlobalEventListener(t, e, n) } getZone() { return this._zone } _findPluginFor(t) { const e = this._eventNameToPlugin.get(t); if (e) return e; const n = this._plugins; for (let r = 0; r < n.length; r++) { const e = n[r]; if (e.supports(t)) return this._eventNameToPlugin.set(t, e), e } throw new Error(`No event manager plugin found for event ${t}`) } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(at), r.LFG(r.R0b)) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(); class ct { constructor(t) { this._doc = t } addGlobalEventListener(t, e, n) { const r = i().getGlobalEventTarget(this._doc, t); if (!r) throw new Error(`Unsupported event target ${r} for event ${e}`); return this.addEventListener(r, e, n) } } let ut = (() => { class t { constructor() { this._stylesSet = new Set } addStyles(t) { const e = new Set; t.forEach(t => { this._stylesSet.has(t) || (this._stylesSet.add(t), e.add(t)) }), this.onStylesAdded(e) } onStylesAdded(t) { } getAllStyles() { return Array.from(this._stylesSet) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(), ht = (() => { class t extends ut { constructor(t) { super(), this._doc = t, this._hostNodes = new Map, this._hostNodes.set(t.head, []) } _addStylesToHost(t, e, n) { t.forEach(t => { const r = this._doc.createElement("style"); r.textContent = t, n.push(e.appendChild(r)) }) } addHost(t) { const e = []; this._addStylesToHost(this._stylesSet, t, e), this._hostNodes.set(t, e) } removeHost(t) { const e = this._hostNodes.get(t); e && e.forEach(dt), this._hostNodes.delete(t) } onStylesAdded(t) { this._hostNodes.forEach((e, n) => { this._addStylesToHost(t, n, e) }) } ngOnDestroy() { this._hostNodes.forEach(t => t.forEach(dt)) } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(o)) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(); function dt(t) { i().remove(t) } const pt = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" }, ft = /%COMP%/g; function gt(t, e, n) { for (let r = 0; r < e.length; r++) { let s = e[r]; Array.isArray(s) ? gt(t, s, n) : (s = s.replace(ft, t), n.push(s)) } return n } function mt(t) { return e => { if ("__ngUnwrap__" === e) return t; !1 === t(e) && (e.preventDefault(), e.returnValue = !1) } } let _t = (() => { class t { constructor(t, e, n) { this.eventManager = t, this.sharedStylesHost = e, this.appId = n, this.rendererByCompId = new Map, this.defaultRenderer = new yt(t) } createRenderer(t, e) { if (!t || !e) return this.defaultRenderer; switch (e.encapsulation) { case r.ifc.Emulated: { let n = this.rendererByCompId.get(e.id); return n || (n = new vt(this.eventManager, this.sharedStylesHost, e, this.appId), this.rendererByCompId.set(e.id, n)), n.applyToHost(t), n } case 1: case r.ifc.ShadowDom: return new bt(this.eventManager, this.sharedStylesHost, t, e); default: if (!this.rendererByCompId.has(e.id)) { const t = gt(e.id, e.styles, []); this.sharedStylesHost.addStyles(t), this.rendererByCompId.set(e.id, this.defaultRenderer) } return this.defaultRenderer } } begin() { } end() { } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(lt), r.LFG(ht), r.LFG(r.AFp)) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(); class yt { constructor(t) { this.eventManager = t, this.data = Object.create(null) } destroy() { } createElement(t, e) { return e ? document.createElementNS(pt[e] || e, t) : document.createElement(t) } createComment(t) { return document.createComment(t) } createText(t) { return document.createTextNode(t) } appendChild(t, e) { t.appendChild(e) } insertBefore(t, e, n) { t && t.insertBefore(e, n) } removeChild(t, e) { t && t.removeChild(e) } selectRootElement(t, e) { let n = "string" == typeof t ? document.querySelector(t) : t; if (!n) throw new Error(`The selector "${t}" did not match any elements`); return e || (n.textContent = ""), n } parentNode(t) { return t.parentNode } nextSibling(t) { return t.nextSibling } setAttribute(t, e, n, r) { if (r) { e = r + ":" + e; const s = pt[r]; s ? t.setAttributeNS(s, e, n) : t.setAttribute(e, n) } else t.setAttribute(e, n) } removeAttribute(t, e, n) { if (n) { const r = pt[n]; r ? t.removeAttributeNS(r, e) : t.removeAttribute(`${n}:${e}`) } else t.removeAttribute(e) } addClass(t, e) { t.classList.add(e) } removeClass(t, e) { t.classList.remove(e) } setStyle(t, e, n, s) { s & (r.JOm.DashCase | r.JOm.Important) ? t.style.setProperty(e, n, s & r.JOm.Important ? "important" : "") : t.style[e] = n } removeStyle(t, e, n) { n & r.JOm.DashCase ? t.style.removeProperty(e) : t.style[e] = "" } setProperty(t, e, n) { t[e] = n } setValue(t, e) { t.nodeValue = e } listen(t, e, n) { return "string" == typeof t ? this.eventManager.addGlobalEventListener(t, e, mt(n)) : this.eventManager.addEventListener(t, e, mt(n)) } } class vt extends yt { constructor(t, e, n, r) { super(t), this.component = n; const s = gt(r + "-" + n.id, n.styles, []); e.addStyles(s), this.contentAttr = "_ngcontent-%COMP%".replace(ft, r + "-" + n.id), this.hostAttr = "_nghost-%COMP%".replace(ft, r + "-" + n.id) } applyToHost(t) { super.setAttribute(t, this.hostAttr, "") } createElement(t, e) { const n = super.createElement(t, e); return super.setAttribute(n, this.contentAttr, ""), n } } class bt extends yt { constructor(t, e, n, r) { super(t), this.sharedStylesHost = e, this.hostEl = n, this.shadowRoot = n.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const s = gt(r.id, r.styles, []); for (let i = 0; i < s.length; i++) { const t = document.createElement("style"); t.textContent = s[i], this.shadowRoot.appendChild(t) } } nodeOrShadowRoot(t) { return t === this.hostEl ? this.shadowRoot : t } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } appendChild(t, e) { return super.appendChild(this.nodeOrShadowRoot(t), e) } insertBefore(t, e, n) { return super.insertBefore(this.nodeOrShadowRoot(t), e, n) } removeChild(t, e) { return super.removeChild(this.nodeOrShadowRoot(t), e) } parentNode(t) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t))) } } let wt = (() => { class t extends ct { constructor(t) { super(t) } supports(t) { return !0 } addEventListener(t, e, n) { return t.addEventListener(e, n, !1), () => this.removeEventListener(t, e, n) } removeEventListener(t, e, n) { return t.removeEventListener(e, n) } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(o)) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(); const Et = ["alt", "control", "meta", "shift"], St = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, Ct = { A: "1", B: "2", C: "3", D: "4", E: "5", F: "6", G: "7", H: "8", I: "9", J: "*", K: "+", M: "-", N: ".", O: "/", "`": "0", "\x90": "NumLock" }, xt = { alt: t => t.altKey, control: t => t.ctrlKey, meta: t => t.metaKey, shift: t => t.shiftKey }; let Ot = (() => { class t extends ct { constructor(t) { super(t) } supports(e) { return null != t.parseEventName(e) } addEventListener(e, n, r) { const s = t.parseEventName(n), o = t.eventCallback(s.fullKey, r, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => i().onAndCancel(e, s.domEventName, o)) } static parseEventName(e) { const n = e.toLowerCase().split("."), r = n.shift(); if (0 === n.length || "keydown" !== r && "keyup" !== r) return null; const s = t._normalizeKey(n.pop()); let i = ""; if (Et.forEach(t => { const e = n.indexOf(t); e > -1 && (n.splice(e, 1), i += t + ".") }), i += s, 0 != n.length || 0 === s.length) return null; const o = {}; return o.domEventName = r, o.fullKey = i, o } static getEventFullKey(t) { let e = "", n = function (t) { let e = t.key; if (null == e) { if (e = t.keyIdentifier, null == e) return "Unidentified"; e.startsWith("U+") && (e = String.fromCharCode(parseInt(e.substring(2), 16)), 3 === t.location && Ct.hasOwnProperty(e) && (e = Ct[e])) } return St[e] || e }(t); return n = n.toLowerCase(), " " === n ? n = "space" : "." === n && (n = "dot"), Et.forEach(r => { r != n && (0, xt[r])(t) && (e += r + ".") }), e += n, e } static eventCallback(e, n, r) { return s => { t.getEventFullKey(s) === e && r.runGuarded(() => n(s)) } } static _normalizeKey(t) { switch (t) { case "esc": return "escape"; default: return t } } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(o)) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(); const Tt = (0, r.eFA)(r._c5, "browser", [{ provide: r.Lbi, useValue: "browser" }, { provide: r.g9A, useValue: function () { tt.makeCurrent(), it.init() }, multi: !0 }, { provide: o, useFactory: function () { return (0, r.RDi)(document), document }, deps: [] }]), Pt = [[], { provide: r.zSh, useValue: "root" }, { provide: r.qLn, useFactory: function () { return new r.qLn }, deps: [] }, { provide: at, useClass: wt, multi: !0, deps: [o, r.R0b, r.Lbi] }, { provide: at, useClass: Ot, multi: !0, deps: [o] }, [], { provide: _t, useClass: _t, deps: [lt, ht, r.AFp] }, { provide: r.FYo, useExisting: _t }, { provide: ut, useExisting: ht }, { provide: ht, useClass: ht, deps: [o] }, { provide: r.dDg, useClass: r.dDg, deps: [r.R0b] }, { provide: lt, useClass: lt, deps: [at, r.R0b] }, { provide: X, useClass: ot, deps: [] }, []]; let kt = (() => { class t { constructor(t) { if (t) throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.") } static withServerTransition(e) { return { ngModule: t, providers: [{ provide: r.AFp, useValue: e.appId }, { provide: rt, useExisting: r.AFp }, st] } } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(t, 12)) }, t.\u0275mod = r.oAB({ type: t }), t.\u0275inj = r.cJS({ providers: Pt, imports: [K, r.hGG] }), t })(); "undefined" != typeof window && window; var At = n(9764), It = n(8318), Rt = n(8470), Mt = n(9996), Dt = n(2056); function Lt(t, e) { return new It.y(n => { const r = t.length; if (0 === r) return void n.complete(); const s = new Array(r); let i = 0, o = 0; for (let a = 0; a < r; a++) { const l = (0, At.D)(t[a]); let c = !1; n.add(l.subscribe({ next: t => { c || (c = !0, o++), s[a] = t }, error: t => n.error(t), complete: () => { i++, i !== r && c || (o === r && n.next(e ? e.reduce((t, e, n) => (t[e] = s[n], t), {}) : s), n.complete()) } })) } }) } let Nt = (() => { class t { constructor(t, e) { this._renderer = t, this._elementRef = e, this.onChange = t => { }, this.onTouched = () => { } } setProperty(t, e) { this._renderer.setProperty(this._elementRef.nativeElement, t, e) } registerOnTouched(t) { this.onTouched = t } registerOnChange(t) { this.onChange = t } setDisabledState(t) { this.setProperty("disabled", t) } } return t.\u0275fac = function (e) { return new (e || t)(r.Y36(r.Qsj), r.Y36(r.SBq)) }, t.\u0275dir = r.lG2({ type: t }), t })(), Ft = (() => { class t extends Nt { } return t.\u0275fac = function () { let e; return function (n) { return (e || (e = r.n5z(t)))(n || t) } }(), t.\u0275dir = r.lG2({ type: t, features: [r.qOj] }), t })(); const jt = new r.OlP("NgValueAccessor"), Ut = { provide: jt, useExisting: (0, r.Gpc)(() => Bt), multi: !0 }, Vt = new r.OlP("CompositionEventMode"); let Bt = (() => { class t extends Nt { constructor(t, e, n) { super(t, e), this._compositionMode = n, this._composing = !1, null == this._compositionMode && (this._compositionMode = !function () { const t = i() ? i().getUserAgent() : ""; return /android (\d+)/.test(t.toLowerCase()) }()) } writeValue(t) { this.setProperty("value", null == t ? "" : t) } _handleInput(t) { (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(t) } _compositionStart() { this._composing = !0 } _compositionEnd(t) { this._composing = !1, this._compositionMode && this.onChange(t) } } return t.\u0275fac = function (e) { return new (e || t)(r.Y36(r.Qsj), r.Y36(r.SBq), r.Y36(Vt, 8)) }, t.\u0275dir = r.lG2({ type: t, selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]], hostBindings: function (t, e) { 1 & t && r.NdJ("input", function (t) { return e._handleInput(t.target.value) })("blur", function () { return e.onTouched() })("compositionstart", function () { return e._compositionStart() })("compositionend", function (t) { return e._compositionEnd(t.target.value) }) }, features: [r._Bn([Ut]), r.qOj] }), t })(); const qt = new r.OlP("NgValidators"), $t = new r.OlP("NgAsyncValidators"); function zt(t) { return null != t } function Ht(t) { const e = (0, r.QGY)(t) ? (0, At.D)(t) : t; return (0, r.CqO)(e), e } function Gt(t) { let e = {}; return t.forEach(t => { e = null != t ? Object.assign(Object.assign({}, e), t) : e }), 0 === Object.keys(e).length ? null : e } function Zt(t, e) { return e.map(e => e(t)) } function Wt(t) { return t.map(t => function (t) { return !t.validate }(t) ? t : e => t.validate(e)) } function Kt(t) { return null != t ? function (t) { if (!t) return null; const e = t.filter(zt); return 0 == e.length ? null : function (t) { return Gt(Zt(t, e)) } }(Wt(t)) : null } function Yt(t) { return null != t ? function (t) { if (!t) return null; const e = t.filter(zt); return 0 == e.length ? null : function (t) { return function (...t) { if (1 === t.length) { const e = t[0]; if ((0, Rt.k)(e)) return Lt(e, null); if ((0, Dt.K)(e) && Object.getPrototypeOf(e) === Object.prototype) { const t = Object.keys(e); return Lt(t.map(t => e[t]), t) } } if ("function" == typeof t[t.length - 1]) { const e = t.pop(); return Lt(t = 1 === t.length && (0, Rt.k)(t[0]) ? t[0] : t, null).pipe((0, Mt.U)(t => e(...t))) } return Lt(t, null) }(Zt(t, e).map(Ht)).pipe((0, Mt.U)(Gt)) } }(Wt(t)) : null } function Qt(t, e) { return null === t ? [e] : Array.isArray(t) ? [...t, e] : [t, e] } let Jt = (() => { class t { constructor() { this._rawValidators = [], this._rawAsyncValidators = [], this._onDestroyCallbacks = [] } get value() { return this.control ? this.control.value : null } get valid() { return this.control ? this.control.valid : null } get invalid() { return this.control ? this.control.invalid : null } get pending() { return this.control ? this.control.pending : null } get disabled() { return this.control ? this.control.disabled : null } get enabled() { return this.control ? this.control.enabled : null } get errors() { return this.control ? this.control.errors : null } get pristine() { return this.control ? this.control.pristine : null } get dirty() { return this.control ? this.control.dirty : null } get touched() { return this.control ? this.control.touched : null } get status() { return this.control ? this.control.status : null } get untouched() { return this.control ? this.control.untouched : null } get statusChanges() { return this.control ? this.control.statusChanges : null } get valueChanges() { return this.control ? this.control.valueChanges : null } get path() { return null } _setValidators(t) { this._rawValidators = t || [], this._composedValidatorFn = Kt(this._rawValidators) } _setAsyncValidators(t) { this._rawAsyncValidators = t || [], this._composedAsyncValidatorFn = Yt(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn || null } get asyncValidator() { return this._composedAsyncValidatorFn || null } _registerOnDestroy(t) { this._onDestroyCallbacks.push(t) } _invokeOnDestroyCallbacks() { this._onDestroyCallbacks.forEach(t => t()), this._onDestroyCallbacks = [] } reset(t) { this.control && this.control.reset(t) } hasError(t, e) { return !!this.control && this.control.hasError(t, e) } getError(t, e) { return this.control ? this.control.getError(t, e) : null } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = r.lG2({ type: t }), t })(), Xt = (() => { class t extends Jt { get formDirective() { return null } get path() { return null } } return t.\u0275fac = function () { let e; return function (n) { return (e || (e = r.n5z(t)))(n || t) } }(), t.\u0275dir = r.lG2({ type: t, features: [r.qOj] }), t })(); class te extends Jt { constructor() { super(...arguments), this._parent = null, this.name = null, this.valueAccessor = null } } class ee { constructor(t) { this._cd = t } is(t) { var e, n; return !!(null === (n = null === (e = this._cd) || void 0 === e ? void 0 : e.control) || void 0 === n ? void 0 : n[t]) } } let ne = (() => { class t extends ee { constructor(t) { super(t) } } return t.\u0275fac = function (e) { return new (e || t)(r.Y36(te, 2)) }, t.\u0275dir = r.lG2({ type: t, selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]], hostVars: 14, hostBindings: function (t, e) { 2 & t && r.ekj("ng-untouched", e.is("untouched"))("ng-touched", e.is("touched"))("ng-pristine", e.is("pristine"))("ng-dirty", e.is("dirty"))("ng-valid", e.is("valid"))("ng-invalid", e.is("invalid"))("ng-pending", e.is("pending")) }, features: [r.qOj] }), t })(), re = (() => { class t extends ee { constructor(t) { super(t) } } return t.\u0275fac = function (e) { return new (e || t)(r.Y36(Xt, 10)) }, t.\u0275dir = r.lG2({ type: t, selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]], hostVars: 14, hostBindings: function (t, e) { 2 & t && r.ekj("ng-untouched", e.is("untouched"))("ng-touched", e.is("touched"))("ng-pristine", e.is("pristine"))("ng-dirty", e.is("dirty"))("ng-valid", e.is("valid"))("ng-invalid", e.is("invalid"))("ng-pending", e.is("pending")) }, features: [r.qOj] }), t })(); function se(t, e) { oe(t, e), e.valueAccessor.writeValue(t.value), function (t, e) { e.valueAccessor.registerOnChange(n => { t._pendingValue = n, t._pendingChange = !0, t._pendingDirty = !0, "change" === t.updateOn && ae(t, e) }) }(t, e), function (t, e) { const n = (t, n) => { e.valueAccessor.writeValue(t), n && e.viewToModelUpdate(t) }; t.registerOnChange(n), e._registerOnDestroy(() => { t._unregisterOnChange(n) }) }(t, e), function (t, e) { e.valueAccessor.registerOnTouched(() => { t._pendingTouched = !0, "blur" === t.updateOn && t._pendingChange && ae(t, e), "submit" !== t.updateOn && t.markAsTouched() }) }(t, e), function (t, e) { if (e.valueAccessor.setDisabledState) { const n = t => { e.valueAccessor.setDisabledState(t) }; t.registerOnDisabledChange(n), e._registerOnDestroy(() => { t._unregisterOnDisabledChange(n) }) } }(t, e) } function ie(t, e) { t.forEach(t => { t.registerOnValidatorChange && t.registerOnValidatorChange(e) }) } function oe(t, e) { const n = function (t) { return t._rawValidators }(t); null !== e.validator ? t.setValidators(Qt(n, e.validator)) : "function" == typeof n && t.setValidators([n]); const r = function (t) { return t._rawAsyncValidators }(t); null !== e.asyncValidator ? t.setAsyncValidators(Qt(r, e.asyncValidator)) : "function" == typeof r && t.setAsyncValidators([r]); const s = () => t.updateValueAndValidity(); ie(e._rawValidators, s), ie(e._rawAsyncValidators, s) } function ae(t, e) { t._pendingDirty && t.markAsDirty(), t.setValue(t._pendingValue, { emitModelToViewChange: !1 }), e.viewToModelUpdate(t._pendingValue), t._pendingChange = !1 } function le(t, e) { const n = t.indexOf(e); n > -1 && t.splice(n, 1) } const ce = "VALID", ue = "INVALID", he = "PENDING", de = "DISABLED"; function pe(t) { return (_e(t) ? t.validators : t) || null } function fe(t) { return Array.isArray(t) ? Kt(t) : t || null } function ge(t, e) { return (_e(e) ? e.asyncValidators : t) || null } function me(t) { return Array.isArray(t) ? Yt(t) : t || null } function _e(t) { return null != t && !Array.isArray(t) && "object" == typeof t } class ye { constructor(t, e) { this._hasOwnPendingAsyncValidator = !1, this._onCollectionChange = () => { }, this._parent = null, this.pristine = !0, this.touched = !1, this._onDisabledChange = [], this._rawValidators = t, this._rawAsyncValidators = e, this._composedValidatorFn = fe(this._rawValidators), this._composedAsyncValidatorFn = me(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn } set validator(t) { this._rawValidators = this._composedValidatorFn = t } get asyncValidator() { return this._composedAsyncValidatorFn } set asyncValidator(t) { this._rawAsyncValidators = this._composedAsyncValidatorFn = t } get parent() { return this._parent } get valid() { return this.status === ce } get invalid() { return this.status === ue } get pending() { return this.status == he } get disabled() { return this.status === de } get enabled() { return this.status !== de } get dirty() { return !this.pristine } get untouched() { return !this.touched } get updateOn() { return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change" } setValidators(t) { this._rawValidators = t, this._composedValidatorFn = fe(t) } setAsyncValidators(t) { this._rawAsyncValidators = t, this._composedAsyncValidatorFn = me(t) } clearValidators() { this.validator = null } clearAsyncValidators() { this.asyncValidator = null } markAsTouched(t = {}) { this.touched = !0, this._parent && !t.onlySelf && this._parent.markAsTouched(t) } markAllAsTouched() { this.markAsTouched({ onlySelf: !0 }), this._forEachChild(t => t.markAllAsTouched()) } markAsUntouched(t = {}) { this.touched = !1, this._pendingTouched = !1, this._forEachChild(t => { t.markAsUntouched({ onlySelf: !0 }) }), this._parent && !t.onlySelf && this._parent._updateTouched(t) } markAsDirty(t = {}) { this.pristine = !1, this._parent && !t.onlySelf && this._parent.markAsDirty(t) } markAsPristine(t = {}) { this.pristine = !0, this._pendingDirty = !1, this._forEachChild(t => { t.markAsPristine({ onlySelf: !0 }) }), this._parent && !t.onlySelf && this._parent._updatePristine(t) } markAsPending(t = {}) { this.status = he, !1 !== t.emitEvent && this.statusChanges.emit(this.status), this._parent && !t.onlySelf && this._parent.markAsPending(t) } disable(t = {}) { const e = this._parentMarkedDirty(t.onlySelf); this.status = de, this.errors = null, this._forEachChild(e => { e.disable(Object.assign(Object.assign({}, t), { onlySelf: !0 })) }), this._updateValue(), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors(Object.assign(Object.assign({}, t), { skipPristineCheck: e })), this._onDisabledChange.forEach(t => t(!0)) } enable(t = {}) { const e = this._parentMarkedDirty(t.onlySelf); this.status = ce, this._forEachChild(e => { e.enable(Object.assign(Object.assign({}, t), { onlySelf: !0 })) }), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }), this._updateAncestors(Object.assign(Object.assign({}, t), { skipPristineCheck: e })), this._onDisabledChange.forEach(t => t(!1)) } _updateAncestors(t) { this._parent && !t.onlySelf && (this._parent.updateValueAndValidity(t), t.skipPristineCheck || this._parent._updatePristine(), this._parent._updateTouched()) } setParent(t) { this._parent = t } updateValueAndValidity(t = {}) { this._setInitialStatus(), this._updateValue(), this.enabled && (this._cancelExistingSubscription(), this.errors = this._runValidator(), this.status = this._calculateStatus(), this.status !== ce && this.status !== he || this._runAsyncValidator(t.emitEvent)), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !t.onlySelf && this._parent.updateValueAndValidity(t) } _updateTreeValidity(t = { emitEvent: !0 }) { this._forEachChild(e => e._updateTreeValidity(t)), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }) } _setInitialStatus() { this.status = this._allControlsDisabled() ? de : ce } _runValidator() { return this.validator ? this.validator(this) : null } _runAsyncValidator(t) { if (this.asyncValidator) { this.status = he, this._hasOwnPendingAsyncValidator = !0; const e = Ht(this.asyncValidator(this)); this._asyncValidationSubscription = e.subscribe(e => { this._hasOwnPendingAsyncValidator = !1, this.setErrors(e, { emitEvent: t }) }) } } _cancelExistingSubscription() { this._asyncValidationSubscription && (this._asyncValidationSubscription.unsubscribe(), this._hasOwnPendingAsyncValidator = !1) } setErrors(t, e = {}) { this.errors = t, this._updateControlsErrors(!1 !== e.emitEvent) } get(t) { return function (t, e, n) { if (null == e) return null; if (Array.isArray(e) || (e = e.split(".")), Array.isArray(e) && 0 === e.length) return null; let r = t; return e.forEach(t => { r = r instanceof be ? r.controls.hasOwnProperty(t) ? r.controls[t] : null : r instanceof we && r.at(t) || null }), r }(this, t) } getError(t, e) { const n = e ? this.get(e) : this; return n && n.errors ? n.errors[t] : null } hasError(t, e) { return !!this.getError(t, e) } get root() { let t = this; for (; t._parent;)t = t._parent; return t } _updateControlsErrors(t) { this.status = this._calculateStatus(), t && this.statusChanges.emit(this.status), this._parent && this._parent._updateControlsErrors(t) } _initObservables() { this.valueChanges = new r.vpe, this.statusChanges = new r.vpe } _calculateStatus() { return this._allControlsDisabled() ? de : this.errors ? ue : this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(he) ? he : this._anyControlsHaveStatus(ue) ? ue : ce } _anyControlsHaveStatus(t) { return this._anyControls(e => e.status === t) } _anyControlsDirty() { return this._anyControls(t => t.dirty) } _anyControlsTouched() { return this._anyControls(t => t.touched) } _updatePristine(t = {}) { this.pristine = !this._anyControlsDirty(), this._parent && !t.onlySelf && this._parent._updatePristine(t) } _updateTouched(t = {}) { this.touched = this._anyControlsTouched(), this._parent && !t.onlySelf && this._parent._updateTouched(t) } _isBoxedValue(t) { return "object" == typeof t && null !== t && 2 === Object.keys(t).length && "value" in t && "disabled" in t } _registerOnCollectionChange(t) { this._onCollectionChange = t } _setUpdateStrategy(t) { _e(t) && null != t.updateOn && (this._updateOn = t.updateOn) } _parentMarkedDirty(t) { return !t && !(!this._parent || !this._parent.dirty) && !this._parent._anyControlsDirty() } } class ve extends ye { constructor(t = null, e, n) { super(pe(e), ge(n, e)), this._onChange = [], this._applyFormState(t), this._setUpdateStrategy(e), this._initObservables(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } setValue(t, e = {}) { this.value = this._pendingValue = t, this._onChange.length && !1 !== e.emitModelToViewChange && this._onChange.forEach(t => t(this.value, !1 !== e.emitViewToModelChange)), this.updateValueAndValidity(e) } patchValue(t, e = {}) { this.setValue(t, e) } reset(t = null, e = {}) { this._applyFormState(t), this.markAsPristine(e), this.markAsUntouched(e), this.setValue(this.value, e), this._pendingChange = !1 } _updateValue() { } _anyControls(t) { return !1 } _allControlsDisabled() { return this.disabled } registerOnChange(t) { this._onChange.push(t) } _unregisterOnChange(t) { le(this._onChange, t) } registerOnDisabledChange(t) { this._onDisabledChange.push(t) } _unregisterOnDisabledChange(t) { le(this._onDisabledChange, t) } _forEachChild(t) { } _syncPendingControls() { return !("submit" !== this.updateOn || (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), !this._pendingChange) || (this.setValue(this._pendingValue, { onlySelf: !0, emitModelToViewChange: !1 }), 0)) } _applyFormState(t) { this._isBoxedValue(t) ? (this.value = this._pendingValue = t.value, t.disabled ? this.disable({ onlySelf: !0, emitEvent: !1 }) : this.enable({ onlySelf: !0, emitEvent: !1 })) : this.value = this._pendingValue = t } } class be extends ye { constructor(t, e, n) { super(pe(e), ge(n, e)), this.controls = t, this._initObservables(), this._setUpdateStrategy(e), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } registerControl(t, e) { return this.controls[t] ? this.controls[t] : (this.controls[t] = e, e.setParent(this), e._registerOnCollectionChange(this._onCollectionChange), e) } addControl(t, e, n = {}) { this.registerControl(t, e), this.updateValueAndValidity({ emitEvent: n.emitEvent }), this._onCollectionChange() } removeControl(t, e = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), delete this.controls[t], this.updateValueAndValidity({ emitEvent: e.emitEvent }), this._onCollectionChange() } setControl(t, e, n = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), delete this.controls[t], e && this.registerControl(t, e), this.updateValueAndValidity({ emitEvent: n.emitEvent }), this._onCollectionChange() } contains(t) { return this.controls.hasOwnProperty(t) && this.controls[t].enabled } setValue(t, e = {}) { this._checkAllValuesPresent(t), Object.keys(t).forEach(n => { this._throwIfControlMissing(n), this.controls[n].setValue(t[n], { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } patchValue(t, e = {}) { null != t && (Object.keys(t).forEach(n => { this.controls[n] && this.controls[n].patchValue(t[n], { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e)) } reset(t = {}, e = {}) { this._forEachChild((n, r) => { n.reset(t[r], { onlySelf: !0, emitEvent: e.emitEvent }) }), this._updatePristine(e), this._updateTouched(e), this.updateValueAndValidity(e) } getRawValue() { return this._reduceChildren({}, (t, e, n) => (t[n] = e instanceof ve ? e.value : e.getRawValue(), t)) } _syncPendingControls() { let t = this._reduceChildren(!1, (t, e) => !!e._syncPendingControls() || t); return t && this.updateValueAndValidity({ onlySelf: !0 }), t } _throwIfControlMissing(t) { if (!Object.keys(this.controls).length) throw new Error("\n        There are no form controls registered with this group yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "); if (!this.controls[t]) throw new Error(`Cannot find form control with name: ${t}.`) } _forEachChild(t) { Object.keys(this.controls).forEach(e => { const n = this.controls[e]; n && t(n, e) }) } _setUpControls() { this._forEachChild(t => { t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange) }) } _updateValue() { this.value = this._reduceValue() } _anyControls(t) { for (const e of Object.keys(this.controls)) { const n = this.controls[e]; if (this.contains(e) && t(n)) return !0 } return !1 } _reduceValue() { return this._reduceChildren({}, (t, e, n) => ((e.enabled || this.disabled) && (t[n] = e.value), t)) } _reduceChildren(t, e) { let n = t; return this._forEachChild((t, r) => { n = e(n, t, r) }), n } _allControlsDisabled() { for (const t of Object.keys(this.controls)) if (this.controls[t].enabled) return !1; return Object.keys(this.controls).length > 0 || this.disabled } _checkAllValuesPresent(t) { this._forEachChild((e, n) => { if (void 0 === t[n]) throw new Error(`Must supply a value for form control with name: '${n}'.`) }) } } class we extends ye { constructor(t, e, n) { super(pe(e), ge(n, e)), this.controls = t, this._initObservables(), this._setUpdateStrategy(e), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } at(t) { return this.controls[t] } push(t, e = {}) { this.controls.push(t), this._registerControl(t), this.updateValueAndValidity({ emitEvent: e.emitEvent }), this._onCollectionChange() } insert(t, e, n = {}) { this.controls.splice(t, 0, e), this._registerControl(e), this.updateValueAndValidity({ emitEvent: n.emitEvent }) } removeAt(t, e = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), this.controls.splice(t, 1), this.updateValueAndValidity({ emitEvent: e.emitEvent }) } setControl(t, e, n = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), this.controls.splice(t, 1), e && (this.controls.splice(t, 0, e), this._registerControl(e)), this.updateValueAndValidity({ emitEvent: n.emitEvent }), this._onCollectionChange() } get length() { return this.controls.length } setValue(t, e = {}) { this._checkAllValuesPresent(t), t.forEach((t, n) => { this._throwIfControlMissing(n), this.at(n).setValue(t, { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } patchValue(t, e = {}) { null != t && (t.forEach((t, n) => { this.at(n) && this.at(n).patchValue(t, { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e)) } reset(t = [], e = {}) { this._forEachChild((n, r) => { n.reset(t[r], { onlySelf: !0, emitEvent: e.emitEvent }) }), this._updatePristine(e), this._updateTouched(e), this.updateValueAndValidity(e) } getRawValue() { return this.controls.map(t => t instanceof ve ? t.value : t.getRawValue()) } clear(t = {}) { this.controls.length < 1 || (this._forEachChild(t => t._registerOnCollectionChange(() => { })), this.controls.splice(0), this.updateValueAndValidity({ emitEvent: t.emitEvent })) } _syncPendingControls() { let t = this.controls.reduce((t, e) => !!e._syncPendingControls() || t, !1); return t && this.updateValueAndValidity({ onlySelf: !0 }), t } _throwIfControlMissing(t) { if (!this.controls.length) throw new Error("\n        There are no form controls registered with this array yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "); if (!this.at(t)) throw new Error(`Cannot find form control at index ${t}`) } _forEachChild(t) { this.controls.forEach((e, n) => { t(e, n) }) } _updateValue() { this.value = this.controls.filter(t => t.enabled || this.disabled).map(t => t.value) } _anyControls(t) { return this.controls.some(e => e.enabled && t(e)) } _setUpControls() { this._forEachChild(t => this._registerControl(t)) } _checkAllValuesPresent(t) { this._forEachChild((e, n) => { if (void 0 === t[n]) throw new Error(`Must supply a value for form control at index: ${n}.`) }) } _allControlsDisabled() { for (const t of this.controls) if (t.enabled) return !1; return this.controls.length > 0 || this.disabled } _registerControl(t) { t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange) } } const Ee = { provide: Xt, useExisting: (0, r.Gpc)(() => Ce) }, Se = (() => Promise.resolve(null))(); let Ce = (() => { class t extends Xt { constructor(t, e) { super(), this.submitted = !1, this._directives = [], this.ngSubmit = new r.vpe, this.form = new be({}, Kt(t), Yt(e)) } ngAfterViewInit() { this._setUpdateStrategy() } get formDirective() { return this } get control() { return this.form } get path() { return [] } get controls() { return this.form.controls } addControl(t) { Se.then(() => { const e = this._findContainer(t.path); t.control = e.registerControl(t.name, t.control), se(t.control, t), t.control.updateValueAndValidity({ emitEvent: !1 }), this._directives.push(t) }) } getControl(t) { return this.form.get(t.path) } removeControl(t) { Se.then(() => { const e = this._findContainer(t.path); e && e.removeControl(t.name), le(this._directives, t) }) } addFormGroup(t) { Se.then(() => { const e = this._findContainer(t.path), n = new be({}); (function (t, e) { oe(t, e) })(n, t), e.registerControl(t.name, n), n.updateValueAndValidity({ emitEvent: !1 }) }) } removeFormGroup(t) { Se.then(() => { const e = this._findContainer(t.path); e && e.removeControl(t.name) }) } getFormGroup(t) { return this.form.get(t.path) } updateModel(t, e) { Se.then(() => { this.form.get(t.path).setValue(e) }) } setValue(t) { this.control.setValue(t) } onSubmit(t) { return this.submitted = !0, e = this._directives, this.form._syncPendingControls(), e.forEach(t => { const e = t.control; "submit" === e.updateOn && e._pendingChange && (t.viewToModelUpdate(e._pendingValue), e._pendingChange = !1) }), this.ngSubmit.emit(t), !1; var e } onReset() { this.resetForm() } resetForm(t) { this.form.reset(t), this.submitted = !1 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.form._updateOn = this.options.updateOn) } _findContainer(t) { return t.pop(), t.length ? this.form.get(t) : this.form } } return t.\u0275fac = function (e) { return new (e || t)(r.Y36(qt, 10), r.Y36($t, 10)) }, t.\u0275dir = r.lG2({ type: t, selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]], hostBindings: function (t, e) { 1 & t && r.NdJ("submit", function (t) { return e.onSubmit(t) })("reset", function () { return e.onReset() }) }, inputs: { options: ["ngFormOptions", "options"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [r._Bn([Ee]), r.qOj] }), t })(); const xe = { provide: te, useExisting: (0, r.Gpc)(() => Te) }, Oe = (() => Promise.resolve(null))(); let Te = (() => { class t extends te { constructor(t, e, n, s) { super(), this.control = new ve, this._registered = !1, this.update = new r.vpe, this._parent = t, this._setValidators(e), this._setAsyncValidators(n), this.valueAccessor = function (t, e) { if (!e) return null; let n, r, s; return Array.isArray(e), e.forEach(t => { t.constructor === Bt ? n = t : Object.getPrototypeOf(t.constructor) === Ft ? r = t : s = t }), s || r || n || null }(0, s) } ngOnChanges(t) { this._checkForErrors(), this._registered || this._setUpControl(), "isDisabled" in t && this._updateDisabled(t), function (t, e) { if (!t.hasOwnProperty("model")) return !1; const n = t.model; return !!n.isFirstChange() || !Object.is(e, n.currentValue) }(t, this.viewModel) && (this._updateValue(this.model), this.viewModel = this.model) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } get path() { return this._parent ? [...this._parent.path, this.name] : [this.name] } get formDirective() { return this._parent ? this._parent.formDirective : null } viewToModelUpdate(t) { this.viewModel = t, this.update.emit(t) } _setUpControl() { this._setUpdateStrategy(), this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this), this._registered = !0 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.control._updateOn = this.options.updateOn) } _isStandalone() { return !this._parent || !(!this.options || !this.options.standalone) } _setUpStandalone() { se(this.control, this), this.control.updateValueAndValidity({ emitEvent: !1 }) } _checkForErrors() { this._isStandalone() || this._checkParentType(), this._checkName() } _checkParentType() { } _checkName() { this.options && this.options.name && (this.name = this.options.name), this._isStandalone() } _updateValue(t) { Oe.then(() => { this.control.setValue(t, { emitViewToModelChange: !1 }) }) } _updateDisabled(t) { const e = t.isDisabled.currentValue, n = "" === e || e && "false" !== e; Oe.then(() => { n && !this.control.disabled ? this.control.disable() : !n && this.control.disabled && this.control.enable() }) } } return t.\u0275fac = function (e) { return new (e || t)(r.Y36(Xt, 9), r.Y36(qt, 10), r.Y36($t, 10), r.Y36(jt, 10)) }, t.\u0275dir = r.lG2({ type: t, selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]], inputs: { name: "name", isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"], options: ["ngModelOptions", "options"] }, outputs: { update: "ngModelChange" }, exportAs: ["ngModel"], features: [r._Bn([xe]), r.qOj, r.TTD] }), t })(), Pe = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = r.lG2({ type: t, selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]], hostAttrs: ["novalidate", ""] }), t })(), ke = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = r.oAB({ type: t }), t.\u0275inj = r.cJS({}), t })(); const Ae = { provide: jt, useExisting: (0, r.Gpc)(() => Re), multi: !0 }; function Ie(t, e) { return null == t ? `${e}` : (e && "object" == typeof e && (e = "Object"), `${t}: ${e}`.slice(0, 50)) } let Re = (() => { class t extends Ft { constructor() { super(...arguments), this._optionMap = new Map, this._idCounter = 0, this._compareWith = Object.is } set compareWith(t) { this._compareWith = t } writeValue(t) { this.value = t; const e = this._getOptionId(t); null == e && this.setProperty("selectedIndex", -1); const n = Ie(e, t); this.setProperty("value", n) } registerOnChange(t) { this.onChange = e => { this.value = this._getOptionValue(e), t(this.value) } } _registerOption() { return (this._idCounter++).toString() } _getOptionId(t) { for (const e of Array.from(this._optionMap.keys())) if (this._compareWith(this._optionMap.get(e), t)) return e; return null } _getOptionValue(t) { const e = function (t) { return t.split(":")[0] }(t); return this._optionMap.has(e) ? this._optionMap.get(e) : t } } return t.\u0275fac = function () { let e; return function (n) { return (e || (e = r.n5z(t)))(n || t) } }(), t.\u0275dir = r.lG2({ type: t, selectors: [["select", "formControlName", "", 3, "multiple", ""], ["select", "formControl", "", 3, "multiple", ""], ["select", "ngModel", "", 3, "multiple", ""]], hostBindings: function (t, e) { 1 & t && r.NdJ("change", function (t) { return e.onChange(t.target.value) })("blur", function () { return e.onTouched() }) }, inputs: { compareWith: "compareWith" }, features: [r._Bn([Ae]), r.qOj] }), t })(), Me = (() => { class t { constructor(t, e, n) { this._element = t, this._renderer = e, this._select = n, this._select && (this.id = this._select._registerOption()) } set ngValue(t) { null != this._select && (this._select._optionMap.set(this.id, t), this._setElementValue(Ie(this.id, t)), this._select.writeValue(this._select.value)) } set value(t) { this._setElementValue(t), this._select && this._select.writeValue(this._select.value) } _setElementValue(t) { this._renderer.setProperty(this._element.nativeElement, "value", t) } ngOnDestroy() { this._select && (this._select._optionMap.delete(this.id), this._select.writeValue(this._select.value)) } } return t.\u0275fac = function (e) { return new (e || t)(r.Y36(r.SBq), r.Y36(r.Qsj), r.Y36(Re, 9)) }, t.\u0275dir = r.lG2({ type: t, selectors: [["option"]], inputs: { ngValue: "ngValue", value: "value" } }), t })(); const De = { provide: jt, useExisting: (0, r.Gpc)(() => Ne), multi: !0 }; function Le(t, e) { return null == t ? `${e}` : ("string" == typeof e && (e = `'${e}'`), e && "object" == typeof e && (e = "Object"), `${t}: ${e}`.slice(0, 50)) } let Ne = (() => { class t extends Ft { constructor() { super(...arguments), this._optionMap = new Map, this._idCounter = 0, this._compareWith = Object.is } set compareWith(t) { this._compareWith = t } writeValue(t) { let e; if (this.value = t, Array.isArray(t)) { const n = t.map(t => this._getOptionId(t)); e = (t, e) => { t._setSelected(n.indexOf(e.toString()) > -1) } } else e = (t, e) => { t._setSelected(!1) }; this._optionMap.forEach(e) } registerOnChange(t) { this.onChange = e => { const n = []; if (void 0 !== e.selectedOptions) { const t = e.selectedOptions; for (let e = 0; e < t.length; e++) { const r = t.item(e), s = this._getOptionValue(r.value); n.push(s) } } else { const t = e.options; for (let e = 0; e < t.length; e++) { const r = t.item(e); if (r.selected) { const t = this._getOptionValue(r.value); n.push(t) } } } this.value = n, t(n) } } _registerOption(t) { const e = (this._idCounter++).toString(); return this._optionMap.set(e, t), e } _getOptionId(t) { for (const e of Array.from(this._optionMap.keys())) if (this._compareWith(this._optionMap.get(e)._value, t)) return e; return null } _getOptionValue(t) { const e = function (t) { return t.split(":")[0] }(t); return this._optionMap.has(e) ? this._optionMap.get(e)._value : t } } return t.\u0275fac = function () { let e; return function (n) { return (e || (e = r.n5z(t)))(n || t) } }(), t.\u0275dir = r.lG2({ type: t, selectors: [["select", "multiple", "", "formControlName", ""], ["select", "multiple", "", "formControl", ""], ["select", "multiple", "", "ngModel", ""]], hostBindings: function (t, e) { 1 & t && r.NdJ("change", function (t) { return e.onChange(t.target) })("blur", function () { return e.onTouched() }) }, inputs: { compareWith: "compareWith" }, features: [r._Bn([De]), r.qOj] }), t })(), Fe = (() => { class t { constructor(t, e, n) { this._element = t, this._renderer = e, this._select = n, this._select && (this.id = this._select._registerOption(this)) } set ngValue(t) { null != this._select && (this._value = t, this._setElementValue(Le(this.id, t)), this._select.writeValue(this._select.value)) } set value(t) { this._select ? (this._value = t, this._setElementValue(Le(this.id, t)), this._select.writeValue(this._select.value)) : this._setElementValue(t) } _setElementValue(t) { this._renderer.setProperty(this._element.nativeElement, "value", t) } _setSelected(t) { this._renderer.setProperty(this._element.nativeElement, "selected", t) } ngOnDestroy() { this._select && (this._select._optionMap.delete(this.id), this._select.writeValue(this._select.value)) } } return t.\u0275fac = function (e) { return new (e || t)(r.Y36(r.SBq), r.Y36(r.Qsj), r.Y36(Ne, 9)) }, t.\u0275dir = r.lG2({ type: t, selectors: [["option"]], inputs: { ngValue: "ngValue", value: "value" } }), t })(), je = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = r.oAB({ type: t }), t.\u0275inj = r.cJS({ imports: [[ke]] }), t })(), Ue = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = r.oAB({ type: t }), t.\u0275inj = r.cJS({ imports: [je] }), t })(); class Ve { } const Be = "*"; function qe(t, e = null) { return { type: 2, steps: t, options: e } } function $e(t) { return { type: 6, styles: t, offset: null } } function ze(t) { Promise.resolve(null).then(t) } class He { constructor(t = 0, e = 0) { this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._started = !1, this._destroyed = !1, this._finished = !1, this._position = 0, this.parentPlayer = null, this.totalTime = t + e } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } hasStarted() { return this._started } init() { } play() { this.hasStarted() || (this._onStart(), this.triggerMicrotask()), this._started = !0 } triggerMicrotask() { ze(() => this._onFinish()) } _onStart() { this._onStartFns.forEach(t => t()), this._onStartFns = [] } pause() { } restart() { } finish() { this._onFinish() } destroy() { this._destroyed || (this._destroyed = !0, this.hasStarted() || this._onStart(), this.finish(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } reset() { this._started = !1 } setPosition(t) { this._position = this.totalTime ? t * this.totalTime : 1 } getPosition() { return this.totalTime ? this._position / this.totalTime : 1 } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } } class Ge { constructor(t) { this._onDoneFns = [], this._onStartFns = [], this._finished = !1, this._started = !1, this._destroyed = !1, this._onDestroyFns = [], this.parentPlayer = null, this.totalTime = 0, this.players = t; let e = 0, n = 0, r = 0; const s = this.players.length; 0 == s ? ze(() => this._onFinish()) : this.players.forEach(t => { t.onDone(() => { ++e == s && this._onFinish() }), t.onDestroy(() => { ++n == s && this._onDestroy() }), t.onStart(() => { ++r == s && this._onStart() }) }), this.totalTime = this.players.reduce((t, e) => Math.max(t, e.totalTime), 0) } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } init() { this.players.forEach(t => t.init()) } onStart(t) { this._onStartFns.push(t) } _onStart() { this.hasStarted() || (this._started = !0, this._onStartFns.forEach(t => t()), this._onStartFns = []) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } hasStarted() { return this._started } play() { this.parentPlayer || this.init(), this._onStart(), this.players.forEach(t => t.play()) } pause() { this.players.forEach(t => t.pause()) } restart() { this.players.forEach(t => t.restart()) } finish() { this._onFinish(), this.players.forEach(t => t.finish()) } destroy() { this._onDestroy() } _onDestroy() { this._destroyed || (this._destroyed = !0, this._onFinish(), this.players.forEach(t => t.destroy()), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } reset() { this.players.forEach(t => t.reset()), this._destroyed = !1, this._finished = !1, this._started = !1 } setPosition(t) { const e = t * this.totalTime; this.players.forEach(t => { const n = t.totalTime ? Math.min(1, e / t.totalTime) : 1; t.setPosition(n) }) } getPosition() { const t = this.players.reduce((t, e) => null === t || e.totalTime > t.totalTime ? e : t, null); return null != t ? t.getPosition() : 0 } beforeDestroy() { this.players.forEach(t => { t.beforeDestroy && t.beforeDestroy() }) } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } } function Ze() { return "undefined" != typeof window && void 0 !== window.document } function We() { return "undefined" != typeof process && "[object process]" === {}.toString.call(process) } function Ke(t) { switch (t.length) { case 0: return new He; case 1: return t[0]; default: return new Ge(t) } } function Ye(t, e, n, r, s = {}, i = {}) { const o = [], a = []; let l = -1, c = null; if (r.forEach(t => { const n = t.offset, r = n == l, u = r && c || {}; Object.keys(t).forEach(n => { let r = n, a = t[n]; if ("offset" !== n) switch (r = e.normalizePropertyName(r, o), a) { case "!": a = s[n]; break; case Be: a = i[n]; break; default: a = e.normalizeStyleValue(n, r, a, o) }u[r] = a }), r || a.push(u), c = u, l = n }), o.length) { const t = "\n - "; throw new Error(`Unable to animate due to the following errors:${t}${o.join(t)}`) } return a } function Qe(t, e, n, r) { switch (e) { case "start": t.onStart(() => r(n && Je(n, "start", t))); break; case "done": t.onDone(() => r(n && Je(n, "done", t))); break; case "destroy": t.onDestroy(() => r(n && Je(n, "destroy", t))) } } function Je(t, e, n) { const r = n.totalTime, s = Xe(t.element, t.triggerName, t.fromState, t.toState, e || t.phaseName, null == r ? t.totalTime : r, !!n.disabled), i = t._data; return null != i && (s._data = i), s } function Xe(t, e, n, r, s = "", i = 0, o) { return { element: t, triggerName: e, fromState: n, toState: r, phaseName: s, totalTime: i, disabled: !!o } } function tn(t, e, n) { let r; return t instanceof Map ? (r = t.get(e), r || t.set(e, r = n)) : (r = t[e], r || (r = t[e] = n)), r } function en(t) { const e = t.indexOf(":"); return [t.substring(1, e), t.substr(e + 1)] } let nn = (t, e) => !1, rn = (t, e) => !1, sn = (t, e, n) => []; const on = We(); (on || "undefined" != typeof Element) && (nn = Ze() ? (t, e) => { for (; e && e !== document.documentElement;) { if (e === t) return !0; e = e.parentNode || e.host } return !1 } : (t, e) => t.contains(e), rn = (() => { if (on || Element.prototype.matches) return (t, e) => t.matches(e); { const t = Element.prototype, e = t.matchesSelector || t.mozMatchesSelector || t.msMatchesSelector || t.oMatchesSelector || t.webkitMatchesSelector; return e ? (t, n) => e.apply(t, [n]) : rn } })(), sn = (t, e, n) => { let r = []; if (n) { const n = t.querySelectorAll(e); for (let t = 0; t < n.length; t++)r.push(n[t]) } else { const n = t.querySelector(e); n && r.push(n) } return r }); let an = null, ln = !1; function cn(t) { an || (an = ("undefined" != typeof document ? document.body : null) || {}, ln = !!an.style && "WebkitAppearance" in an.style); let e = !0; return an.style && !function (t) { return "ebkit" == t.substring(1, 6) }(t) && (e = t in an.style, !e && ln) && (e = "Webkit" + t.charAt(0).toUpperCase() + t.substr(1) in an.style), e } const un = rn, hn = nn, dn = sn; function pn(t) { const e = {}; return Object.keys(t).forEach(n => { const r = n.replace(/([a-z])([A-Z])/g, "$1-$2"); e[r] = t[n] }), e } let fn = (() => { class t { validateStyleProperty(t) { return cn(t) } matchesElement(t, e) { return un(t, e) } containsElement(t, e) { return hn(t, e) } query(t, e, n) { return dn(t, e, n) } computeStyle(t, e, n) { return n || "" } animate(t, e, n, r, s, i = [], o) { return new He(n, r) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(), gn = (() => { class t { } return t.NOOP = new fn, t })(); const mn = "ng-enter", _n = "ng-leave", yn = "ng-trigger", vn = ".ng-trigger", bn = "ng-animating", wn = ".ng-animating"; function En(t) { if ("number" == typeof t) return t; const e = t.match(/^(-?[\.\d]+)(m?s)/); return !e || e.length < 2 ? 0 : Sn(parseFloat(e[1]), e[2]) } function Sn(t, e) { switch (e) { case "s": return 1e3 * t; default: return t } } function Cn(t, e, n) { return t.hasOwnProperty("duration") ? t : function (t, e, n) { let r, s = 0, i = ""; if ("string" == typeof t) { const n = t.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i); if (null === n) return e.push(`The provided timing value "${t}" is invalid.`), { duration: 0, delay: 0, easing: "" }; r = Sn(parseFloat(n[1]), n[2]); const o = n[3]; null != o && (s = Sn(parseFloat(o), n[4])); const a = n[5]; a && (i = a) } else r = t; if (!n) { let n = !1, i = e.length; r < 0 && (e.push("Duration values below 0 are not allowed for this animation step."), n = !0), s < 0 && (e.push("Delay values below 0 are not allowed for this animation step."), n = !0), n && e.splice(i, 0, `The provided timing value "${t}" is invalid.`) } return { duration: r, delay: s, easing: i } }(t, e, n) } function xn(t, e = {}) { return Object.keys(t).forEach(n => { e[n] = t[n] }), e } function On(t, e, n = {}) { if (e) for (let r in t) n[r] = t[r]; else xn(t, n); return n } function Tn(t, e, n) { return n ? e + ":" + n + ";" : "" } function Pn(t) { let e = ""; for (let n = 0; n < t.style.length; n++) { const r = t.style.item(n); e += Tn(0, r, t.style.getPropertyValue(r)) } for (const n in t.style) t.style.hasOwnProperty(n) && !n.startsWith("_") && (e += Tn(0, n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), t.style[n])); t.setAttribute("style", e) } function kn(t, e, n) { t.style && (Object.keys(e).forEach(r => { const s = Fn(r); n && !n.hasOwnProperty(r) && (n[r] = t.style[s]), t.style[s] = e[r] }), We() && Pn(t)) } function An(t, e) { t.style && (Object.keys(e).forEach(e => { const n = Fn(e); t.style[n] = "" }), We() && Pn(t)) } function In(t) { return Array.isArray(t) ? 1 == t.length ? t[0] : qe(t) : t } const Rn = new RegExp("{{\\s*(.+?)\\s*}}", "g"); function Mn(t) { let e = []; if ("string" == typeof t) { let n; for (; n = Rn.exec(t);)e.push(n[1]); Rn.lastIndex = 0 } return e } function Dn(t, e, n) { const r = t.toString(), s = r.replace(Rn, (t, r) => { let s = e[r]; return e.hasOwnProperty(r) || (n.push(`Please provide a value for the animation param ${r}`), s = ""), s.toString() }); return s == r ? t : s } function Ln(t) { const e = []; let n = t.next(); for (; !n.done;)e.push(n.value), n = t.next(); return e } const Nn = /-+([a-z0-9])/g; function Fn(t) { return t.replace(Nn, (...t) => t[1].toUpperCase()) } function jn(t, e) { return 0 === t || 0 === e } function Un(t, e, n) { const r = Object.keys(n); if (r.length && e.length) { let i = e[0], o = []; if (r.forEach(t => { i.hasOwnProperty(t) || o.push(t), i[t] = n[t] }), o.length) for (var s = 1; s < e.length; s++) { let n = e[s]; o.forEach(function (e) { n[e] = Bn(t, e) }) } } return e } function Vn(t, e, n) { switch (e.type) { case 7: return t.visitTrigger(e, n); case 0: return t.visitState(e, n); case 1: return t.visitTransition(e, n); case 2: return t.visitSequence(e, n); case 3: return t.visitGroup(e, n); case 4: return t.visitAnimate(e, n); case 5: return t.visitKeyframes(e, n); case 6: return t.visitStyle(e, n); case 8: return t.visitReference(e, n); case 9: return t.visitAnimateChild(e, n); case 10: return t.visitAnimateRef(e, n); case 11: return t.visitQuery(e, n); case 12: return t.visitStagger(e, n); default: throw new Error(`Unable to resolve animation metadata node #${e.type}`) } } function Bn(t, e) { return window.getComputedStyle(t)[e] } const qn = "*"; function $n(t, e) { const n = []; return "string" == typeof t ? t.split(/\s*,\s*/).forEach(t => function (t, e, n) { if (":" == t[0]) { const r = function (t, e) { switch (t) { case ":enter": return "void => *"; case ":leave": return "* => void"; case ":increment": return (t, e) => parseFloat(e) > parseFloat(t); case ":decrement": return (t, e) => parseFloat(e) < parseFloat(t); default: return e.push(`The transition alias value "${t}" is not supported`), "* => *" } }(t, n); if ("function" == typeof r) return void e.push(r); t = r } const r = t.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/); if (null == r || r.length < 4) return n.push(`The provided transition expression "${t}" is not supported`), e; const s = r[1], i = r[2], o = r[3]; e.push(Gn(s, o)), "<" != i[0] || s == qn && o == qn || e.push(Gn(o, s)) }(t, n, e)) : n.push(t), n } const zn = new Set(["true", "1"]), Hn = new Set(["false", "0"]); function Gn(t, e) { const n = zn.has(t) || Hn.has(t), r = zn.has(e) || Hn.has(e); return (s, i) => { let o = t == qn || t == s, a = e == qn || e == i; return !o && n && "boolean" == typeof s && (o = s ? zn.has(t) : Hn.has(t)), !a && r && "boolean" == typeof i && (a = i ? zn.has(e) : Hn.has(e)), o && a } } const Zn = new RegExp("s*:selfs*,?", "g"); function Wn(t, e, n) { return new Kn(t).build(e, n) } class Kn { constructor(t) { this._driver = t } build(t, e) { const n = new Yn(e); return this._resetContextStyleTimingState(n), Vn(this, In(t), n) } _resetContextStyleTimingState(t) { t.currentQuerySelector = "", t.collectedStyles = {}, t.collectedStyles[""] = {}, t.currentTime = 0 } visitTrigger(t, e) { let n = e.queryCount = 0, r = e.depCount = 0; const s = [], i = []; return "@" == t.name.charAt(0) && e.errors.push("animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))"), t.definitions.forEach(t => { if (this._resetContextStyleTimingState(e), 0 == t.type) { const n = t, r = n.name; r.toString().split(/\s*,\s*/).forEach(t => { n.name = t, s.push(this.visitState(n, e)) }), n.name = r } else if (1 == t.type) { const s = this.visitTransition(t, e); n += s.queryCount, r += s.depCount, i.push(s) } else e.errors.push("only state() and transition() definitions can sit inside of a trigger()") }), { type: 7, name: t.name, states: s, transitions: i, queryCount: n, depCount: r, options: null } } visitState(t, e) { const n = this.visitStyle(t.styles, e), r = t.options && t.options.params || null; if (n.containsDynamicStyles) { const s = new Set, i = r || {}; if (n.styles.forEach(t => { if (Qn(t)) { const e = t; Object.keys(e).forEach(t => { Mn(e[t]).forEach(t => { i.hasOwnProperty(t) || s.add(t) }) }) } }), s.size) { const n = Ln(s.values()); e.errors.push(`state("${t.name}", ...) must define default values for all the following style substitutions: ${n.join(", ")}`) } } return { type: 0, name: t.name, style: n, options: r ? { params: r } : null } } visitTransition(t, e) { e.queryCount = 0, e.depCount = 0; const n = Vn(this, In(t.animation), e); return { type: 1, matchers: $n(t.expr, e.errors), animation: n, queryCount: e.queryCount, depCount: e.depCount, options: Jn(t.options) } } visitSequence(t, e) { return { type: 2, steps: t.steps.map(t => Vn(this, t, e)), options: Jn(t.options) } } visitGroup(t, e) { const n = e.currentTime; let r = 0; const s = t.steps.map(t => { e.currentTime = n; const s = Vn(this, t, e); return r = Math.max(r, e.currentTime), s }); return e.currentTime = r, { type: 3, steps: s, options: Jn(t.options) } } visitAnimate(t, e) { const n = function (t, e) { let n = null; if (t.hasOwnProperty("duration")) n = t; else if ("number" == typeof t) return Xn(Cn(t, e).duration, 0, ""); const r = t; if (r.split(/\s+/).some(t => "{" == t.charAt(0) && "{" == t.charAt(1))) { const t = Xn(0, 0, ""); return t.dynamic = !0, t.strValue = r, t } return n = n || Cn(r, e), Xn(n.duration, n.delay, n.easing) }(t.timings, e.errors); let r; e.currentAnimateTimings = n; let s = t.styles ? t.styles : $e({}); if (5 == s.type) r = this.visitKeyframes(s, e); else { let s = t.styles, i = !1; if (!s) { i = !0; const t = {}; n.easing && (t.easing = n.easing), s = $e(t) } e.currentTime += n.duration + n.delay; const o = this.visitStyle(s, e); o.isEmptyStep = i, r = o } return e.currentAnimateTimings = null, { type: 4, timings: n, style: r, options: null } } visitStyle(t, e) { const n = this._makeStyleAst(t, e); return this._validateStyleAst(n, e), n } _makeStyleAst(t, e) { const n = []; Array.isArray(t.styles) ? t.styles.forEach(t => { "string" == typeof t ? t == Be ? n.push(t) : e.errors.push(`The provided style string value ${t} is not allowed.`) : n.push(t) }) : n.push(t.styles); let r = !1, s = null; return n.forEach(t => { if (Qn(t)) { const e = t, n = e.easing; if (n && (s = n, delete e.easing), !r) for (let t in e) if (e[t].toString().indexOf("{{") >= 0) { r = !0; break } } }), { type: 6, styles: n, easing: s, offset: t.offset, containsDynamicStyles: r, options: null } } _validateStyleAst(t, e) { const n = e.currentAnimateTimings; let r = e.currentTime, s = e.currentTime; n && s > 0 && (s -= n.duration + n.delay), t.styles.forEach(t => { "string" != typeof t && Object.keys(t).forEach(n => { if (!this._driver.validateStyleProperty(n)) return void e.errors.push(`The provided animation property "${n}" is not a supported CSS property for animations`); const i = e.collectedStyles[e.currentQuerySelector], o = i[n]; let a = !0; o && (s != r && s >= o.startTime && r <= o.endTime && (e.errors.push(`The CSS property "${n}" that exists between the times of "${o.startTime}ms" and "${o.endTime}ms" is also being animated in a parallel animation between the times of "${s}ms" and "${r}ms"`), a = !1), s = o.startTime), a && (i[n] = { startTime: s, endTime: r }), e.options && function (t, e, n) { const r = e.params || {}, s = Mn(t); s.length && s.forEach(t => { r.hasOwnProperty(t) || n.push(`Unable to resolve the local animation param ${t} in the given list of values`) }) }(t[n], e.options, e.errors) }) }) } visitKeyframes(t, e) { const n = { type: 5, styles: [], options: null }; if (!e.currentAnimateTimings) return e.errors.push("keyframes() must be placed inside of a call to animate()"), n; let r = 0; const s = []; let i = !1, o = !1, a = 0; const l = t.steps.map(t => { const n = this._makeStyleAst(t, e); let l = null != n.offset ? n.offset : function (t) { if ("string" == typeof t) return null; let e = null; if (Array.isArray(t)) t.forEach(t => { if (Qn(t) && t.hasOwnProperty("offset")) { const n = t; e = parseFloat(n.offset), delete n.offset } }); else if (Qn(t) && t.hasOwnProperty("offset")) { const n = t; e = parseFloat(n.offset), delete n.offset } return e }(n.styles), c = 0; return null != l && (r++, c = n.offset = l), o = o || c < 0 || c > 1, i = i || c < a, a = c, s.push(c), n }); o && e.errors.push("Please ensure that all keyframe offsets are between 0 and 1"), i && e.errors.push("Please ensure that all keyframe offsets are in order"); const c = t.steps.length; let u = 0; r > 0 && r < c ? e.errors.push("Not all style() steps within the declared keyframes() contain offsets") : 0 == r && (u = 1 / (c - 1)); const h = c - 1, d = e.currentTime, p = e.currentAnimateTimings, f = p.duration; return l.forEach((t, r) => { const i = u > 0 ? r == h ? 1 : u * r : s[r], o = i * f; e.currentTime = d + p.delay + o, p.duration = o, this._validateStyleAst(t, e), t.offset = i, n.styles.push(t) }), n } visitReference(t, e) { return { type: 8, animation: Vn(this, In(t.animation), e), options: Jn(t.options) } } visitAnimateChild(t, e) { return e.depCount++, { type: 9, options: Jn(t.options) } } visitAnimateRef(t, e) { return { type: 10, animation: this.visitReference(t.animation, e), options: Jn(t.options) } } visitQuery(t, e) { const n = e.currentQuerySelector, r = t.options || {}; e.queryCount++, e.currentQuery = t; const [s, i] = function (t) { const e = !!t.split(/\s*,\s*/).find(t => ":self" == t); return e && (t = t.replace(Zn, "")), [t = t.replace(/@\*/g, vn).replace(/@\w+/g, t => ".ng-trigger-" + t.substr(1)).replace(/:animating/g, wn), e] }(t.selector); e.currentQuerySelector = n.length ? n + " " + s : s, tn(e.collectedStyles, e.currentQuerySelector, {}); const o = Vn(this, In(t.animation), e); return e.currentQuery = null, e.currentQuerySelector = n, { type: 11, selector: s, limit: r.limit || 0, optional: !!r.optional, includeSelf: i, animation: o, originalSelector: t.selector, options: Jn(t.options) } } visitStagger(t, e) { e.currentQuery || e.errors.push("stagger() can only be used inside of query()"); const n = "full" === t.timings ? { duration: 0, delay: 0, easing: "full" } : Cn(t.timings, e.errors, !0); return { type: 12, animation: Vn(this, In(t.animation), e), timings: n, options: null } } } class Yn { constructor(t) { this.errors = t, this.queryCount = 0, this.depCount = 0, this.currentTransition = null, this.currentQuery = null, this.currentQuerySelector = null, this.currentAnimateTimings = null, this.currentTime = 0, this.collectedStyles = {}, this.options = null } } function Qn(t) { return !Array.isArray(t) && "object" == typeof t } function Jn(t) { var e; return t ? (t = xn(t)).params && (t.params = (e = t.params) ? xn(e) : null) : t = {}, t } function Xn(t, e, n) { return { duration: t, delay: e, easing: n } } function tr(t, e, n, r, s, i, o = null, a = !1) { return { type: 1, element: t, keyframes: e, preStyleProps: n, postStyleProps: r, duration: s, delay: i, totalTime: s + i, easing: o, subTimeline: a } } class er { constructor() { this._map = new Map } consume(t) { let e = this._map.get(t); return e ? this._map.delete(t) : e = [], e } append(t, e) { let n = this._map.get(t); n || this._map.set(t, n = []), n.push(...e) } has(t) { return this._map.has(t) } clear() { this._map.clear() } } const nr = new RegExp(":enter", "g"), rr = new RegExp(":leave", "g"); function sr(t, e, n, r, s, i = {}, o = {}, a, l, c = []) { return (new ir).buildKeyframes(t, e, n, r, s, i, o, a, l, c) } class ir { buildKeyframes(t, e, n, r, s, i, o, a, l, c = []) { l = l || new er; const u = new ar(t, e, l, r, s, c, []); u.options = a, u.currentTimeline.setStyles([i], null, u.errors, a), Vn(this, n, u); const h = u.timelines.filter(t => t.containsAnimation()); if (h.length && Object.keys(o).length) { const t = h[h.length - 1]; t.allowOnlyTimelineStyles() || t.setStyles([o], null, u.errors, a) } return h.length ? h.map(t => t.buildKeyframes()) : [tr(e, [], [], [], 0, 0, "", !1)] } visitTrigger(t, e) { } visitState(t, e) { } visitTransition(t, e) { } visitAnimateChild(t, e) { const n = e.subInstructions.consume(e.element); if (n) { const r = e.createSubContext(t.options), s = e.currentTimeline.currentTime, i = this._visitSubInstructions(n, r, r.options); s != i && e.transformIntoNewTimeline(i) } e.previousNode = t } visitAnimateRef(t, e) { const n = e.createSubContext(t.options); n.transformIntoNewTimeline(), this.visitReference(t.animation, n), e.transformIntoNewTimeline(n.currentTimeline.currentTime), e.previousNode = t } _visitSubInstructions(t, e, n) { let r = e.currentTimeline.currentTime; const s = null != n.duration ? En(n.duration) : null, i = null != n.delay ? En(n.delay) : null; return 0 !== s && t.forEach(t => { const n = e.appendInstructionToTimeline(t, s, i); r = Math.max(r, n.duration + n.delay) }), r } visitReference(t, e) { e.updateOptions(t.options, !0), Vn(this, t.animation, e), e.previousNode = t } visitSequence(t, e) { const n = e.subContextCount; let r = e; const s = t.options; if (s && (s.params || s.delay) && (r = e.createSubContext(s), r.transformIntoNewTimeline(), null != s.delay)) { 6 == r.previousNode.type && (r.currentTimeline.snapshotCurrentStyles(), r.previousNode = or); const t = En(s.delay); r.delayNextStep(t) } t.steps.length && (t.steps.forEach(t => Vn(this, t, r)), r.currentTimeline.applyStylesToKeyframe(), r.subContextCount > n && r.transformIntoNewTimeline()), e.previousNode = t } visitGroup(t, e) { const n = []; let r = e.currentTimeline.currentTime; const s = t.options && t.options.delay ? En(t.options.delay) : 0; t.steps.forEach(i => { const o = e.createSubContext(t.options); s && o.delayNextStep(s), Vn(this, i, o), r = Math.max(r, o.currentTimeline.currentTime), n.push(o.currentTimeline) }), n.forEach(t => e.currentTimeline.mergeTimelineCollectedStyles(t)), e.transformIntoNewTimeline(r), e.previousNode = t } _visitTiming(t, e) { if (t.dynamic) { const n = t.strValue; return Cn(e.params ? Dn(n, e.params, e.errors) : n, e.errors) } return { duration: t.duration, delay: t.delay, easing: t.easing } } visitAnimate(t, e) { const n = e.currentAnimateTimings = this._visitTiming(t.timings, e), r = e.currentTimeline; n.delay && (e.incrementTime(n.delay), r.snapshotCurrentStyles()); const s = t.style; 5 == s.type ? this.visitKeyframes(s, e) : (e.incrementTime(n.duration), this.visitStyle(s, e), r.applyStylesToKeyframe()), e.currentAnimateTimings = null, e.previousNode = t } visitStyle(t, e) { const n = e.currentTimeline, r = e.currentAnimateTimings; !r && n.getCurrentStyleProperties().length && n.forwardFrame(); const s = r && r.easing || t.easing; t.isEmptyStep ? n.applyEmptyStep(s) : n.setStyles(t.styles, s, e.errors, e.options), e.previousNode = t } visitKeyframes(t, e) { const n = e.currentAnimateTimings, r = e.currentTimeline.duration, s = n.duration, i = e.createSubContext().currentTimeline; i.easing = n.easing, t.styles.forEach(t => { i.forwardTime((t.offset || 0) * s), i.setStyles(t.styles, t.easing, e.errors, e.options), i.applyStylesToKeyframe() }), e.currentTimeline.mergeTimelineCollectedStyles(i), e.transformIntoNewTimeline(r + s), e.previousNode = t } visitQuery(t, e) { const n = e.currentTimeline.currentTime, r = t.options || {}, s = r.delay ? En(r.delay) : 0; s && (6 === e.previousNode.type || 0 == n && e.currentTimeline.getCurrentStyleProperties().length) && (e.currentTimeline.snapshotCurrentStyles(), e.previousNode = or); let i = n; const o = e.invokeQuery(t.selector, t.originalSelector, t.limit, t.includeSelf, !!r.optional, e.errors); e.currentQueryTotal = o.length; let a = null; o.forEach((n, r) => { e.currentQueryIndex = r; const o = e.createSubContext(t.options, n); s && o.delayNextStep(s), n === e.element && (a = o.currentTimeline), Vn(this, t.animation, o), o.currentTimeline.applyStylesToKeyframe(), i = Math.max(i, o.currentTimeline.currentTime) }), e.currentQueryIndex = 0, e.currentQueryTotal = 0, e.transformIntoNewTimeline(i), a && (e.currentTimeline.mergeTimelineCollectedStyles(a), e.currentTimeline.snapshotCurrentStyles()), e.previousNode = t } visitStagger(t, e) { const n = e.parentContext, r = e.currentTimeline, s = t.timings, i = Math.abs(s.duration), o = i * (e.currentQueryTotal - 1); let a = i * e.currentQueryIndex; switch (s.duration < 0 ? "reverse" : s.easing) { case "reverse": a = o - a; break; case "full": a = n.currentStaggerTime }const l = e.currentTimeline; a && l.delayNextStep(a); const c = l.currentTime; Vn(this, t.animation, e), e.previousNode = t, n.currentStaggerTime = r.currentTime - c + (r.startTime - n.currentTimeline.startTime) } } const or = {}; class ar { constructor(t, e, n, r, s, i, o, a) { this._driver = t, this.element = e, this.subInstructions = n, this._enterClassName = r, this._leaveClassName = s, this.errors = i, this.timelines = o, this.parentContext = null, this.currentAnimateTimings = null, this.previousNode = or, this.subContextCount = 0, this.options = {}, this.currentQueryIndex = 0, this.currentQueryTotal = 0, this.currentStaggerTime = 0, this.currentTimeline = a || new lr(this._driver, e, 0), o.push(this.currentTimeline) } get params() { return this.options.params } updateOptions(t, e) { if (!t) return; const n = t; let r = this.options; null != n.duration && (r.duration = En(n.duration)), null != n.delay && (r.delay = En(n.delay)); const s = n.params; if (s) { let t = r.params; t || (t = this.options.params = {}), Object.keys(s).forEach(n => { e && t.hasOwnProperty(n) || (t[n] = Dn(s[n], t, this.errors)) }) } } _copyOptions() { const t = {}; if (this.options) { const e = this.options.params; if (e) { const n = t.params = {}; Object.keys(e).forEach(t => { n[t] = e[t] }) } } return t } createSubContext(t = null, e, n) { const r = e || this.element, s = new ar(this._driver, r, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(r, n || 0)); return s.previousNode = this.previousNode, s.currentAnimateTimings = this.currentAnimateTimings, s.options = this._copyOptions(), s.updateOptions(t), s.currentQueryIndex = this.currentQueryIndex, s.currentQueryTotal = this.currentQueryTotal, s.parentContext = this, this.subContextCount++, s } transformIntoNewTimeline(t) { return this.previousNode = or, this.currentTimeline = this.currentTimeline.fork(this.element, t), this.timelines.push(this.currentTimeline), this.currentTimeline } appendInstructionToTimeline(t, e, n) { const r = { duration: null != e ? e : t.duration, delay: this.currentTimeline.currentTime + (null != n ? n : 0) + t.delay, easing: "" }, s = new cr(this._driver, t.element, t.keyframes, t.preStyleProps, t.postStyleProps, r, t.stretchStartingKeyframe); return this.timelines.push(s), r } incrementTime(t) { this.currentTimeline.forwardTime(this.currentTimeline.duration + t) } delayNextStep(t) { t > 0 && this.currentTimeline.delayNextStep(t) } invokeQuery(t, e, n, r, s, i) { let o = []; if (r && o.push(this.element), t.length > 0) { t = (t = t.replace(nr, "." + this._enterClassName)).replace(rr, "." + this._leaveClassName); let e = this._driver.query(this.element, t, 1 != n); 0 !== n && (e = n < 0 ? e.slice(e.length + n, e.length) : e.slice(0, n)), o.push(...e) } return s || 0 != o.length || i.push(`\`query("${e}")\` returned zero elements. (Use \`query("${e}", { optional: true })\` if you wish to allow this.)`), o } } class lr { constructor(t, e, n, r) { this._driver = t, this.element = e, this.startTime = n, this._elementTimelineStylesLookup = r, this.duration = 0, this._previousKeyframe = {}, this._currentKeyframe = {}, this._keyframes = new Map, this._styleSummary = {}, this._pendingStyles = {}, this._backFill = {}, this._currentEmptyStepKeyframe = null, this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = new Map), this._localTimelineStyles = Object.create(this._backFill, {}), this._globalTimelineStyles = this._elementTimelineStylesLookup.get(e), this._globalTimelineStyles || (this._globalTimelineStyles = this._localTimelineStyles, this._elementTimelineStylesLookup.set(e, this._localTimelineStyles)), this._loadKeyframe() } containsAnimation() { switch (this._keyframes.size) { case 0: return !1; case 1: return this.getCurrentStyleProperties().length > 0; default: return !0 } } getCurrentStyleProperties() { return Object.keys(this._currentKeyframe) } get currentTime() { return this.startTime + this.duration } delayNextStep(t) { const e = 1 == this._keyframes.size && Object.keys(this._pendingStyles).length; this.duration || e ? (this.forwardTime(this.currentTime + t), e && this.snapshotCurrentStyles()) : this.startTime += t } fork(t, e) { return this.applyStylesToKeyframe(), new lr(this._driver, t, e || this.currentTime, this._elementTimelineStylesLookup) } _loadKeyframe() { this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe), this._currentKeyframe = this._keyframes.get(this.duration), this._currentKeyframe || (this._currentKeyframe = Object.create(this._backFill, {}), this._keyframes.set(this.duration, this._currentKeyframe)) } forwardFrame() { this.duration += 1, this._loadKeyframe() } forwardTime(t) { this.applyStylesToKeyframe(), this.duration = t, this._loadKeyframe() } _updateStyle(t, e) { this._localTimelineStyles[t] = e, this._globalTimelineStyles[t] = e, this._styleSummary[t] = { time: this.currentTime, value: e } } allowOnlyTimelineStyles() { return this._currentEmptyStepKeyframe !== this._currentKeyframe } applyEmptyStep(t) { t && (this._previousKeyframe.easing = t), Object.keys(this._globalTimelineStyles).forEach(t => { this._backFill[t] = this._globalTimelineStyles[t] || Be, this._currentKeyframe[t] = Be }), this._currentEmptyStepKeyframe = this._currentKeyframe } setStyles(t, e, n, r) { e && (this._previousKeyframe.easing = e); const s = r && r.params || {}, i = function (t, e) { const n = {}; let r; return t.forEach(t => { "*" === t ? (r = r || Object.keys(e), r.forEach(t => { n[t] = Be })) : On(t, !1, n) }), n }(t, this._globalTimelineStyles); Object.keys(i).forEach(t => { const e = Dn(i[t], s, n); this._pendingStyles[t] = e, this._localTimelineStyles.hasOwnProperty(t) || (this._backFill[t] = this._globalTimelineStyles.hasOwnProperty(t) ? this._globalTimelineStyles[t] : Be), this._updateStyle(t, e) }) } applyStylesToKeyframe() { const t = this._pendingStyles, e = Object.keys(t); 0 != e.length && (this._pendingStyles = {}, e.forEach(e => { this._currentKeyframe[e] = t[e] }), Object.keys(this._localTimelineStyles).forEach(t => { this._currentKeyframe.hasOwnProperty(t) || (this._currentKeyframe[t] = this._localTimelineStyles[t]) })) } snapshotCurrentStyles() { Object.keys(this._localTimelineStyles).forEach(t => { const e = this._localTimelineStyles[t]; this._pendingStyles[t] = e, this._updateStyle(t, e) }) } getFinalKeyframe() { return this._keyframes.get(this.duration) } get properties() { const t = []; for (let e in this._currentKeyframe) t.push(e); return t } mergeTimelineCollectedStyles(t) { Object.keys(t._styleSummary).forEach(e => { const n = this._styleSummary[e], r = t._styleSummary[e]; (!n || r.time > n.time) && this._updateStyle(e, r.value) }) } buildKeyframes() { this.applyStylesToKeyframe(); const t = new Set, e = new Set, n = 1 === this._keyframes.size && 0 === this.duration; let r = []; this._keyframes.forEach((s, i) => { const o = On(s, !0); Object.keys(o).forEach(n => { const r = o[n]; "!" == r ? t.add(n) : r == Be && e.add(n) }), n || (o.offset = i / this.duration), r.push(o) }); const s = t.size ? Ln(t.values()) : [], i = e.size ? Ln(e.values()) : []; if (n) { const t = r[0], e = xn(t); t.offset = 0, e.offset = 1, r = [t, e] } return tr(this.element, r, s, i, this.duration, this.startTime, this.easing, !1) } } class cr extends lr { constructor(t, e, n, r, s, i, o = !1) { super(t, e, i.delay), this.element = e, this.keyframes = n, this.preStyleProps = r, this.postStyleProps = s, this._stretchStartingKeyframe = o, this.timings = { duration: i.duration, delay: i.delay, easing: i.easing } } containsAnimation() { return this.keyframes.length > 1 } buildKeyframes() { let t = this.keyframes, { delay: e, duration: n, easing: r } = this.timings; if (this._stretchStartingKeyframe && e) { const s = [], i = n + e, o = e / i, a = On(t[0], !1); a.offset = 0, s.push(a); const l = On(t[0], !1); l.offset = ur(o), s.push(l); const c = t.length - 1; for (let r = 1; r <= c; r++) { let o = On(t[r], !1); o.offset = ur((e + o.offset * n) / i), s.push(o) } n = i, e = 0, r = "", t = s } return tr(this.element, t, this.preStyleProps, this.postStyleProps, n, e, r, !0) } } function ur(t, e = 3) { const n = Math.pow(10, e - 1); return Math.round(t * n) / n } class hr { } class dr extends hr { normalizePropertyName(t, e) { return Fn(t) } normalizeStyleValue(t, e, n, r) { let s = ""; const i = n.toString().trim(); if (pr[e] && 0 !== n && "0" !== n) if ("number" == typeof n) s = "px"; else { const e = n.match(/^[+-]?[\d\.]+([a-z]*)$/); e && 0 == e[1].length && r.push(`Please provide a CSS unit value for ${t}:${n}`) } return i + s } } const pr = (() => function (t) { const e = {}; return t.forEach(t => e[t] = !0), e }("width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective".split(",")))(); function fr(t, e, n, r, s, i, o, a, l, c, u, h, d) { return { type: 0, element: t, triggerName: e, isRemovalTransition: s, fromState: n, fromStyles: i, toState: r, toStyles: o, timelines: a, queriedElements: l, preStyleProps: c, postStyleProps: u, totalTime: h, errors: d } } const gr = {}; class mr { constructor(t, e, n) { this._triggerName = t, this.ast = e, this._stateStyles = n } match(t, e, n, r) { return function (t, e, n, r, s) { return t.some(t => t(e, n, r, s)) }(this.ast.matchers, t, e, n, r) } buildStyles(t, e, n) { const r = this._stateStyles["*"], s = this._stateStyles[t], i = r ? r.buildStyles(e, n) : {}; return s ? s.buildStyles(e, n) : i } build(t, e, n, r, s, i, o, a, l, c) { const u = [], h = this.ast.options && this.ast.options.params || gr, d = this.buildStyles(n, o && o.params || gr, u), p = a && a.params || gr, f = this.buildStyles(r, p, u), g = new Set, m = new Map, _ = new Map, y = "void" === r, v = { params: Object.assign(Object.assign({}, h), p) }, b = c ? [] : sr(t, e, this.ast.animation, s, i, d, f, v, l, u); let w = 0; if (b.forEach(t => { w = Math.max(t.duration + t.delay, w) }), u.length) return fr(e, this._triggerName, n, r, y, d, f, [], [], m, _, w, u); b.forEach(t => { const n = t.element, r = tn(m, n, {}); t.preStyleProps.forEach(t => r[t] = !0); const s = tn(_, n, {}); t.postStyleProps.forEach(t => s[t] = !0), n !== e && g.add(n) }); const E = Ln(g.values()); return fr(e, this._triggerName, n, r, y, d, f, b, E, m, _, w) } } class _r { constructor(t, e) { this.styles = t, this.defaultParams = e } buildStyles(t, e) { const n = {}, r = xn(this.defaultParams); return Object.keys(t).forEach(e => { const n = t[e]; null != n && (r[e] = n) }), this.styles.styles.forEach(t => { if ("string" != typeof t) { const s = t; Object.keys(s).forEach(t => { let i = s[t]; i.length > 1 && (i = Dn(i, r, e)), n[t] = i }) } }), n } } class yr { constructor(t, e) { this.name = t, this.ast = e, this.transitionFactories = [], this.states = {}, e.states.forEach(t => { this.states[t.name] = new _r(t.style, t.options && t.options.params || {}) }), vr(this.states, "true", "1"), vr(this.states, "false", "0"), e.transitions.forEach(e => { this.transitionFactories.push(new mr(t, e, this.states)) }), this.fallbackTransition = new mr(t, { type: 1, animation: { type: 2, steps: [], options: null }, matchers: [(t, e) => !0], options: null, queryCount: 0, depCount: 0 }, this.states) } get containsQueries() { return this.ast.queryCount > 0 } matchTransition(t, e, n, r) { return this.transitionFactories.find(s => s.match(t, e, n, r)) || null } matchStyles(t, e, n) { return this.fallbackTransition.buildStyles(t, e, n) } } function vr(t, e, n) { t.hasOwnProperty(e) ? t.hasOwnProperty(n) || (t[n] = t[e]) : t.hasOwnProperty(n) && (t[e] = t[n]) } const br = new er; class wr { constructor(t, e, n) { this.bodyNode = t, this._driver = e, this._normalizer = n, this._animations = {}, this._playersById = {}, this.players = [] } register(t, e) { const n = [], r = Wn(this._driver, e, n); if (n.length) throw new Error(`Unable to build the animation due to the following errors: ${n.join("\n")}`); this._animations[t] = r } _buildPlayer(t, e, n) { const r = t.element, s = Ye(0, this._normalizer, 0, t.keyframes, e, n); return this._driver.animate(r, s, t.duration, t.delay, t.easing, [], !0) } create(t, e, n = {}) { const r = [], s = this._animations[t]; let i; const o = new Map; if (s ? (i = sr(this._driver, e, s, mn, _n, {}, {}, n, br, r), i.forEach(t => { const e = tn(o, t.element, {}); t.postStyleProps.forEach(t => e[t] = null) })) : (r.push("The requested animation doesn't exist or has already been destroyed"), i = []), r.length) throw new Error(`Unable to create the animation due to the following errors: ${r.join("\n")}`); o.forEach((t, e) => { Object.keys(t).forEach(n => { t[n] = this._driver.computeStyle(e, n, Be) }) }); const a = Ke(i.map(t => { const e = o.get(t.element); return this._buildPlayer(t, {}, e) })); return this._playersById[t] = a, a.onDestroy(() => this.destroy(t)), this.players.push(a), a } destroy(t) { const e = this._getPlayer(t); e.destroy(), delete this._playersById[t]; const n = this.players.indexOf(e); n >= 0 && this.players.splice(n, 1) } _getPlayer(t) { const e = this._playersById[t]; if (!e) throw new Error(`Unable to find the timeline player referenced by ${t}`); return e } listen(t, e, n, r) { const s = Xe(e, "", "", ""); return Qe(this._getPlayer(t), n, s, r), () => { } } command(t, e, n, r) { if ("register" == n) return void this.register(t, r[0]); if ("create" == n) return void this.create(t, e, r[0] || {}); const s = this._getPlayer(t); switch (n) { case "play": s.play(); break; case "pause": s.pause(); break; case "reset": s.reset(); break; case "restart": s.restart(); break; case "finish": s.finish(); break; case "init": s.init(); break; case "setPosition": s.setPosition(parseFloat(r[0])); break; case "destroy": this.destroy(t) } } } const Er = "ng-animate-queued", Sr = "ng-animate-disabled", Cr = ".ng-animate-disabled", xr = [], Or = { namespaceId: "", setForRemoval: !1, setForMove: !1, hasAnimation: !1, removedBeforeQueried: !1 }, Tr = { namespaceId: "", setForMove: !1, setForRemoval: !1, hasAnimation: !1, removedBeforeQueried: !0 }; class Pr { constructor(t, e = "") { this.namespaceId = e; const n = t && t.hasOwnProperty("value"); if (this.value = null != (r = n ? t.value : t) ? r : null, n) { const e = xn(t); delete e.value, this.options = e } else this.options = {}; var r; this.options.params || (this.options.params = {}) } get params() { return this.options.params } absorbOptions(t) { const e = t.params; if (e) { const t = this.options.params; Object.keys(e).forEach(n => { null == t[n] && (t[n] = e[n]) }) } } } const kr = "void", Ar = new Pr(kr); class Ir { constructor(t, e, n) { this.id = t, this.hostElement = e, this._engine = n, this.players = [], this._triggers = {}, this._queue = [], this._elementListeners = new Map, this._hostClassName = "ng-tns-" + t, jr(e, this._hostClassName) } listen(t, e, n, r) { if (!this._triggers.hasOwnProperty(e)) throw new Error(`Unable to listen on the animation trigger event "${n}" because the animation trigger "${e}" doesn't exist!`); if (null == n || 0 == n.length) throw new Error(`Unable to listen on the animation trigger "${e}" because the provided event is undefined!`); if ("start" != (s = n) && "done" != s) throw new Error(`The provided animation trigger event "${n}" for the animation trigger "${e}" is not supported!`); var s; const i = tn(this._elementListeners, t, []), o = { name: e, phase: n, callback: r }; i.push(o); const a = tn(this._engine.statesByElement, t, {}); return a.hasOwnProperty(e) || (jr(t, yn), jr(t, "ng-trigger-" + e), a[e] = Ar), () => { this._engine.afterFlush(() => { const t = i.indexOf(o); t >= 0 && i.splice(t, 1), this._triggers[e] || delete a[e] }) } } register(t, e) { return !this._triggers[t] && (this._triggers[t] = e, !0) } _getTrigger(t) { const e = this._triggers[t]; if (!e) throw new Error(`The provided animation trigger "${t}" has not been registered!`); return e } trigger(t, e, n, r = !0) { const s = this._getTrigger(e), i = new Mr(this.id, e, t); let o = this._engine.statesByElement.get(t); o || (jr(t, yn), jr(t, "ng-trigger-" + e), this._engine.statesByElement.set(t, o = {})); let a = o[e]; const l = new Pr(n, this.id); if (!(n && n.hasOwnProperty("value")) && a && l.absorbOptions(a.options), o[e] = l, a || (a = Ar), l.value !== kr && a.value === l.value) { if (!function (t, e) { const n = Object.keys(t), r = Object.keys(e); if (n.length != r.length) return !1; for (let s = 0; s < n.length; s++) { const r = n[s]; if (!e.hasOwnProperty(r) || t[r] !== e[r]) return !1 } return !0 }(a.params, l.params)) { const e = [], n = s.matchStyles(a.value, a.params, e), r = s.matchStyles(l.value, l.params, e); e.length ? this._engine.reportError(e) : this._engine.afterFlush(() => { An(t, n), kn(t, r) }) } return } const c = tn(this._engine.playersByElement, t, []); c.forEach(t => { t.namespaceId == this.id && t.triggerName == e && t.queued && t.destroy() }); let u = s.matchTransition(a.value, l.value, t, l.params), h = !1; if (!u) { if (!r) return; u = s.fallbackTransition, h = !0 } return this._engine.totalQueuedPlayers++, this._queue.push({ element: t, triggerName: e, transition: u, fromState: a, toState: l, player: i, isFallbackTransition: h }), h || (jr(t, Er), i.onStart(() => { Ur(t, Er) })), i.onDone(() => { let e = this.players.indexOf(i); e >= 0 && this.players.splice(e, 1); const n = this._engine.playersByElement.get(t); if (n) { let t = n.indexOf(i); t >= 0 && n.splice(t, 1) } }), this.players.push(i), c.push(i), i } deregister(t) { delete this._triggers[t], this._engine.statesByElement.forEach((e, n) => { delete e[t] }), this._elementListeners.forEach((e, n) => { this._elementListeners.set(n, e.filter(e => e.name != t)) }) } clearElementCache(t) { this._engine.statesByElement.delete(t), this._elementListeners.delete(t); const e = this._engine.playersByElement.get(t); e && (e.forEach(t => t.destroy()), this._engine.playersByElement.delete(t)) } _signalRemovalForInnerTriggers(t, e) { const n = this._engine.driver.query(t, vn, !0); n.forEach(t => { if (t.__ng_removed) return; const n = this._engine.fetchNamespacesByElement(t); n.size ? n.forEach(n => n.triggerLeaveAnimation(t, e, !1, !0)) : this.clearElementCache(t) }), this._engine.afterFlushAnimationsDone(() => n.forEach(t => this.clearElementCache(t))) } triggerLeaveAnimation(t, e, n, r) { const s = this._engine.statesByElement.get(t); if (s) { const i = []; if (Object.keys(s).forEach(e => { if (this._triggers[e]) { const n = this.trigger(t, e, kr, r); n && i.push(n) } }), i.length) return this._engine.markElementAsRemoved(this.id, t, !0, e), n && Ke(i).onDone(() => this._engine.processLeaveNode(t)), !0 } return !1 } prepareLeaveAnimationListeners(t) { const e = this._elementListeners.get(t), n = this._engine.statesByElement.get(t); if (e && n) { const r = new Set; e.forEach(e => { const s = e.name; if (r.has(s)) return; r.add(s); const i = this._triggers[s].fallbackTransition, o = n[s] || Ar, a = new Pr(kr), l = new Mr(this.id, s, t); this._engine.totalQueuedPlayers++, this._queue.push({ element: t, triggerName: s, transition: i, fromState: o, toState: a, player: l, isFallbackTransition: !0 }) }) } } removeNode(t, e) { const n = this._engine; if (t.childElementCount && this._signalRemovalForInnerTriggers(t, e), this.triggerLeaveAnimation(t, e, !0)) return; let r = !1; if (n.totalAnimations) { const e = n.players.length ? n.playersByQueriedElement.get(t) : []; if (e && e.length) r = !0; else { let e = t; for (; e = e.parentNode;)if (n.statesByElement.get(e)) { r = !0; break } } } if (this.prepareLeaveAnimationListeners(t), r) n.markElementAsRemoved(this.id, t, !1, e); else { const r = t.__ng_removed; r && r !== Or || (n.afterFlush(() => this.clearElementCache(t)), n.destroyInnerAnimations(t), n._onRemovalComplete(t, e)) } } insertNode(t, e) { jr(t, this._hostClassName) } drainQueuedTransitions(t) { const e = []; return this._queue.forEach(n => { const r = n.player; if (r.destroyed) return; const s = n.element, i = this._elementListeners.get(s); i && i.forEach(e => { if (e.name == n.triggerName) { const r = Xe(s, n.triggerName, n.fromState.value, n.toState.value); r._data = t, Qe(n.player, e.phase, r, e.callback) } }), r.markedForDestroy ? this._engine.afterFlush(() => { r.destroy() }) : e.push(n) }), this._queue = [], e.sort((t, e) => { const n = t.transition.ast.depCount, r = e.transition.ast.depCount; return 0 == n || 0 == r ? n - r : this._engine.driver.containsElement(t.element, e.element) ? 1 : -1 }) } destroy(t) { this.players.forEach(t => t.destroy()), this._signalRemovalForInnerTriggers(this.hostElement, t) } elementContainsData(t) { let e = !1; return this._elementListeners.has(t) && (e = !0), e = !!this._queue.find(e => e.element === t) || e, e } } class Rr { constructor(t, e, n) { this.bodyNode = t, this.driver = e, this._normalizer = n, this.players = [], this.newHostElements = new Map, this.playersByElement = new Map, this.playersByQueriedElement = new Map, this.statesByElement = new Map, this.disabledNodes = new Set, this.totalAnimations = 0, this.totalQueuedPlayers = 0, this._namespaceLookup = {}, this._namespaceList = [], this._flushFns = [], this._whenQuietFns = [], this.namespacesByHostElement = new Map, this.collectedEnterElements = [], this.collectedLeaveElements = [], this.onRemovalComplete = (t, e) => { } } _onRemovalComplete(t, e) { this.onRemovalComplete(t, e) } get queuedPlayers() { const t = []; return this._namespaceList.forEach(e => { e.players.forEach(e => { e.queued && t.push(e) }) }), t } createNamespace(t, e) { const n = new Ir(t, e, this); return this.bodyNode && this.driver.containsElement(this.bodyNode, e) ? this._balanceNamespaceList(n, e) : (this.newHostElements.set(e, n), this.collectEnterElement(e)), this._namespaceLookup[t] = n } _balanceNamespaceList(t, e) { const n = this._namespaceList.length - 1; if (n >= 0) { let r = !1; for (let s = n; s >= 0; s--)if (this.driver.containsElement(this._namespaceList[s].hostElement, e)) { this._namespaceList.splice(s + 1, 0, t), r = !0; break } r || this._namespaceList.splice(0, 0, t) } else this._namespaceList.push(t); return this.namespacesByHostElement.set(e, t), t } register(t, e) { let n = this._namespaceLookup[t]; return n || (n = this.createNamespace(t, e)), n } registerTrigger(t, e, n) { let r = this._namespaceLookup[t]; r && r.register(e, n) && this.totalAnimations++ } destroy(t, e) { if (!t) return; const n = this._fetchNamespace(t); this.afterFlush(() => { this.namespacesByHostElement.delete(n.hostElement), delete this._namespaceLookup[t]; const e = this._namespaceList.indexOf(n); e >= 0 && this._namespaceList.splice(e, 1) }), this.afterFlushAnimationsDone(() => n.destroy(e)) } _fetchNamespace(t) { return this._namespaceLookup[t] } fetchNamespacesByElement(t) { const e = new Set, n = this.statesByElement.get(t); if (n) { const t = Object.keys(n); for (let r = 0; r < t.length; r++) { const s = n[t[r]].namespaceId; if (s) { const t = this._fetchNamespace(s); t && e.add(t) } } } return e } trigger(t, e, n, r) { if (Dr(e)) { const s = this._fetchNamespace(t); if (s) return s.trigger(e, n, r), !0 } return !1 } insertNode(t, e, n, r) { if (!Dr(e)) return; const s = e.__ng_removed; if (s && s.setForRemoval) { s.setForRemoval = !1, s.setForMove = !0; const t = this.collectedLeaveElements.indexOf(e); t >= 0 && this.collectedLeaveElements.splice(t, 1) } if (t) { const r = this._fetchNamespace(t); r && r.insertNode(e, n) } r && this.collectEnterElement(e) } collectEnterElement(t) { this.collectedEnterElements.push(t) } markElementAsDisabled(t, e) { e ? this.disabledNodes.has(t) || (this.disabledNodes.add(t), jr(t, Sr)) : this.disabledNodes.has(t) && (this.disabledNodes.delete(t), Ur(t, Sr)) } removeNode(t, e, n, r) { if (Dr(e)) { const s = t ? this._fetchNamespace(t) : null; if (s ? s.removeNode(e, r) : this.markElementAsRemoved(t, e, !1, r), n) { const n = this.namespacesByHostElement.get(e); n && n.id !== t && n.removeNode(e, r) } } else this._onRemovalComplete(e, r) } markElementAsRemoved(t, e, n, r) { this.collectedLeaveElements.push(e), e.__ng_removed = { namespaceId: t, setForRemoval: r, hasAnimation: n, removedBeforeQueried: !1 } } listen(t, e, n, r, s) { return Dr(e) ? this._fetchNamespace(t).listen(e, n, r, s) : () => { } } _buildInstruction(t, e, n, r, s) { return t.transition.build(this.driver, t.element, t.fromState.value, t.toState.value, n, r, t.fromState.options, t.toState.options, e, s) } destroyInnerAnimations(t) { let e = this.driver.query(t, vn, !0); e.forEach(t => this.destroyActiveAnimationsForElement(t)), 0 != this.playersByQueriedElement.size && (e = this.driver.query(t, wn, !0), e.forEach(t => this.finishActiveQueriedAnimationOnElement(t))) } destroyActiveAnimationsForElement(t) { const e = this.playersByElement.get(t); e && e.forEach(t => { t.queued ? t.markedForDestroy = !0 : t.destroy() }) } finishActiveQueriedAnimationOnElement(t) { const e = this.playersByQueriedElement.get(t); e && e.forEach(t => t.finish()) } whenRenderingDone() { return new Promise(t => { if (this.players.length) return Ke(this.players).onDone(() => t()); t() }) } processLeaveNode(t) { const e = t.__ng_removed; if (e && e.setForRemoval) { if (t.__ng_removed = Or, e.namespaceId) { this.destroyInnerAnimations(t); const n = this._fetchNamespace(e.namespaceId); n && n.clearElementCache(t) } this._onRemovalComplete(t, e.setForRemoval) } this.driver.matchesElement(t, Cr) && this.markElementAsDisabled(t, !1), this.driver.query(t, Cr, !0).forEach(t => { this.markElementAsDisabled(t, !1) }) } flush(t = -1) { let e = []; if (this.newHostElements.size && (this.newHostElements.forEach((t, e) => this._balanceNamespaceList(t, e)), this.newHostElements.clear()), this.totalAnimations && this.collectedEnterElements.length) for (let n = 0; n < this.collectedEnterElements.length; n++)jr(this.collectedEnterElements[n], "ng-star-inserted"); if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) { const n = []; try { e = this._flushAnimations(n, t) } finally { for (let t = 0; t < n.length; t++)n[t]() } } else for (let n = 0; n < this.collectedLeaveElements.length; n++)this.processLeaveNode(this.collectedLeaveElements[n]); if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0, this.collectedLeaveElements.length = 0, this._flushFns.forEach(t => t()), this._flushFns = [], this._whenQuietFns.length) { const t = this._whenQuietFns; this._whenQuietFns = [], e.length ? Ke(e).onDone(() => { t.forEach(t => t()) }) : t.forEach(t => t()) } } reportError(t) { throw new Error(`Unable to process animations due to the following failed trigger transitions\n ${t.join("\n")}`) } _flushAnimations(t, e) { const n = new er, r = [], s = new Map, i = [], o = new Map, a = new Map, l = new Map, c = new Set; this.disabledNodes.forEach(t => { c.add(t); const e = this.driver.query(t, ".ng-animate-queued", !0); for (let n = 0; n < e.length; n++)c.add(e[n]) }); const u = this.bodyNode, h = Array.from(this.statesByElement.keys()), d = Fr(h, this.collectedEnterElements), p = new Map; let f = 0; d.forEach((t, e) => { const n = mn + f++; p.set(e, n), t.forEach(t => jr(t, n)) }); const g = [], m = new Set, _ = new Set; for (let A = 0; A < this.collectedLeaveElements.length; A++) { const t = this.collectedLeaveElements[A], e = t.__ng_removed; e && e.setForRemoval && (g.push(t), m.add(t), e.hasAnimation ? this.driver.query(t, ".ng-star-inserted", !0).forEach(t => m.add(t)) : _.add(t)) } const y = new Map, v = Fr(h, Array.from(m)); v.forEach((t, e) => { const n = _n + f++; y.set(e, n), t.forEach(t => jr(t, n)) }), t.push(() => { d.forEach((t, e) => { const n = p.get(e); t.forEach(t => Ur(t, n)) }), v.forEach((t, e) => { const n = y.get(e); t.forEach(t => Ur(t, n)) }), g.forEach(t => { this.processLeaveNode(t) }) }); const b = [], w = []; for (let A = this._namespaceList.length - 1; A >= 0; A--)this._namespaceList[A].drainQueuedTransitions(e).forEach(t => { const e = t.player, s = t.element; if (b.push(e), this.collectedEnterElements.length) { const t = s.__ng_removed; if (t && t.setForMove) return void e.destroy() } const c = !u || !this.driver.containsElement(u, s), h = y.get(s), d = p.get(s), f = this._buildInstruction(t, n, d, h, c); if (f.errors && f.errors.length) w.push(f); else { if (c) return e.onStart(() => An(s, f.fromStyles)), e.onDestroy(() => kn(s, f.toStyles)), void r.push(e); if (t.isFallbackTransition) return e.onStart(() => An(s, f.fromStyles)), e.onDestroy(() => kn(s, f.toStyles)), void r.push(e); f.timelines.forEach(t => t.stretchStartingKeyframe = !0), n.append(s, f.timelines), i.push({ instruction: f, player: e, element: s }), f.queriedElements.forEach(t => tn(o, t, []).push(e)), f.preStyleProps.forEach((t, e) => { const n = Object.keys(t); if (n.length) { let t = a.get(e); t || a.set(e, t = new Set), n.forEach(e => t.add(e)) } }), f.postStyleProps.forEach((t, e) => { const n = Object.keys(t); let r = l.get(e); r || l.set(e, r = new Set), n.forEach(t => r.add(t)) }) } }); if (w.length) { const t = []; w.forEach(e => { t.push(`@${e.triggerName} has failed due to:\n`), e.errors.forEach(e => t.push(`- ${e}\n`)) }), b.forEach(t => t.destroy()), this.reportError(t) } const E = new Map, S = new Map; i.forEach(t => { const e = t.element; n.has(e) && (S.set(e, e), this._beforeAnimationBuild(t.player.namespaceId, t.instruction, E)) }), r.forEach(t => { const e = t.element; this._getPreviousPlayers(e, !1, t.namespaceId, t.triggerName, null).forEach(t => { tn(E, e, []).push(t), t.destroy() }) }); const C = g.filter(t => qr(t, a, l)), x = new Map; Nr(x, this.driver, _, l, Be).forEach(t => { qr(t, a, l) && C.push(t) }); const O = new Map; d.forEach((t, e) => { Nr(O, this.driver, new Set(t), a, "!") }), C.forEach(t => { const e = x.get(t), n = O.get(t); x.set(t, Object.assign(Object.assign({}, e), n)) }); const T = [], P = [], k = {}; i.forEach(t => { const { element: e, player: i, instruction: o } = t; if (n.has(e)) { if (c.has(e)) return i.onDestroy(() => kn(e, o.toStyles)), i.disabled = !0, i.overrideTotalTime(o.totalTime), void r.push(i); let t = k; if (S.size > 1) { let n = e; const r = []; for (; n = n.parentNode;) { const e = S.get(n); if (e) { t = e; break } r.push(n) } r.forEach(e => S.set(e, t)) } const n = this._buildAnimation(i.namespaceId, o, E, s, O, x); if (i.setRealPlayer(n), t === k) T.push(i); else { const e = this.playersByElement.get(t); e && e.length && (i.parentPlayer = Ke(e)), r.push(i) } } else An(e, o.fromStyles), i.onDestroy(() => kn(e, o.toStyles)), P.push(i), c.has(e) && r.push(i) }), P.forEach(t => { const e = s.get(t.element); if (e && e.length) { const n = Ke(e); t.setRealPlayer(n) } }), r.forEach(t => { t.parentPlayer ? t.syncPlayerEvents(t.parentPlayer) : t.destroy() }); for (let A = 0; A < g.length; A++) { const t = g[A], e = t.__ng_removed; if (Ur(t, _n), e && e.hasAnimation) continue; let n = []; if (o.size) { let e = o.get(t); e && e.length && n.push(...e); let r = this.driver.query(t, wn, !0); for (let t = 0; t < r.length; t++) { let e = o.get(r[t]); e && e.length && n.push(...e) } } const r = n.filter(t => !t.destroyed); r.length ? Vr(this, t, r) : this.processLeaveNode(t) } return g.length = 0, T.forEach(t => { this.players.push(t), t.onDone(() => { t.destroy(); const e = this.players.indexOf(t); this.players.splice(e, 1) }), t.play() }), T } elementContainsData(t, e) { let n = !1; const r = e.__ng_removed; return r && r.setForRemoval && (n = !0), this.playersByElement.has(e) && (n = !0), this.playersByQueriedElement.has(e) && (n = !0), this.statesByElement.has(e) && (n = !0), this._fetchNamespace(t).elementContainsData(e) || n } afterFlush(t) { this._flushFns.push(t) } afterFlushAnimationsDone(t) { this._whenQuietFns.push(t) } _getPreviousPlayers(t, e, n, r, s) { let i = []; if (e) { const e = this.playersByQueriedElement.get(t); e && (i = e) } else { const e = this.playersByElement.get(t); if (e) { const t = !s || s == kr; e.forEach(e => { e.queued || (t || e.triggerName == r) && i.push(e) }) } } return (n || r) && (i = i.filter(t => !(n && n != t.namespaceId || r && r != t.triggerName))), i } _beforeAnimationBuild(t, e, n) { const r = e.element, s = e.isRemovalTransition ? void 0 : t, i = e.isRemovalTransition ? void 0 : e.triggerName; for (const o of e.timelines) { const t = o.element, a = t !== r, l = tn(n, t, []); this._getPreviousPlayers(t, a, s, i, e.toState).forEach(t => { const e = t.getRealPlayer(); e.beforeDestroy && e.beforeDestroy(), t.destroy(), l.push(t) }) } An(r, e.fromStyles) } _buildAnimation(t, e, n, r, s, i) { const o = e.triggerName, a = e.element, l = [], c = new Set, u = new Set, h = e.timelines.map(e => { const h = e.element; c.add(h); const d = h.__ng_removed; if (d && d.removedBeforeQueried) return new He(e.duration, e.delay); const p = h !== a, f = function (t) { const e = []; return Br(t, e), e }((n.get(h) || xr).map(t => t.getRealPlayer())).filter(t => !!t.element && t.element === h), g = s.get(h), m = i.get(h), _ = Ye(0, this._normalizer, 0, e.keyframes, g, m), y = this._buildPlayer(e, _, f); if (e.subTimeline && r && u.add(h), p) { const e = new Mr(t, o, h); e.setRealPlayer(y), l.push(e) } return y }); l.forEach(t => { tn(this.playersByQueriedElement, t.element, []).push(t), t.onDone(() => function (t, e, n) { let r; if (t instanceof Map) { if (r = t.get(e), r) { if (r.length) { const t = r.indexOf(n); r.splice(t, 1) } 0 == r.length && t.delete(e) } } else if (r = t[e], r) { if (r.length) { const t = r.indexOf(n); r.splice(t, 1) } 0 == r.length && delete t[e] } return r }(this.playersByQueriedElement, t.element, t)) }), c.forEach(t => jr(t, bn)); const d = Ke(h); return d.onDestroy(() => { c.forEach(t => Ur(t, bn)), kn(a, e.toStyles) }), u.forEach(t => { tn(r, t, []).push(d) }), d } _buildPlayer(t, e, n) { return e.length > 0 ? this.driver.animate(t.element, e, t.duration, t.delay, t.easing, n) : new He(t.duration, t.delay) } } class Mr { constructor(t, e, n) { this.namespaceId = t, this.triggerName = e, this.element = n, this._player = new He, this._containsRealPlayer = !1, this._queuedCallbacks = {}, this.destroyed = !1, this.markedForDestroy = !1, this.disabled = !1, this.queued = !0, this.totalTime = 0 } setRealPlayer(t) { this._containsRealPlayer || (this._player = t, Object.keys(this._queuedCallbacks).forEach(e => { this._queuedCallbacks[e].forEach(n => Qe(t, e, void 0, n)) }), this._queuedCallbacks = {}, this._containsRealPlayer = !0, this.overrideTotalTime(t.totalTime), this.queued = !1) } getRealPlayer() { return this._player } overrideTotalTime(t) { this.totalTime = t } syncPlayerEvents(t) { const e = this._player; e.triggerCallback && t.onStart(() => e.triggerCallback("start")), t.onDone(() => this.finish()), t.onDestroy(() => this.destroy()) } _queueEvent(t, e) { tn(this._queuedCallbacks, t, []).push(e) } onDone(t) { this.queued && this._queueEvent("done", t), this._player.onDone(t) } onStart(t) { this.queued && this._queueEvent("start", t), this._player.onStart(t) } onDestroy(t) { this.queued && this._queueEvent("destroy", t), this._player.onDestroy(t) } init() { this._player.init() } hasStarted() { return !this.queued && this._player.hasStarted() } play() { !this.queued && this._player.play() } pause() { !this.queued && this._player.pause() } restart() { !this.queued && this._player.restart() } finish() { this._player.finish() } destroy() { this.destroyed = !0, this._player.destroy() } reset() { !this.queued && this._player.reset() } setPosition(t) { this.queued || this._player.setPosition(t) } getPosition() { return this.queued ? 0 : this._player.getPosition() } triggerCallback(t) { const e = this._player; e.triggerCallback && e.triggerCallback(t) } } function Dr(t) { return t && 1 === t.nodeType } function Lr(t, e) { const n = t.style.display; return t.style.display = null != e ? e : "none", n } function Nr(t, e, n, r, s) { const i = []; n.forEach(t => i.push(Lr(t))); const o = []; r.forEach((n, r) => { const i = {}; n.forEach(t => { const n = i[t] = e.computeStyle(r, t, s); n && 0 != n.length || (r.__ng_removed = Tr, o.push(r)) }), t.set(r, i) }); let a = 0; return n.forEach(t => Lr(t, i[a++])), o } function Fr(t, e) { const n = new Map; if (t.forEach(t => n.set(t, [])), 0 == e.length) return n; const r = new Set(e), s = new Map; function i(t) { if (!t) return 1; let e = s.get(t); if (e) return e; const o = t.parentNode; return e = n.has(o) ? o : r.has(o) ? 1 : i(o), s.set(t, e), e } return e.forEach(t => { const e = i(t); 1 !== e && n.get(e).push(t) }), n } function jr(t, e) { if (t.classList) t.classList.add(e); else { let n = t.$$classes; n || (n = t.$$classes = {}), n[e] = !0 } } function Ur(t, e) { if (t.classList) t.classList.remove(e); else { let n = t.$$classes; n && delete n[e] } } function Vr(t, e, n) { Ke(n).onDone(() => t.processLeaveNode(e)) } function Br(t, e) { for (let n = 0; n < t.length; n++) { const r = t[n]; r instanceof Ge ? Br(r.players, e) : e.push(r) } } function qr(t, e, n) { const r = n.get(t); if (!r) return !1; let s = e.get(t); return s ? r.forEach(t => s.add(t)) : e.set(t, r), n.delete(t), !0 } class $r { constructor(t, e, n) { this.bodyNode = t, this._driver = e, this._triggerCache = {}, this.onRemovalComplete = (t, e) => { }, this._transitionEngine = new Rr(t, e, n), this._timelineEngine = new wr(t, e, n), this._transitionEngine.onRemovalComplete = (t, e) => this.onRemovalComplete(t, e) } registerTrigger(t, e, n, r, s) { const i = t + "-" + r; let o = this._triggerCache[i]; if (!o) { const t = [], e = Wn(this._driver, s, t); if (t.length) throw new Error(`The animation trigger "${r}" has failed to build due to the following errors:\n - ${t.join("\n - ")}`); o = function (t, e) { return new yr(t, e) }(r, e), this._triggerCache[i] = o } this._transitionEngine.registerTrigger(e, r, o) } register(t, e) { this._transitionEngine.register(t, e) } destroy(t, e) { this._transitionEngine.destroy(t, e) } onInsert(t, e, n, r) { this._transitionEngine.insertNode(t, e, n, r) } onRemove(t, e, n, r) { this._transitionEngine.removeNode(t, e, r || !1, n) } disableAnimations(t, e) { this._transitionEngine.markElementAsDisabled(t, e) } process(t, e, n, r) { if ("@" == n.charAt(0)) { const [t, s] = en(n); this._timelineEngine.command(t, e, s, r) } else this._transitionEngine.trigger(t, e, n, r) } listen(t, e, n, r, s) { if ("@" == n.charAt(0)) { const [t, r] = en(n); return this._timelineEngine.listen(t, e, r, s) } return this._transitionEngine.listen(t, e, n, r, s) } flush(t = -1) { this._transitionEngine.flush(t) } get players() { return this._transitionEngine.players.concat(this._timelineEngine.players) } whenRenderingDone() { return this._transitionEngine.whenRenderingDone() } } function zr(t, e) { let n = null, r = null; return Array.isArray(e) && e.length ? (n = Gr(e[0]), e.length > 1 && (r = Gr(e[e.length - 1]))) : e && (n = Gr(e)), n || r ? new Hr(t, n, r) : null } let Hr = (() => { class t { constructor(e, n, r) { this._element = e, this._startStyles = n, this._endStyles = r, this._state = 0; let s = t.initialStylesByElement.get(e); s || t.initialStylesByElement.set(e, s = {}), this._initialStyles = s } start() { this._state < 1 && (this._startStyles && kn(this._element, this._startStyles, this._initialStyles), this._state = 1) } finish() { this.start(), this._state < 2 && (kn(this._element, this._initialStyles), this._endStyles && (kn(this._element, this._endStyles), this._endStyles = null), this._state = 1) } destroy() { this.finish(), this._state < 3 && (t.initialStylesByElement.delete(this._element), this._startStyles && (An(this._element, this._startStyles), this._endStyles = null), this._endStyles && (An(this._element, this._endStyles), this._endStyles = null), kn(this._element, this._initialStyles), this._state = 3) } } return t.initialStylesByElement = new WeakMap, t })(); function Gr(t) { let e = null; const n = Object.keys(t); for (let r = 0; r < n.length; r++) { const s = n[r]; Zr(s) && (e = e || {}, e[s] = t[s]) } return e } function Zr(t) { return "display" === t || "position" === t } const Wr = "animation", Kr = "animationend"; class Yr { constructor(t, e, n, r, s, i, o) { this._element = t, this._name = e, this._duration = n, this._delay = r, this._easing = s, this._fillMode = i, this._onDoneFn = o, this._finished = !1, this._destroyed = !1, this._startTime = 0, this._position = 0, this._eventFn = t => this._handleCallback(t) } apply() { !function (t, e) { const n = ns(t, "").trim(); n.length && (function (t, e) { let n = 0; for (let r = 0; r < t.length; r++)"," === t.charAt(r) && n++ }(n), e = `${n}, ${e}`), es(t, "", e) }(this._element, `${this._duration}ms ${this._easing} ${this._delay}ms 1 normal ${this._fillMode} ${this._name}`), ts(this._element, this._eventFn, !1), this._startTime = Date.now() } pause() { Qr(this._element, this._name, "paused") } resume() { Qr(this._element, this._name, "running") } setPosition(t) { const e = Jr(this._element, this._name); this._position = t * this._duration, es(this._element, "Delay", `-${this._position}ms`, e) } getPosition() { return this._position } _handleCallback(t) { const e = t._ngTestManualTimestamp || Date.now(), n = 1e3 * parseFloat(t.elapsedTime.toFixed(3)); t.animationName == this._name && Math.max(e - this._startTime, 0) >= this._delay && n >= this._duration && this.finish() } finish() { this._finished || (this._finished = !0, this._onDoneFn(), ts(this._element, this._eventFn, !0)) } destroy() { this._destroyed || (this._destroyed = !0, this.finish(), function (t, e) { const n = ns(t, "").split(","), r = Xr(n, e); r >= 0 && (n.splice(r, 1), es(t, "", n.join(","))) }(this._element, this._name)) } } function Qr(t, e, n) { es(t, "PlayState", n, Jr(t, e)) } function Jr(t, e) { const n = ns(t, ""); return n.indexOf(",") > 0 ? Xr(n.split(","), e) : Xr([n], e) } function Xr(t, e) { for (let n = 0; n < t.length; n++)if (t[n].indexOf(e) >= 0) return n; return -1 } function ts(t, e, n) { n ? t.removeEventListener(Kr, e) : t.addEventListener(Kr, e) } function es(t, e, n, r) { const s = Wr + e; if (null != r) { const e = t.style[s]; if (e.length) { const t = e.split(","); t[r] = n, n = t.join(",") } } t.style[s] = n } function ns(t, e) { return t.style[Wr + e] || "" } class rs { constructor(t, e, n, r, s, i, o, a) { this.element = t, this.keyframes = e, this.animationName = n, this._duration = r, this._delay = s, this._finalStyles = o, this._specialStyles = a, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this.currentSnapshot = {}, this._state = 0, this.easing = i || "linear", this.totalTime = r + s, this._buildStyler() } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } destroy() { this.init(), this._state >= 4 || (this._state = 4, this._styler.destroy(), this._flushStartFns(), this._flushDoneFns(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } _flushDoneFns() { this._onDoneFns.forEach(t => t()), this._onDoneFns = [] } _flushStartFns() { this._onStartFns.forEach(t => t()), this._onStartFns = [] } finish() { this.init(), this._state >= 3 || (this._state = 3, this._styler.finish(), this._flushStartFns(), this._specialStyles && this._specialStyles.finish(), this._flushDoneFns()) } setPosition(t) { this._styler.setPosition(t) } getPosition() { return this._styler.getPosition() } hasStarted() { return this._state >= 2 } init() { this._state >= 1 || (this._state = 1, this._styler.apply(), this._delay && this._styler.pause()) } play() { this.init(), this.hasStarted() || (this._flushStartFns(), this._state = 2, this._specialStyles && this._specialStyles.start()), this._styler.resume() } pause() { this.init(), this._styler.pause() } restart() { this.reset(), this.play() } reset() { this._state = 0, this._styler.destroy(), this._buildStyler(), this._styler.apply() } _buildStyler() { this._styler = new Yr(this.element, this.animationName, this._duration, this._delay, this.easing, "forwards", () => this.finish()) } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } beforeDestroy() { this.init(); const t = {}; if (this.hasStarted()) { const e = this._state >= 3; Object.keys(this._finalStyles).forEach(n => { "offset" != n && (t[n] = e ? this._finalStyles[n] : Bn(this.element, n)) }) } this.currentSnapshot = t } } class ss extends He { constructor(t, e) { super(), this.element = t, this._startingStyles = {}, this.__initialized = !1, this._styles = pn(e) } init() { !this.__initialized && this._startingStyles && (this.__initialized = !0, Object.keys(this._styles).forEach(t => { this._startingStyles[t] = this.element.style[t] }), super.init()) } play() { this._startingStyles && (this.init(), Object.keys(this._styles).forEach(t => this.element.style.setProperty(t, this._styles[t])), super.play()) } destroy() { this._startingStyles && (Object.keys(this._startingStyles).forEach(t => { const e = this._startingStyles[t]; e ? this.element.style.setProperty(t, e) : this.element.style.removeProperty(t) }), this._startingStyles = null, super.destroy()) } } class is { constructor() { this._count = 0 } validateStyleProperty(t) { return cn(t) } matchesElement(t, e) { return un(t, e) } containsElement(t, e) { return hn(t, e) } query(t, e, n) { return dn(t, e, n) } computeStyle(t, e, n) { return window.getComputedStyle(t)[e] } buildKeyframeElement(t, e, n) { n = n.map(t => pn(t)); let r = `@keyframes ${e} {\n`, s = ""; n.forEach(t => { s = " "; const e = parseFloat(t.offset); r += `${s}${100 * e}% {\n`, s += " ", Object.keys(t).forEach(e => { const n = t[e]; switch (e) { case "offset": return; case "easing": return void (n && (r += `${s}animation-timing-function: ${n};\n`)); default: return void (r += `${s}${e}: ${n};\n`) } }), r += `${s}}\n` }), r += "}\n"; const i = document.createElement("style"); return i.textContent = r, i } animate(t, e, n, r, s, i = [], o) { const a = i.filter(t => t instanceof rs), l = {}; jn(n, r) && a.forEach(t => { let e = t.currentSnapshot; Object.keys(e).forEach(t => l[t] = e[t]) }); const c = function (t) { let e = {}; return t && (Array.isArray(t) ? t : [t]).forEach(t => { Object.keys(t).forEach(n => { "offset" != n && "easing" != n && (e[n] = t[n]) }) }), e }(e = Un(t, e, l)); if (0 == n) return new ss(t, c); const u = "gen_css_kf_" + this._count++, h = this.buildKeyframeElement(t, u, e); (function (t) { var e; const n = null === (e = t.getRootNode) || void 0 === e ? void 0 : e.call(t); return "undefined" != typeof ShadowRoot && n instanceof ShadowRoot ? n : document.head })(t).appendChild(h); const d = zr(t, e), p = new rs(t, e, u, n, r, s, c, d); return p.onDestroy(() => { var t; (t = h).parentNode.removeChild(t) }), p } } class os { constructor(t, e, n, r) { this.element = t, this.keyframes = e, this.options = n, this._specialStyles = r, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._initialized = !1, this._finished = !1, this._started = !1, this._destroyed = !1, this.time = 0, this.parentPlayer = null, this.currentSnapshot = {}, this._duration = n.duration, this._delay = n.delay || 0, this.time = this._duration + this._delay } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } init() { this._buildPlayer(), this._preparePlayerBeforeStart() } _buildPlayer() { if (this._initialized) return; this._initialized = !0; const t = this.keyframes; this.domPlayer = this._triggerWebAnimation(this.element, t, this.options), this._finalKeyframe = t.length ? t[t.length - 1] : {}, this.domPlayer.addEventListener("finish", () => this._onFinish()) } _preparePlayerBeforeStart() { this._delay ? this._resetDomPlayerState() : this.domPlayer.pause() } _triggerWebAnimation(t, e, n) { return t.animate(e, n) } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } play() { this._buildPlayer(), this.hasStarted() || (this._onStartFns.forEach(t => t()), this._onStartFns = [], this._started = !0, this._specialStyles && this._specialStyles.start()), this.domPlayer.play() } pause() { this.init(), this.domPlayer.pause() } finish() { this.init(), this._specialStyles && this._specialStyles.finish(), this._onFinish(), this.domPlayer.finish() } reset() { this._resetDomPlayerState(), this._destroyed = !1, this._finished = !1, this._started = !1 } _resetDomPlayerState() { this.domPlayer && this.domPlayer.cancel() } restart() { this.reset(), this.play() } hasStarted() { return this._started } destroy() { this._destroyed || (this._destroyed = !0, this._resetDomPlayerState(), this._onFinish(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } setPosition(t) { void 0 === this.domPlayer && this.init(), this.domPlayer.currentTime = t * this.time } getPosition() { return this.domPlayer.currentTime / this.time } get totalTime() { return this._delay + this._duration } beforeDestroy() { const t = {}; this.hasStarted() && Object.keys(this._finalKeyframe).forEach(e => { "offset" != e && (t[e] = this._finished ? this._finalKeyframe[e] : Bn(this.element, e)) }), this.currentSnapshot = t } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } } class as { constructor() { this._isNativeImpl = /\{\s*\[native\s+code\]\s*\}/.test(ls().toString()), this._cssKeyframesDriver = new is } validateStyleProperty(t) { return cn(t) } matchesElement(t, e) { return un(t, e) } containsElement(t, e) { return hn(t, e) } query(t, e, n) { return dn(t, e, n) } computeStyle(t, e, n) { return window.getComputedStyle(t)[e] } overrideWebAnimationsSupport(t) { this._isNativeImpl = t } animate(t, e, n, r, s, i = [], o) { if (!o && !this._isNativeImpl) return this._cssKeyframesDriver.animate(t, e, n, r, s, i); const a = { duration: n, delay: r, fill: 0 == r ? "both" : "forwards" }; s && (a.easing = s); const l = {}, c = i.filter(t => t instanceof os); jn(n, r) && c.forEach(t => { let e = t.currentSnapshot; Object.keys(e).forEach(t => l[t] = e[t]) }); const u = zr(t, e = Un(t, e = e.map(t => On(t, !1)), l)); return new os(t, e, a, u) } } function ls() { return Ze() && Element.prototype.animate || {} } let cs = (() => { class t extends Ve { constructor(t, e) { super(), this._nextAnimationId = 0, this._renderer = t.createRenderer(e.body, { id: "0", encapsulation: r.ifc.None, styles: [], data: { animation: [] } }) } build(t) { const e = this._nextAnimationId.toString(); this._nextAnimationId++; const n = Array.isArray(t) ? qe(t) : t; return ds(this._renderer, null, e, "register", [n]), new us(e, this._renderer) } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(r.FYo), r.LFG(o)) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(); class us extends class { }{ constructor(t, e) { super(), this._id = t, this._renderer = e } create(t, e) { return new hs(this._id, t, e || {}, this._renderer) } } class hs { constructor(t, e, n, r) { this.id = t, this.element = e, this._renderer = r, this.parentPlayer = null, this._started = !1, this.totalTime = 0, this._command("create", n) } _listen(t, e) { return this._renderer.listen(this.element, `@@${this.id}:${t}`, e) } _command(t, ...e) { return ds(this._renderer, this.element, this.id, t, e) } onDone(t) { this._listen("done", t) } onStart(t) { this._listen("start", t) } onDestroy(t) { this._listen("destroy", t) } init() { this._command("init") } hasStarted() { return this._started } play() { this._command("play"), this._started = !0 } pause() { this._command("pause") } restart() { this._command("restart") } finish() { this._command("finish") } destroy() { this._command("destroy") } reset() { this._command("reset"), this._started = !1 } setPosition(t) { this._command("setPosition", t) } getPosition() { var t, e; return null !== (e = null === (t = this._renderer.engine.players[+this.id]) || void 0 === t ? void 0 : t.getPosition()) && void 0 !== e ? e : 0 } } function ds(t, e, n, r, s) { return t.setProperty(e, `@@${n}:${r}`, s) } const ps = "@", fs = "@.disabled"; let gs = (() => { class t { constructor(t, e, n) { this.delegate = t, this.engine = e, this._zone = n, this._currentId = 0, this._microtaskId = 1, this._animationCallbacksBuffer = [], this._rendererCache = new Map, this._cdRecurDepth = 0, this.promise = Promise.resolve(0), e.onRemovalComplete = (t, e) => { e && e.parentNode(t) && e.removeChild(t.parentNode, t) } } createRenderer(t, e) { const n = this.delegate.createRenderer(t, e); if (!(t && e && e.data && e.data.animation)) { let t = this._rendererCache.get(n); return t || (t = new ms("", n, this.engine), this._rendererCache.set(n, t)), t } const r = e.id, s = e.id + "-" + this._currentId; this._currentId++, this.engine.register(s, t); const i = e => { Array.isArray(e) ? e.forEach(i) : this.engine.registerTrigger(r, s, t, e.name, e) }; return e.data.animation.forEach(i), new _s(this, s, n, this.engine) } begin() { this._cdRecurDepth++, this.delegate.begin && this.delegate.begin() } _scheduleCountTask() { this.promise.then(() => { this._microtaskId++ }) } scheduleListenerCallback(t, e, n) { t >= 0 && t < this._microtaskId ? this._zone.run(() => e(n)) : (0 == this._animationCallbacksBuffer.length && Promise.resolve(null).then(() => { this._zone.run(() => { this._animationCallbacksBuffer.forEach(t => { const [e, n] = t; e(n) }), this._animationCallbacksBuffer = [] }) }), this._animationCallbacksBuffer.push([e, n])) } end() { this._cdRecurDepth--, 0 == this._cdRecurDepth && this._zone.runOutsideAngular(() => { this._scheduleCountTask(), this.engine.flush(this._microtaskId) }), this.delegate.end && this.delegate.end() } whenRenderingDone() { return this.engine.whenRenderingDone() } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(r.FYo), r.LFG($r), r.LFG(r.R0b)) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(); class ms { constructor(t, e, n) { this.namespaceId = t, this.delegate = e, this.engine = n, this.destroyNode = this.delegate.destroyNode ? t => e.destroyNode(t) : null } get data() { return this.delegate.data } destroy() { this.engine.destroy(this.namespaceId, this.delegate), this.delegate.destroy() } createElement(t, e) { return this.delegate.createElement(t, e) } createComment(t) { return this.delegate.createComment(t) } createText(t) { return this.delegate.createText(t) } appendChild(t, e) { this.delegate.appendChild(t, e), this.engine.onInsert(this.namespaceId, e, t, !1) } insertBefore(t, e, n, r = !0) { this.delegate.insertBefore(t, e, n), this.engine.onInsert(this.namespaceId, e, t, r) } removeChild(t, e, n) { this.engine.onRemove(this.namespaceId, e, this.delegate, n) } selectRootElement(t, e) { return this.delegate.selectRootElement(t, e) } parentNode(t) { return this.delegate.parentNode(t) } nextSibling(t) { return this.delegate.nextSibling(t) } setAttribute(t, e, n, r) { this.delegate.setAttribute(t, e, n, r) } removeAttribute(t, e, n) { this.delegate.removeAttribute(t, e, n) } addClass(t, e) { this.delegate.addClass(t, e) } removeClass(t, e) { this.delegate.removeClass(t, e) } setStyle(t, e, n, r) { this.delegate.setStyle(t, e, n, r) } removeStyle(t, e, n) { this.delegate.removeStyle(t, e, n) } setProperty(t, e, n) { e.charAt(0) == ps && e == fs ? this.disableAnimations(t, !!n) : this.delegate.setProperty(t, e, n) } setValue(t, e) { this.delegate.setValue(t, e) } listen(t, e, n) { return this.delegate.listen(t, e, n) } disableAnimations(t, e) { this.engine.disableAnimations(t, e) } } class _s extends ms { constructor(t, e, n, r) { super(e, n, r), this.factory = t, this.namespaceId = e } setProperty(t, e, n) { e.charAt(0) == ps ? "." == e.charAt(1) && e == fs ? this.disableAnimations(t, n = void 0 === n || !!n) : this.engine.process(this.namespaceId, t, e.substr(1), n) : this.delegate.setProperty(t, e, n) } listen(t, e, n) { if (e.charAt(0) == ps) { const r = function (t) { switch (t) { case "body": return document.body; case "document": return document; case "window": return window; default: return t } }(t); let s = e.substr(1), i = ""; return s.charAt(0) != ps && ([s, i] = function (t) { const e = t.indexOf("."); return [t.substring(0, e), t.substr(e + 1)] }(s)), this.engine.listen(this.namespaceId, r, s, i, t => { this.factory.scheduleListenerCallback(t._data || -1, n, t) }) } return this.delegate.listen(t, e, n) } } let ys = (() => { class t extends $r { constructor(t, e, n) { super(t.body, e, n) } ngOnDestroy() { this.flush() } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(o), r.LFG(gn), r.LFG(hr)) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(); const vs = new r.OlP("AnimationModuleType"), bs = [{ provide: Ve, useClass: cs }, { provide: hr, useFactory: function () { return new dr } }, { provide: $r, useClass: ys }, { provide: r.FYo, useFactory: function (t, e, n) { return new gs(t, e, n) }, deps: [_t, $r, r.R0b] }], ws = [{ provide: gn, useFactory: function () { return "function" == typeof ls() ? new as : new is } }, { provide: vs, useValue: "BrowserAnimations" }, ...bs], Es = [{ provide: gn, useClass: fn }, { provide: vs, useValue: "NoopAnimations" }, ...bs]; let Ss = (() => { class t { static withConfig(e) { return { ngModule: t, providers: e.disableAnimations ? Es : ws } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = r.oAB({ type: t }), t.\u0275inj = r.cJS({ providers: ws, imports: [kt] }), t })(); var Cs = n(878), xs = n(436), Os = n(3835); class Ts { } class Ps { } class ks { constructor(t) { this.normalizedNames = new Map, this.lazyUpdate = null, t ? this.lazyInit = "string" == typeof t ? () => { this.headers = new Map, t.split("\n").forEach(t => { const e = t.indexOf(":"); if (e > 0) { const n = t.slice(0, e), r = n.toLowerCase(), s = t.slice(e + 1).trim(); this.maybeSetNormalizedName(n, r), this.headers.has(r) ? this.headers.get(r).push(s) : this.headers.set(r, [s]) } }) } : () => { this.headers = new Map, Object.keys(t).forEach(e => { let n = t[e]; const r = e.toLowerCase(); "string" == typeof n && (n = [n]), n.length > 0 && (this.headers.set(r, n), this.maybeSetNormalizedName(e, r)) }) } : this.headers = new Map } has(t) { return this.init(), this.headers.has(t.toLowerCase()) } get(t) { this.init(); const e = this.headers.get(t.toLowerCase()); return e && e.length > 0 ? e[0] : null } keys() { return this.init(), Array.from(this.normalizedNames.values()) } getAll(t) { return this.init(), this.headers.get(t.toLowerCase()) || null } append(t, e) { return this.clone({ name: t, value: e, op: "a" }) } set(t, e) { return this.clone({ name: t, value: e, op: "s" }) } delete(t, e) { return this.clone({ name: t, value: e, op: "d" }) } maybeSetNormalizedName(t, e) { this.normalizedNames.has(e) || this.normalizedNames.set(e, t) } init() { this.lazyInit && (this.lazyInit instanceof ks ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(t => this.applyUpdate(t)), this.lazyUpdate = null)) } copyFrom(t) { t.init(), Array.from(t.headers.keys()).forEach(e => { this.headers.set(e, t.headers.get(e)), this.normalizedNames.set(e, t.normalizedNames.get(e)) }) } clone(t) { const e = new ks; return e.lazyInit = this.lazyInit && this.lazyInit instanceof ks ? this.lazyInit : this, e.lazyUpdate = (this.lazyUpdate || []).concat([t]), e } applyUpdate(t) { const e = t.name.toLowerCase(); switch (t.op) { case "a": case "s": let n = t.value; if ("string" == typeof n && (n = [n]), 0 === n.length) return; this.maybeSetNormalizedName(t.name, e); const r = ("a" === t.op ? this.headers.get(e) : void 0) || []; r.push(...n), this.headers.set(e, r); break; case "d": const s = t.value; if (s) { let t = this.headers.get(e); if (!t) return; t = t.filter(t => -1 === s.indexOf(t)), 0 === t.length ? (this.headers.delete(e), this.normalizedNames.delete(e)) : this.headers.set(e, t) } else this.headers.delete(e), this.normalizedNames.delete(e) } } forEach(t) { this.init(), Array.from(this.normalizedNames.keys()).forEach(e => t(this.normalizedNames.get(e), this.headers.get(e))) } } class As { encodeKey(t) { return Is(t) } encodeValue(t) { return Is(t) } decodeKey(t) { return decodeURIComponent(t) } decodeValue(t) { return decodeURIComponent(t) } } function Is(t) { return encodeURIComponent(t).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/gi, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%2B/gi, "+").replace(/%3D/gi, "=").replace(/%3F/gi, "?").replace(/%2F/gi, "/") } function Rs(t) { return `${t}` } class Ms { constructor(t = {}) { if (this.updates = null, this.cloneFrom = null, this.encoder = t.encoder || new As, t.fromString) { if (t.fromObject) throw new Error("Cannot specify both fromString and fromObject."); this.map = function (t, e) { const n = new Map; return t.length > 0 && t.replace(/^\?/, "").split("&").forEach(t => { const r = t.indexOf("="), [s, i] = -1 == r ? [e.decodeKey(t), ""] : [e.decodeKey(t.slice(0, r)), e.decodeValue(t.slice(r + 1))], o = n.get(s) || []; o.push(i), n.set(s, o) }), n }(t.fromString, this.encoder) } else t.fromObject ? (this.map = new Map, Object.keys(t.fromObject).forEach(e => { const n = t.fromObject[e]; this.map.set(e, Array.isArray(n) ? n : [n]) })) : this.map = null } has(t) { return this.init(), this.map.has(t) } get(t) { this.init(); const e = this.map.get(t); return e ? e[0] : null } getAll(t) { return this.init(), this.map.get(t) || null } keys() { return this.init(), Array.from(this.map.keys()) } append(t, e) { return this.clone({ param: t, value: e, op: "a" }) } appendAll(t) { const e = []; return Object.keys(t).forEach(n => { const r = t[n]; Array.isArray(r) ? r.forEach(t => { e.push({ param: n, value: t, op: "a" }) }) : e.push({ param: n, value: r, op: "a" }) }), this.clone(e) } set(t, e) { return this.clone({ param: t, value: e, op: "s" }) } delete(t, e) { return this.clone({ param: t, value: e, op: "d" }) } toString() { return this.init(), this.keys().map(t => { const e = this.encoder.encodeKey(t); return this.map.get(t).map(t => e + "=" + this.encoder.encodeValue(t)).join("&") }).filter(t => "" !== t).join("&") } clone(t) { const e = new Ms({ encoder: this.encoder }); return e.cloneFrom = this.cloneFrom || this, e.updates = (this.updates || []).concat(t), e } init() { null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(t => this.map.set(t, this.cloneFrom.map.get(t))), this.updates.forEach(t => { switch (t.op) { case "a": case "s": const e = ("a" === t.op ? this.map.get(t.param) : void 0) || []; e.push(Rs(t.value)), this.map.set(t.param, e); break; case "d": if (void 0 === t.value) { this.map.delete(t.param); break } { let e = this.map.get(t.param) || []; const n = e.indexOf(Rs(t.value)); -1 !== n && e.splice(n, 1), e.length > 0 ? this.map.set(t.param, e) : this.map.delete(t.param) } } }), this.cloneFrom = this.updates = null) } } class Ds { constructor() { this.map = new Map } set(t, e) { return this.map.set(t, e), this } get(t) { return this.map.has(t) || this.map.set(t, t.defaultValue()), this.map.get(t) } delete(t) { return this.map.delete(t), this } keys() { return this.map.keys() } } function Ls(t) { return "undefined" != typeof ArrayBuffer && t instanceof ArrayBuffer } function Ns(t) { return "undefined" != typeof Blob && t instanceof Blob } function Fs(t) { return "undefined" != typeof FormData && t instanceof FormData } class js { constructor(t, e, n, r) { let s; if (this.url = e, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = t.toUpperCase(), function (t) { switch (t) { case "DELETE": case "GET": case "HEAD": case "OPTIONS": case "JSONP": return !1; default: return !0 } }(this.method) || r ? (this.body = void 0 !== n ? n : null, s = r) : s = n, s && (this.reportProgress = !!s.reportProgress, this.withCredentials = !!s.withCredentials, s.responseType && (this.responseType = s.responseType), s.headers && (this.headers = s.headers), s.context && (this.context = s.context), s.params && (this.params = s.params)), this.headers || (this.headers = new ks), this.context || (this.context = new Ds), this.params) { const t = this.params.toString(); if (0 === t.length) this.urlWithParams = e; else { const n = e.indexOf("?"); this.urlWithParams = e + (-1 === n ? "?" : n < e.length - 1 ? "&" : "") + t } } else this.params = new Ms, this.urlWithParams = e } serializeBody() { return null === this.body ? null : Ls(this.body) || Ns(this.body) || Fs(this.body) || "string" == typeof this.body ? this.body : this.body instanceof Ms ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString() } detectContentTypeHeader() { return null === this.body || Fs(this.body) ? null : Ns(this.body) ? this.body.type || null : Ls(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof Ms ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || "boolean" == typeof this.body ? "application/json" : null } clone(t = {}) { var e; const n = t.method || this.method, r = t.url || this.url, s = t.responseType || this.responseType, i = void 0 !== t.body ? t.body : this.body, o = void 0 !== t.withCredentials ? t.withCredentials : this.withCredentials, a = void 0 !== t.reportProgress ? t.reportProgress : this.reportProgress; let l = t.headers || this.headers, c = t.params || this.params; const u = null !== (e = t.context) && void 0 !== e ? e : this.context; return void 0 !== t.setHeaders && (l = Object.keys(t.setHeaders).reduce((e, n) => e.set(n, t.setHeaders[n]), l)), t.setParams && (c = Object.keys(t.setParams).reduce((e, n) => e.set(n, t.setParams[n]), c)), new js(n, r, i, { params: c, headers: l, context: u, reportProgress: a, responseType: s, withCredentials: o }) } } var Us = function (t) { return t[t.Sent = 0] = "Sent", t[t.UploadProgress = 1] = "UploadProgress", t[t.ResponseHeader = 2] = "ResponseHeader", t[t.DownloadProgress = 3] = "DownloadProgress", t[t.Response = 4] = "Response", t[t.User = 5] = "User", t }({}); class Vs { constructor(t, e = 200, n = "OK") { this.headers = t.headers || new ks, this.status = void 0 !== t.status ? t.status : e, this.statusText = t.statusText || n, this.url = t.url || null, this.ok = this.status >= 200 && this.status < 300 } } class Bs extends Vs { constructor(t = {}) { super(t), this.type = Us.ResponseHeader } clone(t = {}) { return new Bs({ headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class qs extends Vs { constructor(t = {}) { super(t), this.type = Us.Response, this.body = void 0 !== t.body ? t.body : null } clone(t = {}) { return new qs({ body: void 0 !== t.body ? t.body : this.body, headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class $s extends Vs { constructor(t) { super(t, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, this.message = this.status >= 200 && this.status < 300 ? `Http failure during parsing for ${t.url || "(unknown url)"}` : `Http failure response for ${t.url || "(unknown url)"}: ${t.status} ${t.statusText}`, this.error = t.error || null } } function zs(t, e) { return { body: e, headers: t.headers, context: t.context, observe: t.observe, params: t.params, reportProgress: t.reportProgress, responseType: t.responseType, withCredentials: t.withCredentials } } let Hs = (() => { class t { constructor(t) { this.handler = t } request(t, e, n = {}) { let r; if (t instanceof js) r = t; else { let s, i; s = n.headers instanceof ks ? n.headers : new ks(n.headers), n.params && (i = n.params instanceof Ms ? n.params : new Ms({ fromObject: n.params })), r = new js(t, e, void 0 !== n.body ? n.body : null, { headers: s, context: n.context, params: i, reportProgress: n.reportProgress, responseType: n.responseType || "json", withCredentials: n.withCredentials }) } const s = (0, Cs.of)(r).pipe((0, xs.b)(t => this.handler.handle(t))); if (t instanceof js || "events" === n.observe) return s; const i = s.pipe((0, Os.h)(t => t instanceof qs)); switch (n.observe || "body") { case "body": switch (r.responseType) { case "arraybuffer": return i.pipe((0, Mt.U)(t => { if (null !== t.body && !(t.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer."); return t.body })); case "blob": return i.pipe((0, Mt.U)(t => { if (null !== t.body && !(t.body instanceof Blob)) throw new Error("Response is not a Blob."); return t.body })); case "text": return i.pipe((0, Mt.U)(t => { if (null !== t.body && "string" != typeof t.body) throw new Error("Response is not a string."); return t.body })); case "json": default: return i.pipe((0, Mt.U)(t => t.body)) }case "response": return i; default: throw new Error(`Unreachable: unhandled observe type ${n.observe}}`) } } delete(t, e = {}) { return this.request("DELETE", t, e) } get(t, e = {}) { return this.request("GET", t, e) } head(t, e = {}) { return this.request("HEAD", t, e) } jsonp(t, e) { return this.request("JSONP", t, { params: (new Ms).append(e, "JSONP_CALLBACK"), observe: "body", responseType: "json" }) } options(t, e = {}) { return this.request("OPTIONS", t, e) } patch(t, e, n = {}) { return this.request("PATCH", t, zs(n, e)) } post(t, e, n = {}) { return this.request("POST", t, zs(n, e)) } put(t, e, n = {}) { return this.request("PUT", t, zs(n, e)) } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(Ts)) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(); class Gs { constructor(t, e) { this.next = t, this.interceptor = e } handle(t) { return this.interceptor.intercept(t, this.next) } } const Zs = new r.OlP("HTTP_INTERCEPTORS"); let Ws = (() => { class t { intercept(t, e) { return e.handle(t) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(); const Ks = /^\)\]\}',?\n/; let Ys = (() => { class t { constructor(t) { this.xhrFactory = t } handle(t) { if ("JSONP" === t.method) throw new Error("Attempted to construct Jsonp request without HttpClientJsonpModule installed."); return new It.y(e => { const n = this.xhrFactory.build(); if (n.open(t.method, t.urlWithParams), t.withCredentials && (n.withCredentials = !0), t.headers.forEach((t, e) => n.setRequestHeader(t, e.join(","))), t.headers.has("Accept") || n.setRequestHeader("Accept", "application/json, text/plain, */*"), !t.headers.has("Content-Type")) { const e = t.detectContentTypeHeader(); null !== e && n.setRequestHeader("Content-Type", e) } if (t.responseType) { const e = t.responseType.toLowerCase(); n.responseType = "json" !== e ? e : "text" } const r = t.serializeBody(); let s = null; const i = () => { if (null !== s) return s; const e = 1223 === n.status ? 204 : n.status, r = n.statusText || "OK", i = new ks(n.getAllResponseHeaders()), o = function (t) { return "responseURL" in t && t.responseURL ? t.responseURL : /^X-Request-URL:/m.test(t.getAllResponseHeaders()) ? t.getResponseHeader("X-Request-URL") : null }(n) || t.url; return s = new Bs({ headers: i, status: e, statusText: r, url: o }), s }, o = () => { let { headers: r, status: s, statusText: o, url: a } = i(), l = null; 204 !== s && (l = void 0 === n.response ? n.responseText : n.response), 0 === s && (s = l ? 200 : 0); let c = s >= 200 && s < 300; if ("json" === t.responseType && "string" == typeof l) { const t = l; l = l.replace(Ks, ""); try { l = "" !== l ? JSON.parse(l) : null } catch (u) { l = t, c && (c = !1, l = { error: u, text: l }) } } c ? (e.next(new qs({ body: l, headers: r, status: s, statusText: o, url: a || void 0 })), e.complete()) : e.error(new $s({ error: l, headers: r, status: s, statusText: o, url: a || void 0 })) }, a = t => { const { url: r } = i(), s = new $s({ error: t, status: n.status || 0, statusText: n.statusText || "Unknown Error", url: r || void 0 }); e.error(s) }; let l = !1; const c = r => { l || (e.next(i()), l = !0); let s = { type: Us.DownloadProgress, loaded: r.loaded }; r.lengthComputable && (s.total = r.total), "text" === t.responseType && n.responseText && (s.partialText = n.responseText), e.next(s) }, u = t => { let n = { type: Us.UploadProgress, loaded: t.loaded }; t.lengthComputable && (n.total = t.total), e.next(n) }; return n.addEventListener("load", o), n.addEventListener("error", a), n.addEventListener("timeout", a), n.addEventListener("abort", a), t.reportProgress && (n.addEventListener("progress", c), null !== r && n.upload && n.upload.addEventListener("progress", u)), n.send(r), e.next({ type: Us.Sent }), () => { n.removeEventListener("error", a), n.removeEventListener("abort", a), n.removeEventListener("load", o), n.removeEventListener("timeout", a), t.reportProgress && (n.removeEventListener("progress", c), null !== r && n.upload && n.upload.removeEventListener("progress", u)), n.readyState !== n.DONE && n.abort() } }) } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(X)) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(); const Qs = new r.OlP("XSRF_COOKIE_NAME"), Js = new r.OlP("XSRF_HEADER_NAME"); class Xs { } let ti = (() => { class t { constructor(t, e, n) { this.doc = t, this.platform = e, this.cookieName = n, this.lastCookieString = "", this.lastToken = null, this.parseCount = 0 } getToken() { if ("server" === this.platform) return null; const t = this.doc.cookie || ""; return t !== this.lastCookieString && (this.parseCount++, this.lastToken = L(t, this.cookieName), this.lastCookieString = t), this.lastToken } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(o), r.LFG(r.Lbi), r.LFG(Qs)) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(), ei = (() => { class t { constructor(t, e) { this.tokenService = t, this.headerName = e } intercept(t, e) { const n = t.url.toLowerCase(); if ("GET" === t.method || "HEAD" === t.method || n.startsWith("http://") || n.startsWith("https://")) return e.handle(t); const r = this.tokenService.getToken(); return null === r || t.headers.has(this.headerName) || (t = t.clone({ headers: t.headers.set(this.headerName, r) })), e.handle(t) } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(Xs), r.LFG(Js)) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(), ni = (() => { class t { constructor(t, e) { this.backend = t, this.injector = e, this.chain = null } handle(t) { if (null === this.chain) { const t = this.injector.get(Zs, []); this.chain = t.reduceRight((t, e) => new Gs(t, e), this.backend) } return this.chain.handle(t) } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(Ps), r.LFG(r.zs3)) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(), ri = (() => { class t { static disable() { return { ngModule: t, providers: [{ provide: ei, useClass: Ws }] } } static withOptions(e = {}) { return { ngModule: t, providers: [e.cookieName ? { provide: Qs, useValue: e.cookieName } : [], e.headerName ? { provide: Js, useValue: e.headerName } : []] } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = r.oAB({ type: t }), t.\u0275inj = r.cJS({ providers: [ei, { provide: Zs, useExisting: ei, multi: !0 }, { provide: Xs, useClass: ti }, { provide: Qs, useValue: "XSRF-TOKEN" }, { provide: Js, useValue: "X-XSRF-TOKEN" }] }), t })(), si = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = r.oAB({ type: t }), t.\u0275inj = r.cJS({ providers: [Hs, { provide: Ts, useClass: ni }, Ys, { provide: Ps, useExisting: Ys }], imports: [[ri.withOptions({ cookieName: "XSRF-TOKEN", headerName: "X-XSRF-TOKEN" })]] }), t })(); var ii = n(2294), oi = n(1906), ai = n(5959), li = n(6673); class ci { call(t, e) { return e.subscribe(new ui(t)) } } class ui extends li.L { _next(t) { } } var hi = n(3103); class di { call(t, e) { return e.subscribe(new pi(t)) } } class pi extends li.L { constructor(t) { super(t) } _next(t) { this.destination.next(hi.P.createNext(t)) } _error(t) { const e = this.destination; e.next(hi.P.createError(t)), e.complete() } _complete() { const t = this.destination; t.next(hi.P.createComplete()), t.complete() } } var fi = n(7727), gi = n(7570); function mi(t, e, n, r) { return s => s.lift(new _i(t, e, n, r)) } class _i { constructor(t, e, n, r) { this.keySelector = t, this.elementSelector = e, this.durationSelector = n, this.subjectSelector = r } call(t, e) { return e.subscribe(new yi(t, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector)) } } class yi extends li.L { constructor(t, e, n, r, s) { super(t), this.keySelector = e, this.elementSelector = n, this.durationSelector = r, this.subjectSelector = s, this.groups = null, this.attemptedToUnsubscribe = !1, this.count = 0 } _next(t) { let e; try { e = this.keySelector(t) } catch (n) { return void this.error(n) } this._group(t, e) } _group(t, e) { let n = this.groups; n || (n = this.groups = new Map); let r, s = n.get(e); if (this.elementSelector) try { r = this.elementSelector(t) } catch (i) { this.error(i) } else r = t; if (!s) { s = this.subjectSelector ? this.subjectSelector() : new ai.xQ, n.set(e, s); const t = new bi(e, s, this); if (this.destination.next(t), this.durationSelector) { let t; try { t = this.durationSelector(new bi(e, s)) } catch (i) { return void this.error(i) } this.add(t.subscribe(new vi(e, s, this))) } } s.closed || s.next(r) } _error(t) { const e = this.groups; e && (e.forEach((e, n) => { e.error(t) }), e.clear()), this.destination.error(t) } _complete() { const t = this.groups; t && (t.forEach((t, e) => { t.complete() }), t.clear()), this.destination.complete() } removeGroup(t) { this.groups.delete(t) } unsubscribe() { this.closed || (this.attemptedToUnsubscribe = !0, 0 === this.count && super.unsubscribe()) } } class vi extends li.L { constructor(t, e, n) { super(e), this.key = t, this.group = e, this.parent = n } _next(t) { this.complete() } _unsubscribe() { const { parent: t, key: e } = this; this.key = this.parent = null, t && t.removeGroup(e) } } class bi extends It.y { constructor(t, e, n) { super(), this.key = t, this.groupSubject = e, this.refCountSubscription = n } _subscribe(t) { const e = new gi.w, { refCountSubscription: n, groupSubject: r } = this; return n && !n.closed && e.add(new wi(n)), e.add(r.subscribe(t)), e } } class wi extends gi.w { constructor(t) { super(), this.parent = t, t.count++ } unsubscribe() { const t = this.parent; t.closed || this.closed || (super.unsubscribe(), t.count -= 1, 0 === t.count && t.attemptedToUnsubscribe && t.unsubscribe()) } } var Ei = n(3982), Si = n(6882); function Ci(t, e) { return e ? n => n.pipe(Ci((n, r) => (0, At.D)(t(n, r)).pipe((0, Mt.U)((t, s) => e(n, t, r, s))))) : e => e.lift(new xi(t)) } class xi { constructor(t) { this.project = t } call(t, e) { return e.subscribe(new Oi(t, this.project)) } } class Oi extends Si.Ds { constructor(t, e) { super(t), this.project = e, this.hasSubscription = !1, this.hasCompleted = !1, this.index = 0 } _next(t) { this.hasSubscription || this.tryNext(t) } tryNext(t) { let e; const n = this.index++; try { e = this.project(t, n) } catch (r) { return void this.destination.error(r) } this.hasSubscription = !0, this._innerSub(e) } _innerSub(t) { const e = new Si.IY(this), n = this.destination; n.add(e); const r = (0, Si.ft)(t, e); r !== e && n.add(r) } _complete() { this.hasCompleted = !0, this.hasSubscription || this.destination.complete(), this.unsubscribe() } notifyNext(t) { this.destination.next(t) } notifyError(t) { this.destination.error(t) } notifyComplete() { this.hasSubscription = !1, this.hasCompleted && this.destination.complete() } } class Ti { call(t, e) { return e.subscribe(new Pi(t)) } } class Pi extends li.L { constructor(t) { super(t) } _next(t) { t.observe(this.destination) } } var ki = n(611); const Ai = { dispatch: !0, useEffectsErrorHandler: !0 }, Ii = "__@ngrx/effects_create__"; function Ri(t, e) { const n = t(), r = Object.assign(Object.assign({}, Ai), e); return Object.defineProperty(n, Ii, { value: r }), n } function Mi(t) { return Object.getOwnPropertyNames(t).filter(e => !(!t[e] || !t[e].hasOwnProperty(Ii)) && t[e][Ii].hasOwnProperty("dispatch")).map(e => Object.assign({ propertyName: e }, t[e][Ii])) } function Di(t) { return Object.getPrototypeOf(t) } const Li = "__@ngrx/effects__"; function Ni(t) { return (0, ii.qC)(Fi, Di)(t) } function Fi(t) { return function (t) { return t.constructor.hasOwnProperty(Li) }(t) ? t.constructor[Li] : [] } function ji(t, e, n = 10) { return t.pipe((0, fi.K)(r => (e && e.handleError(r), n <= 1 ? t : ji(t, e, n - 1)))) } let Ui = (() => { class t extends It.y { constructor(t) { super(), t && (this.source = t) } lift(e) { const n = new t; return n.source = this, n.operator = e, n } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(ii.Y$)) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(); function Vi(...t) { return (0, Os.h)(e => t.some(t => "string" == typeof t ? t === e.type : t.type === e.type)) } function Bi(t) { return qi(t, "ngrxOnInitEffects") } function qi(t, e) { return t && e in t && "function" == typeof t[e] } const $i = new r.OlP("@ngrx/effects Internal Root Guard"), zi = new r.OlP("@ngrx/effects User Provided Effects"), Hi = new r.OlP("@ngrx/effects Internal Root Effects"), Gi = new r.OlP("@ngrx/effects Root Effects"), Zi = new r.OlP("@ngrx/effects Internal Feature Effects"), Wi = new r.OlP("@ngrx/effects Feature Effects"), Ki = new r.OlP("@ngrx/effects Effects Error Handler"); let Yi = (() => { class t extends ai.xQ { constructor(t, e) { super(), this.errorHandler = t, this.effectsErrorHandler = e } addEffects(t) { this.next(t) } toActions() { return this.pipe(mi(Di), (0, Ei.zg)(t => t.pipe(mi(Qi))), (0, Ei.zg)(t => { const e = t.pipe(Ci(t => { return (e = this.errorHandler, n = this.effectsErrorHandler, t => { const r = function (t, e, n) { const r = Di(t).constructor.name, s = (i = t, [Ni, Mi].reduce((t, e) => t.concat(e(i)), [])).map(({ propertyName: s, dispatch: i, useEffectsErrorHandler: o }) => { const a = "function" == typeof t[s] ? t[s]() : t[s], l = o ? n(a, e) : a; return !1 === i ? l.pipe(function (t) { return t.lift(new ci) }) : l.pipe(function (t) { return t.lift(new di) }).pipe((0, Mt.U)(e => ({ effect: t[s], notification: e, propertyName: s, sourceName: r, sourceInstance: t }))) }); var i; return (0, oi.T)(...s) }(t, e, n); return qi(t, "ngrxOnRunEffects") ? t.ngrxOnRunEffects(r) : r })(t); var e, n }), (0, Mt.U)(t => (function (t, e) { if ("N" === t.notification.kind) { const n = t.notification.value; !function (t) { return "function" != typeof t && t && t.type && "string" == typeof t.type }(n) && e.handleError(new Error(`Effect ${function ({ propertyName: t, sourceInstance: e, sourceName: n }) { const r = "function" == typeof e[t]; return `"${n}.${String(t)}${r ? "()" : ""}"` }(t)} dispatched an invalid action: ${function (t) { try { return JSON.stringify(t) } catch (e) { return t } }(n)}`)) } }(t, this.errorHandler), t.notification)), (0, Os.h)(t => "N" === t.kind && null != t.value), function (t) { return t.lift(new Ti) }), n = t.pipe((0, ki.q)(1), (0, Os.h)(Bi), (0, Mt.U)(t => t.ngrxOnInitEffects())); return (0, oi.T)(e, n) })) } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(r.qLn), r.LFG(Ki)) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(); function Qi(t) { return qi(t, "ngrxOnIdentifyEffects") ? t.ngrxOnIdentifyEffects() : "" } let Ji = (() => { class t { constructor(t, e) { this.effectSources = t, this.store = e, this.effectsSubscription = null } start() { this.effectsSubscription || (this.effectsSubscription = this.effectSources.toActions().subscribe(this.store)) } ngOnDestroy() { this.effectsSubscription && (this.effectsSubscription.unsubscribe(), this.effectsSubscription = null) } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(Yi), r.LFG(ii.yh)) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(); const Xi = "@ngrx/effects/init"; (0, ii.PH)(Xi); let to = (() => { class t { constructor(t, e, n, r, s, i, o) { this.sources = t, e.start(), r.forEach(e => t.addEffects(e)), n.dispatch({ type: Xi }) } addEffects(t) { this.sources.addEffects(t) } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(Yi), r.LFG(Ji), r.LFG(ii.yh), r.LFG(Gi), r.LFG(ii.cr, 8), r.LFG(ii.CK, 8), r.LFG($i, 8)) }, t.\u0275mod = r.oAB({ type: t }), t.\u0275inj = r.cJS({}), t })(), eo = (() => { class t { constructor(t, e, n, r) { e.forEach(e => e.forEach(e => t.addEffects(e))) } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(to), r.LFG(Wi), r.LFG(ii.cr, 8), r.LFG(ii.CK, 8)) }, t.\u0275mod = r.oAB({ type: t }), t.\u0275inj = r.cJS({}), t })(), no = (() => { class t { static forFeature(t = []) { return { ngModule: eo, providers: [t, { provide: Zi, multi: !0, useValue: t }, { provide: zi, multi: !0, useValue: [] }, { provide: Wi, multi: !0, useFactory: ro, deps: [r.zs3, Zi, zi] }] } } static forRoot(t = []) { return { ngModule: to, providers: [{ provide: Ki, useValue: ji }, Ji, Yi, Ui, t, { provide: Hi, useValue: [t] }, { provide: $i, useFactory: so, deps: [[Ji, new r.FiY, new r.tp0], [Hi, new r.PiD]] }, { provide: zi, multi: !0, useValue: [] }, { provide: Gi, useFactory: ro, deps: [r.zs3, Hi, zi] }] } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = r.oAB({ type: t }), t.\u0275inj = r.cJS({}), t })(); function ro(t, e, n) { const r = []; for (const s of e) r.push(...s); for (const s of n) r.push(...s); return function (t, e) { return e.map(e => t.get(e)) }(t, r) } function so(t, e) { if ((1 !== e.length || 0 !== e[0].length) && t) throw new TypeError("EffectsModule.forRoot() called twice. Feature modules should use EffectsModule.forFeature() instead."); return "guarded" } var io = n(9474); const oo = "[poke]s load", ao = "[poke] load", lo = "[poke]s loading", co = "[poke]s error", uo = "[poke] loaded", ho = "[poke]s loaded", po = "[poke] remove", fo = "[poke] removed", go = "[poke] saved", mo = "[poke] added", _o = "[poke] updated", yo = "[action] done", vo = "[action] doned"; class bo { constructor(t = null) { this.filterBy = t, this.type = oo } } class wo { constructor(t = "") { this.pokeName = t, this.type = ao } } class Eo { constructor(t) { this.pokeId = t, this.type = po } } class So { constructor() { this.type = yo } } class Co { constructor(t) { this.poke = t, this.type = go } } class xo { constructor(t = !0) { this.isLoading = t, this.type = lo } } const Oo = { pokes: [], poke: null, isLoading: !1, error: "", isDone: !1 }, To = { pokeState: function (t = Oo, e) { switch (e.type) { case lo: { const { isLoading: n } = e; return Object.assign(Object.assign({}, t), { isLoading: n, error: "" }) } case co: { const { error: n } = e; return console.log("Reducer: Setting poke error", n), Object.assign(Object.assign({}, t), { error: n, isLoading: !1 }) } case ho: { const { pokes: n } = e; return console.log(`Reducer: Setting loaded pokes (${n.length}) pokemons`), Object.assign(Object.assign({}, t), { pokes: n, isLoading: !1, error: "" }) } case uo: { const { poke: n } = e; return Object.assign(Object.assign({}, t), { poke: n, error: "" }) } case vo: return Object.assign(Object.assign({}, t), { isDone: e.isDone }); case fo: { const { pokeId: n } = e; console.log("Reducer: Removing item:", n); const r = t.pokes.filter(t => t.id !== n); return Object.assign(Object.assign({}, t), { pokes: r, error: "", isDone: !0 }) } case mo: { const { poke: n } = e, r = [...t.pokes, n]; return Object.assign(Object.assign({}, t), { pokes: r, error: "" }) } case _o: { const { poke: n } = e, r = t.pokes.map(t => t.id === n.id ? n : t); return Object.assign(Object.assign({}, t), { pokes: r, poke: n, error: "" }) } default: return t } } }, Po = []; function ko() { } var Ao = n(5024); function Io(t, e, n) { return function (r) { return r.lift(new Ro(t, e, n)) } } class Ro { constructor(t, e, n) { this.nextOrObserver = t, this.error = e, this.complete = n } call(t, e) { return e.subscribe(new Mo(t, this.nextOrObserver, this.error, this.complete)) } } class Mo extends li.L { constructor(t, e, n, r) { super(t), this._tapNext = ko, this._tapError = ko, this._tapComplete = ko, this._tapError = n || ko, this._tapComplete = r || ko, (0, Ao.m)(e) ? (this._context = this, this._tapNext = e) : e && (this._context = e, this._tapNext = e.next || ko, this._tapError = e.error || ko, this._tapComplete = e.complete || ko) } _next(t) { try { this._tapNext.call(this._context, t) } catch (e) { return void this.destination.error(e) } this.destination.next(t) } _error(t) { try { this._tapError.call(this._context, t) } catch (t) { return void this.destination.error(t) } this.destination.error(t) } _complete() { try { this._tapComplete.call(this._context) } catch (t) { return void this.destination.error(t) } return this.destination.complete() } } var Do = n(4689); function Lo(t, e, n, r, s, i, o) { try { var a = t[i](o), l = a.value } catch (c) { return void n(c) } a.done ? e(l) : Promise.resolve(l).then(r, s) } function No(t) { return function () { var e = this, n = arguments; return new Promise(function (r, s) { var i = t.apply(e, n); function o(t) { Lo(i, r, s, o, a, "next", t) } function a(t) { Lo(i, r, s, o, a, "throw", t) } o(void 0) }) } } const Fo = { query: jo, get: function (t, e) { return Vo.apply(this, arguments) }, post: function (t, e) { return Bo.apply(this, arguments) }, put: function (t, e) { return qo.apply(this, arguments) }, remove: function (t, e) { return $o.apply(this, arguments) }, makeId: Ho }; function jo(t) { return Uo.apply(this, arguments) } function Uo() { return (Uo = No(function* (t, e = null, n = 500) { var r = JSON.parse(localStorage.getItem(t) || "null") || []; if (n) { const t = { name: (null == e ? void 0 : e.name) || "", type: (null == e ? void 0 : e.type) || "" }, s = new RegExp(t.name, "i"), i = r.filter(e => { var n, r; return s.test(e.name) && (null === (r = null === (n = e.types[0]) || void 0 === n ? void 0 : n.type) || void 0 === r ? void 0 : r.name.includes(t.type)) }); return new Promise(t => setTimeout(t, n, i)) } return yield r })).apply(this, arguments) } function Vo() { return (Vo = No(function* (t, e) { const n = yield jo(t); console.log("DDDD", n); const r = n.find(t => t.name === e); if (!r) throw new Error(`Cannot get, Pokemon ${e} of type: ${t} does not exist`); return r })).apply(this, arguments) } function Bo() { return (Bo = No(function* (t, e) { e = Object.assign(Object.assign({}, e), { id: Ho() }); const n = yield jo(t); return n.push(e), zo(t, n), e })).apply(this, arguments) } function qo() { return (qo = No(function* (t, e) { const n = yield jo(t), r = n.findIndex(t => t.id === e.id); return n[r] = e, zo(t, n), e })).apply(this, arguments) } function $o() { return ($o = No(function* (t, e) { const n = yield jo(t); console.log("STORAGE", n); const r = n.findIndex(t => t.id === e); if (console.log("STORAGE", r), -1 === r) throw new Error(`Cannot remove, item ${e} of type: ${t} does not exist`); return n.splice(r, 1), zo(t, n), !0 })).apply(this, arguments) } function zo(t, e) { localStorage.setItem(t, JSON.stringify(e)) } function Ho(t = 5) { for (var e = "", n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", r = 0; r < t; r++)e += n.charAt(Math.floor(Math.random() * n.length)); return e } let Go = (() => { class t { constructor(t, e) { this.http = t, this.store = e, this.KEY = "pokemon"; const n = JSON.parse(localStorage.getItem(this.KEY) || "null"); n && 0 !== n.length || this.getDataFromApi(10, "1") } query(t = null) { this.store.dispatch(new xo); let e = Fo.query(this.KEY, t); return (0, At.D)(e) } getByName(t) { return console.log("PokeService: Return pokemon ===> effect"), (0, At.D)(Fo.get(this.KEY, t)) } remove(t) { return console.log("PokeService: Removing pokemon ===> effect"), (0, At.D)(Fo.remove(this.KEY, t)) } save(t) { const e = Fo[t.id ? "put" : "post"](this.KEY, t); return console.log("PokeService: Saving Pokemon ===> effect"), (0, At.D)(e) } getDataFromApi(t, e) { var n = this; return No(function* () { const r = `https://pokeapi.co/api/v2/pokemon?limit=${t}&offset=${e}`, s = []; (yield n.http.get(r).toPromise()).results.map(function () { var t = No(function* (t) { const e = yield n.http.get(t.url).toPromise(); s.push(e), s.sort((t, e) => t.id - e.id), localStorage.setItem(n.KEY, JSON.stringify(s)) }); return function (e) { return t.apply(this, arguments) } }()) })() } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(Hs), r.LFG(ii.yh)) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(), Zo = (() => { class t { constructor(t, e) { this.actions$ = t, this.pokeService = e, this.isDone$ = Ri(() => this.actions$.pipe(Vi(yo), (0, Mt.U)(() => ({ type: vo, isDone: !1 })))), this.loadPokes$ = Ri(() => this.actions$.pipe(Vi(oo), Io(() => { console.log(this.actions$) }), (0, Do.w)(t => this.pokeService.query(t.filterBy).pipe((0, Mt.U)(t => ({ type: ho, pokes: t })), Io(() => console.log("here", t)), (0, fi.K)(t => (console.log("Effect: Caught error ===> Reducer", t), (0, Cs.of)({ type: co, error: t.toString() }))))))), this.loadPoke$ = Ri(() => this.actions$.pipe(Vi(ao), Io(() => console.log("Effects: load pokemon ==> service")), (0, Do.w)(t => this.pokeService.getByName(t.pokeName).pipe(Io(() => console.log("Effects: Got pokemon from service ===> Reducer")), (0, Mt.U)(t => ({ type: uo, poke: t })), (0, fi.K)(t => (console.log("Effect: Caught error ===> Reducer", t), (0, Cs.of)({ type: co, error: t.toString() }))))))), this.removePokes$ = Ri(() => this.actions$.pipe(Vi(po), (0, Do.w)(t => this.pokeService.remove(t.pokeId).pipe(Io(t => console.log("PIPE", t)), Io(() => console.log("Effects: poke removed by service ===> Reducer")), (0, Mt.U)(() => ({ type: fo, pokeId: t.pokeId })), (0, fi.K)(t => (console.log("Effect: Caught error ===> Reducer", t), (0, Cs.of)({ type: co, error: t.toString() }))))))), this.savePoke$ = Ri(() => this.actions$.pipe(Vi(go), (0, Do.w)(t => this.pokeService.save(t.poke).pipe(Io(() => console.log("Effects: poke saved by service, inform the ===> Reducer")), (0, Mt.U)(e => ({ type: t.poke.id ? _o : mo, poke: e })), (0, fi.K)(t => (console.log("Effect: Caught error ===> Reducer", t), (0, Cs.of)({ type: co, error: t.toString() }))))))) } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(Ui), r.LFG(Go)) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(); function Wo(t, e) { if (1 & t) { var n = r.EpF(); r.TgZ(0, "a", 11), r.NdJ("keyup.enter", function () { return r.CHM(n), r.oxw(3), r.MAs(1).previous() })("click", function () { return r.CHM(n), r.oxw(3), r.MAs(1).previous() }), r._uU(1), r.TgZ(2, "span", 12), r._uU(3), r.qZA(), r.qZA() } if (2 & t) { var s = r.oxw(3); r.uIk("aria-label", s.previousLabel + " " + s.screenReaderPageLabel), r.xp6(1), r.hij(" ", s.previousLabel, " "), r.xp6(2), r.Oqu(s.screenReaderPageLabel) } } function Ko(t, e) { if (1 & t && (r.TgZ(0, "span"), r._uU(1), r.TgZ(2, "span", 12), r._uU(3), r.qZA(), r.qZA()), 2 & t) { var n = r.oxw(3); r.xp6(1), r.hij(" ", n.previousLabel, " "), r.xp6(2), r.Oqu(n.screenReaderPageLabel) } } function Yo(t, e) { if (1 & t && (r.TgZ(0, "li", 8), r.YNc(1, Wo, 4, 3, "a", 9), r.YNc(2, Ko, 4, 2, "span", 10), r.qZA()), 2 & t) { r.oxw(2); var n = r.MAs(1); r.ekj("disabled", n.isFirstPage()), r.xp6(1), r.Q6J("ngIf", 1 < n.getCurrent()), r.xp6(1), r.Q6J("ngIf", n.isFirstPage()) } } function Qo(t, e) { if (1 & t) { var n = r.EpF(); r.TgZ(0, "a", 11), r.NdJ("keyup.enter", function () { r.CHM(n); var t = r.oxw().$implicit; return r.oxw(2), r.MAs(1).setCurrent(t.value) })("click", function () { r.CHM(n); var t = r.oxw().$implicit; return r.oxw(2), r.MAs(1).setCurrent(t.value) }), r.TgZ(1, "span", 12), r._uU(2), r.qZA(), r.TgZ(3, "span"), r._uU(4), r.ALo(5, "number"), r.qZA(), r.qZA() } if (2 & t) { var s = r.oxw().$implicit, i = r.oxw(2); r.xp6(2), r.hij("", i.screenReaderPageLabel, " "), r.xp6(2), r.Oqu("..." === s.label ? s.label : r.xi3(5, 2, s.label, "")) } } function Jo(t, e) { if (1 & t && (r.ynx(0), r.TgZ(1, "span", 12), r._uU(2), r.qZA(), r.TgZ(3, "span"), r._uU(4), r.ALo(5, "number"), r.qZA(), r.BQk()), 2 & t) { var n = r.oxw().$implicit, s = r.oxw(2); r.xp6(2), r.hij("", s.screenReaderCurrentLabel, " "), r.xp6(2), r.Oqu("..." === n.label ? n.label : r.xi3(5, 2, n.label, "")) } } function Xo(t, e) { if (1 & t && (r.TgZ(0, "li"), r.YNc(1, Qo, 6, 5, "a", 9), r.YNc(2, Jo, 6, 5, "ng-container", 10), r.qZA()), 2 & t) { var n = e.$implicit; r.oxw(2); var s = r.MAs(1); r.ekj("current", s.getCurrent() === n.value)("ellipsis", "..." === n.label), r.xp6(1), r.Q6J("ngIf", s.getCurrent() !== n.value), r.xp6(1), r.Q6J("ngIf", s.getCurrent() === n.value) } } function ta(t, e) { if (1 & t) { var n = r.EpF(); r.TgZ(0, "a", 11), r.NdJ("keyup.enter", function () { return r.CHM(n), r.oxw(3), r.MAs(1).next() })("click", function () { return r.CHM(n), r.oxw(3), r.MAs(1).next() }), r._uU(1), r.TgZ(2, "span", 12), r._uU(3), r.qZA(), r.qZA() } if (2 & t) { var s = r.oxw(3); r.uIk("aria-label", s.nextLabel + " " + s.screenReaderPageLabel), r.xp6(1), r.hij(" ", s.nextLabel, " "), r.xp6(2), r.Oqu(s.screenReaderPageLabel) } } function ea(t, e) { if (1 & t && (r.TgZ(0, "span"), r._uU(1), r.TgZ(2, "span", 12), r._uU(3), r.qZA(), r.qZA()), 2 & t) { var n = r.oxw(3); r.xp6(1), r.hij(" ", n.nextLabel, " "), r.xp6(2), r.Oqu(n.screenReaderPageLabel) } } function na(t, e) { if (1 & t && (r.TgZ(0, "li", 13), r.YNc(1, ta, 4, 3, "a", 9), r.YNc(2, ea, 4, 2, "span", 10), r.qZA()), 2 & t) { r.oxw(2); var n = r.MAs(1); r.ekj("disabled", n.isLastPage()), r.xp6(1), r.Q6J("ngIf", !n.isLastPage()), r.xp6(1), r.Q6J("ngIf", n.isLastPage()) } } function ra(t, e) { if (1 & t && (r.TgZ(0, "ul", 3), r.YNc(1, Yo, 3, 4, "li", 4), r.TgZ(2, "li", 5), r._uU(3), r.qZA(), r.YNc(4, Xo, 3, 6, "li", 6), r.YNc(5, na, 3, 4, "li", 7), r.qZA()), 2 & t) { var n = r.oxw(), s = r.MAs(1); r.ekj("responsive", n.responsive), r.uIk("aria-label", n.screenReaderPaginationLabel), r.xp6(1), r.Q6J("ngIf", n.directionLinks), r.xp6(2), r.AsE(" ", s.getCurrent(), " / ", s.getLastPage(), " "), r.xp6(1), r.Q6J("ngForOf", s.pages)("ngForTrackBy", n.trackByIndex), r.xp6(1), r.Q6J("ngIf", n.directionLinks) } } var sa = function () { function t() { this.change = new r.vpe, this.instances = {}, this.DEFAULT_ID = "DEFAULT_PAGINATION_ID" } return t.prototype.defaultId = function () { return this.DEFAULT_ID }, t.prototype.register = function (t) { return null == t.id && (t.id = this.DEFAULT_ID), this.instances[t.id] ? this.updateInstance(t) : (this.instances[t.id] = t, !0) }, t.prototype.updateInstance = function (t) { var e = !1; for (var n in this.instances[t.id]) t[n] !== this.instances[t.id][n] && (this.instances[t.id][n] = t[n], e = !0); return e }, t.prototype.getCurrentPage = function (t) { if (this.instances[t]) return this.instances[t].currentPage }, t.prototype.setCurrentPage = function (t, e) { if (this.instances[t]) { var n = this.instances[t]; e <= Math.ceil(n.totalItems / n.itemsPerPage) && 1 <= e && (this.instances[t].currentPage = e, this.change.emit(t)) } }, t.prototype.setTotalItems = function (t, e) { this.instances[t] && 0 <= e && (this.instances[t].totalItems = e, this.change.emit(t)) }, t.prototype.setItemsPerPage = function (t, e) { this.instances[t] && (this.instances[t].itemsPerPage = e, this.change.emit(t)) }, t.prototype.getInstance = function (t) { return void 0 === t && (t = this.DEFAULT_ID), this.instances[t] ? this.clone(this.instances[t]) : {} }, t.prototype.clone = function (t) { var e = {}; for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]); return e }, t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = r.Yz7({ token: t, factory: function (e) { return t.\u0275fac(e) } }), t }(), ia = function (t, e) { if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(t, e) }, oa = Number.MAX_SAFE_INTEGER, aa = function () { function t(t) { this.service = t, this.state = {} } return t.prototype.transform = function (t, e) { if (!(t instanceof Array)) { var n = e.id || this.service.defaultId(); return this.state[n] ? this.state[n].slice : t } var r, s, i = e.totalItems && e.totalItems !== t.length, o = this.createInstance(t, e), a = o.id, l = o.itemsPerPage, c = this.service.register(o); if (!i && t instanceof Array) { if (this.stateIsIdentical(a, t, r = (o.currentPage - 1) * (l = +l || oa), s = r + l)) return this.state[a].slice; var u = t.slice(r, s); return this.saveState(a, t, u, r, s), this.service.change.emit(a), u } return c && this.service.change.emit(a), this.saveState(a, t, t, r, s), t }, t.prototype.createInstance = function (t, e) { return this.checkConfig(e), { id: null != e.id ? e.id : this.service.defaultId(), itemsPerPage: +e.itemsPerPage || 0, currentPage: +e.currentPage || 1, totalItems: +e.totalItems || t.length } }, t.prototype.checkConfig = function (t) { var e = ["itemsPerPage", "currentPage"].filter(function (e) { return !(e in t) }); if (0 < e.length) throw new Error("PaginatePipe: Argument is missing the following required properties: " + e.join(", ")) }, t.prototype.saveState = function (t, e, n, r, s) { this.state[t] = { collection: e, size: e.length, slice: n, start: r, end: s } }, t.prototype.stateIsIdentical = function (t, e, n, r) { var s = this.state[t]; return !!s && !(s.size !== e.length || s.start !== n || s.end !== r) && s.slice.every(function (t, r) { return t === e[n + r] }) }, (t = function (t, e, n, r) { var s, i = arguments.length, o = i < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--)(s = t[a]) && (o = (i < 3 ? s(o) : i > 3 ? s(e, n, o) : s(e, n)) || o); return i > 3 && o && Object.defineProperty(e, n, o), o }([ia("design:paramtypes", [sa])], t)).\u0275fac = function (e) { return new (e || t)(r.Y36(sa, 16)) }, t.\u0275pipe = r.Yjl({ name: "paginate", type: t, pure: !1 }), t }(), la = function (t, e, n, r) { var s, i = arguments.length, o = i < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--)(s = t[a]) && (o = (i < 3 ? s(o) : i > 3 ? s(e, n, o) : s(e, n)) || o); return i > 3 && o && Object.defineProperty(e, n, o), o }, ca = function (t, e) { if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(t, e) }; function ua(t) { return !!t && "false" !== t } var ha = function () { function t() { this.maxSize = 7, this.previousLabel = "Previous", this.nextLabel = "Next", this.screenReaderPaginationLabel = "Pagination", this.screenReaderPageLabel = "page", this.screenReaderCurrentLabel = "You're on page", this.pageChange = new r.vpe, this.pageBoundsCorrection = new r.vpe, this._directionLinks = !0, this._autoHide = !1, this._responsive = !1 } return Object.defineProperty(t.prototype, "directionLinks", { get: function () { return this._directionLinks }, set: function (t) { this._directionLinks = ua(t) }, enumerable: !0, configurable: !0 }), Object.defineProperty(t.prototype, "autoHide", { get: function () { return this._autoHide }, set: function (t) { this._autoHide = ua(t) }, enumerable: !0, configurable: !0 }), Object.defineProperty(t.prototype, "responsive", { get: function () { return this._responsive }, set: function (t) { this._responsive = ua(t) }, enumerable: !0, configurable: !0 }), t.prototype.trackByIndex = function (t) { return t }, la([(0, r.IIB)(), ca("design:type", String)], t.prototype, "id", void 0), la([(0, r.IIB)(), ca("design:type", Number)], t.prototype, "maxSize", void 0), la([(0, r.IIB)(), ca("design:type", Boolean), ca("design:paramtypes", [Boolean])], t.prototype, "directionLinks", null), la([(0, r.IIB)(), ca("design:type", Boolean), ca("design:paramtypes", [Boolean])], t.prototype, "autoHide", null), la([(0, r.IIB)(), ca("design:type", Boolean), ca("design:paramtypes", [Boolean])], t.prototype, "responsive", null), la([(0, r.IIB)(), ca("design:type", String)], t.prototype, "previousLabel", void 0), la([(0, r.IIB)(), ca("design:type", String)], t.prototype, "nextLabel", void 0), la([(0, r.IIB)(), ca("design:type", String)], t.prototype, "screenReaderPaginationLabel", void 0), la([(0, r.IIB)(), ca("design:type", String)], t.prototype, "screenReaderPageLabel", void 0), la([(0, r.IIB)(), ca("design:type", String)], t.prototype, "screenReaderCurrentLabel", void 0), la([(0, r.r_U)(), ca("design:type", r.vpe)], t.prototype, "pageChange", void 0), la([(0, r.r_U)(), ca("design:type", r.vpe)], t.prototype, "pageBoundsCorrection", void 0), t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = r.Xpm({ type: t, selectors: [["pagination-controls"]], inputs: { maxSize: "maxSize", previousLabel: "previousLabel", nextLabel: "nextLabel", screenReaderPaginationLabel: "screenReaderPaginationLabel", screenReaderPageLabel: "screenReaderPageLabel", screenReaderCurrentLabel: "screenReaderCurrentLabel", directionLinks: "directionLinks", autoHide: "autoHide", responsive: "responsive", id: "id" }, outputs: { pageChange: "pageChange", pageBoundsCorrection: "pageBoundsCorrection" }, decls: 3, vars: 3, consts: [[3, "id", "maxSize", "pageChange", "pageBoundsCorrection"], ["p", "paginationApi"], ["class", "ngx-pagination", 3, "responsive", 4, "ngIf"], [1, "ngx-pagination"], ["class", "pagination-previous", 3, "disabled", 4, "ngIf"], [1, "small-screen"], [3, "current", "ellipsis", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "pagination-next", 3, "disabled", 4, "ngIf"], [1, "pagination-previous"], ["tabindex", "0", 3, "keyup.enter", "click", 4, "ngIf"], [4, "ngIf"], ["tabindex", "0", 3, "keyup.enter", "click"], [1, "show-for-sr"], [1, "pagination-next"]], template: function (t, e) { if (1 & t && (r.TgZ(0, "pagination-template", 0, 1), r.NdJ("pageChange", function (t) { return e.pageChange.emit(t) })("pageBoundsCorrection", function (t) { return e.pageBoundsCorrection.emit(t) }), r.YNc(2, ra, 6, 9, "ul", 2), r.qZA()), 2 & t) { var n = r.MAs(1); r.Q6J("id", e.id)("maxSize", e.maxSize), r.xp6(2), r.Q6J("ngIf", !(e.autoHide && n.pages.length <= 1)) } }, directives: function () { return [fa, U, F] }, pipes: function () { return [W] }, styles: ["\n.ngx-pagination {\n  margin-left: 0;\n  margin-bottom: 1rem; }\n  .ngx-pagination::before, .ngx-pagination::after {\n    content: ' ';\n    display: table; }\n  .ngx-pagination::after {\n    clear: both; }\n  .ngx-pagination li {\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    -ms-user-select: none;\n    margin-right: 0.0625rem;\n    border-radius: 0; }\n  .ngx-pagination li {\n    display: inline-block; }\n  .ngx-pagination a,\n  .ngx-pagination button {\n    color: #0a0a0a; \n    display: block;\n    padding: 0.1875rem 0.625rem;\n    border-radius: 0; }\n    .ngx-pagination a:hover,\n    .ngx-pagination button:hover {\n      background: #e6e6e6; }\n  .ngx-pagination .current {\n    padding: 0.1875rem 0.625rem;\n    background: #2199e8;\n    color: #fefefe;\n    cursor: default; }\n  .ngx-pagination .disabled {\n    padding: 0.1875rem 0.625rem;\n    color: #cacaca;\n    cursor: default; } \n    .ngx-pagination .disabled:hover {\n      background: transparent; }\n  .ngx-pagination a, .ngx-pagination button {\n    cursor: pointer; }\n\n.ngx-pagination .pagination-previous a::before,\n.ngx-pagination .pagination-previous.disabled::before { \n  content: '\xab';\n  display: inline-block;\n  margin-right: 0.5rem; }\n\n.ngx-pagination .pagination-next a::after,\n.ngx-pagination .pagination-next.disabled::after {\n  content: '\xbb';\n  display: inline-block;\n  margin-left: 0.5rem; }\n\n.ngx-pagination .show-for-sr {\n  position: absolute !important;\n  width: 1px;\n  height: 1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0); }\n.ngx-pagination .small-screen {\n  display: none; }\n@media screen and (max-width: 601px) {\n  .ngx-pagination.responsive .small-screen {\n    display: inline-block; } \n  .ngx-pagination.responsive li:not(.small-screen):not(.pagination-previous):not(.pagination-next) {\n    display: none; }\n}\n  "], encapsulation: 2, changeDetection: 0 }), t }(), da = function (t, e, n, r) { var s, i = arguments.length, o = i < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--)(s = t[a]) && (o = (i < 3 ? s(o) : i > 3 ? s(e, n, o) : s(e, n)) || o); return i > 3 && o && Object.defineProperty(e, n, o), o }, pa = function (t, e) { if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(t, e) }, fa = function () { function t(t, e) { var n = this; this.service = t, this.changeDetectorRef = e, this.maxSize = 7, this.pageChange = new r.vpe, this.pageBoundsCorrection = new r.vpe, this.pages = [], this.changeSub = this.service.change.subscribe(function (t) { n.id === t && (n.updatePageLinks(), n.changeDetectorRef.markForCheck(), n.changeDetectorRef.detectChanges()) }) } return t.prototype.ngOnInit = function () { void 0 === this.id && (this.id = this.service.defaultId()), this.updatePageLinks() }, t.prototype.ngOnChanges = function (t) { this.updatePageLinks() }, t.prototype.ngOnDestroy = function () { this.changeSub.unsubscribe() }, t.prototype.previous = function () { this.checkValidId(), this.setCurrent(this.getCurrent() - 1) }, t.prototype.next = function () { this.checkValidId(), this.setCurrent(this.getCurrent() + 1) }, t.prototype.isFirstPage = function () { return 1 === this.getCurrent() }, t.prototype.isLastPage = function () { return this.getLastPage() === this.getCurrent() }, t.prototype.setCurrent = function (t) { this.pageChange.emit(t) }, t.prototype.getCurrent = function () { return this.service.getCurrentPage(this.id) }, t.prototype.getLastPage = function () { var t = this.service.getInstance(this.id); return t.totalItems < 1 ? 1 : Math.ceil(t.totalItems / t.itemsPerPage) }, t.prototype.getTotalItems = function () { return this.service.getInstance(this.id).totalItems }, t.prototype.checkValidId = function () { null == this.service.getInstance(this.id).id && console.warn('PaginationControlsDirective: the specified id "' + this.id + '" does not match any registered PaginationInstance') }, t.prototype.updatePageLinks = function () { var t = this, e = this.service.getInstance(this.id), n = this.outOfBoundCorrection(e); n !== e.currentPage ? setTimeout(function () { t.pageBoundsCorrection.emit(n), t.pages = t.createPageArray(e.currentPage, e.itemsPerPage, e.totalItems, t.maxSize) }) : this.pages = this.createPageArray(e.currentPage, e.itemsPerPage, e.totalItems, this.maxSize) }, t.prototype.outOfBoundCorrection = function (t) { var e = Math.ceil(t.totalItems / t.itemsPerPage); return e < t.currentPage && 0 < e ? e : t.currentPage < 1 ? 1 : t.currentPage }, t.prototype.createPageArray = function (t, e, n, r) { r = +r; for (var s = [], i = Math.max(Math.ceil(n / e), 1), o = Math.ceil(r / 2), a = t <= o, l = i - o < t, c = !a && !l, u = r < i, h = 1; h <= i && h <= r;) { var d = this.calculatePageNumber(h, t, r, i); s.push({ label: u && (2 === h && (c || l) || h === r - 1 && (c || a)) ? "..." : d, value: d }), h++ } return s }, t.prototype.calculatePageNumber = function (t, e, n, r) { var s = Math.ceil(n / 2); return t === n ? r : 1 === t ? t : n < r ? r - s < e ? r - n + t : s < e ? e - s + t : t : t }, da([(0, r.IIB)(), pa("design:type", String)], t.prototype, "id", void 0), da([(0, r.IIB)(), pa("design:type", Number)], t.prototype, "maxSize", void 0), da([(0, r.r_U)(), pa("design:type", r.vpe)], t.prototype, "pageChange", void 0), da([(0, r.r_U)(), pa("design:type", r.vpe)], t.prototype, "pageBoundsCorrection", void 0), (t = da([pa("design:paramtypes", [sa, r.sBO])], t)).\u0275fac = function (e) { return new (e || t)(r.Y36(sa), r.Y36(r.sBO)) }, t.\u0275dir = r.lG2({ type: t, selectors: [["pagination-template"], ["", "pagination-template", ""]], inputs: { maxSize: "maxSize", id: "id" }, outputs: { pageChange: "pageChange", pageBoundsCorrection: "pageBoundsCorrection" }, exportAs: ["paginationApi"], features: [r.TTD] }), t }(), ga = function () { function t() { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = r.oAB({ type: t }), t.\u0275inj = r.cJS({ providers: [sa], imports: [[K]] }), t }(), ma = n(8512), _a = n(6163), ya = n(9829), va = n(7e3), ba = n(9342); const wa = {}; class Ea { constructor(t) { this.resultSelector = t } call(t, e) { return e.subscribe(new Sa(t, this.resultSelector)) } } class Sa extends ya.L { constructor(t, e) { super(t), this.resultSelector = e, this.active = 0, this.values = [], this.observables = [] } _next(t) { this.values.push(wa), this.observables.push(t) } _complete() { const t = this.observables, e = t.length; if (0 === e) this.destination.complete(); else { this.active = e, this.toRespond = e; for (let n = 0; n < e; n++)this.add((0, va.D)(this, t[n], void 0, n)) } } notifyComplete(t) { 0 == (this.active -= 1) && this.destination.complete() } notifyNext(t, e, n) { const r = this.values, s = this.toRespond ? r[n] === wa ? --this.toRespond : this.toRespond : 0; r[n] = e, 0 === s && (this.resultSelector ? this._tryResultSelector(r) : this.destination.next(r.slice())) } _tryResultSelector(t) { let e; try { e = this.resultSelector.apply(this, t) } catch (n) { return void this.destination.error(n) } this.destination.next(e) } } const Ca = (() => { function t() { return Error.call(this), this.message = "no elements in sequence", this.name = "EmptyError", this } return t.prototype = Object.create(Error.prototype), t })(); var xa = n(7471); function Oa(...t) { return (0, xa.J)(1)((0, Cs.of)(...t)) } var Ta = n(653); function Pa(t) { return new It.y(e => { let n; try { n = t() } catch (r) { return void e.error(r) } return (n ? (0, At.D)(n) : (0, Ta.c)()).subscribe(e) }) } var ka = n(2875), Aa = n(2023), Ia = n(8402); function Ra(t) { return function (e) { return 0 === t ? (0, Ta.c)() : e.lift(new Ma(t)) } } class Ma { constructor(t) { if (this.total = t, this.total < 0) throw new Ia.W } call(t, e) { return e.subscribe(new Da(t, this.total)) } } class Da extends li.L { constructor(t, e) { super(t), this.total = e, this.ring = new Array, this.count = 0 } _next(t) { const e = this.ring, n = this.total, r = this.count++; e.length < n ? e.push(t) : e[r % n] = t } _complete() { const t = this.destination; let e = this.count; if (e > 0) { const n = this.count >= this.total ? this.total : this.count, r = this.ring; for (let s = 0; s < n; s++) { const s = e++ % n; t.next(r[s]) } } t.complete() } } function La(t = ja) { return e => e.lift(new Na(t)) } class Na { constructor(t) { this.errorFactory = t } call(t, e) { return e.subscribe(new Fa(t, this.errorFactory)) } } class Fa extends li.L { constructor(t, e) { super(t), this.errorFactory = e, this.hasValue = !1 } _next(t) { this.hasValue = !0, this.destination.next(t) } _complete() { if (this.hasValue) return this.destination.complete(); { let e; try { e = this.errorFactory() } catch (t) { e = t } this.destination.error(e) } } } function ja() { return new Ca } function Ua(t = null) { return e => e.lift(new Va(t)) } class Va { constructor(t) { this.defaultValue = t } call(t, e) { return e.subscribe(new Ba(t, this.defaultValue)) } } class Ba extends li.L { constructor(t, e) { super(t), this.defaultValue = e, this.isEmpty = !0 } _next(t) { this.isEmpty = !1, this.destination.next(t) } _complete() { this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete() } } var qa = n(3392); function $a(t, e) { const n = arguments.length >= 2; return r => r.pipe(t ? (0, Os.h)((e, n) => t(e, n, r)) : qa.y, (0, ki.q)(1), n ? Ua(e) : La(() => new Ca)) } var za = n(1564); class Ha { constructor(t) { this.callback = t } call(t, e) { return e.subscribe(new Ga(t, this.callback)) } } class Ga extends li.L { constructor(t, e) { super(t), this.add(new gi.w(e)) } } class Za { constructor(t, e) { this.id = t, this.url = e } } class Wa extends Za { constructor(t, e, n = "imperative", r = null) { super(t, e), this.navigationTrigger = n, this.restoredState = r } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } } class Ka extends Za { constructor(t, e, n) { super(t, e), this.urlAfterRedirects = n } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } } class Ya extends Za { constructor(t, e, n) { super(t, e), this.reason = n } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } } class Qa extends Za { constructor(t, e, n) { super(t, e), this.error = n } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } } class Ja extends Za { constructor(t, e, n, r) { super(t, e), this.urlAfterRedirects = n, this.state = r } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class Xa extends Za { constructor(t, e, n, r) { super(t, e), this.urlAfterRedirects = n, this.state = r } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class tl extends Za { constructor(t, e, n, r, s) { super(t, e), this.urlAfterRedirects = n, this.state = r, this.shouldActivate = s } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } } class el extends Za { constructor(t, e, n, r) { super(t, e), this.urlAfterRedirects = n, this.state = r } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class nl extends Za { constructor(t, e, n, r) { super(t, e), this.urlAfterRedirects = n, this.state = r } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class rl { constructor(t) { this.route = t } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } } class sl { constructor(t) { this.route = t } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } } class il { constructor(t) { this.snapshot = t } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class ol { constructor(t) { this.snapshot = t } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class al { constructor(t) { this.snapshot = t } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class ll { constructor(t) { this.snapshot = t } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class cl { constructor(t, e, n) { this.routerEvent = t, this.position = e, this.anchor = n } toString() { return `Scroll(anchor: '${this.anchor}', position: '${this.position ? `${this.position[0]}, ${this.position[1]}` : null}')` } } const ul = "primary"; class hl { constructor(t) { this.params = t || {} } has(t) { return Object.prototype.hasOwnProperty.call(this.params, t) } get(t) { if (this.has(t)) { const e = this.params[t]; return Array.isArray(e) ? e[0] : e } return null } getAll(t) { if (this.has(t)) { const e = this.params[t]; return Array.isArray(e) ? e : [e] } return [] } get keys() { return Object.keys(this.params) } } function dl(t) { return new hl(t) } function pl(t) { const e = Error("NavigationCancelingError: " + t); return e.ngNavigationCancelingError = !0, e } function fl(t, e, n) { const r = n.path.split("/"); if (r.length > t.length) return null; if ("full" === n.pathMatch && (e.hasChildren() || r.length < t.length)) return null; const s = {}; for (let i = 0; i < r.length; i++) { const e = r[i], n = t[i]; if (e.startsWith(":")) s[e.substring(1)] = n; else if (e !== n.path) return null } return { consumed: t.slice(0, r.length), posParams: s } } function gl(t, e) { const n = t ? Object.keys(t) : void 0, r = e ? Object.keys(e) : void 0; if (!n || !r || n.length != r.length) return !1; let s; for (let i = 0; i < n.length; i++)if (s = n[i], !ml(t[s], e[s])) return !1; return !0 } function ml(t, e) { if (Array.isArray(t) && Array.isArray(e)) { if (t.length !== e.length) return !1; const n = [...t].sort(), r = [...e].sort(); return n.every((t, e) => r[e] === t) } return t === e } function _l(t) { return Array.prototype.concat.apply([], t) } function yl(t) { return t.length > 0 ? t[t.length - 1] : null } function vl(t, e) { for (const n in t) t.hasOwnProperty(n) && e(t[n], n) } function bl(t) { return (0, r.CqO)(t) ? t : (0, r.QGY)(t) ? (0, At.D)(Promise.resolve(t)) : (0, Cs.of)(t) } const wl = { exact: function t(e, n, r) { if (!Al(e.segments, n.segments)) return !1; if (!Ol(e.segments, n.segments, r)) return !1; if (e.numberOfChildren !== n.numberOfChildren) return !1; for (const s in n.children) { if (!e.children[s]) return !1; if (!t(e.children[s], n.children[s], r)) return !1 } return !0 }, subset: Cl }, El = { exact: function (t, e) { return gl(t, e) }, subset: function (t, e) { return Object.keys(e).length <= Object.keys(t).length && Object.keys(e).every(n => ml(t[n], e[n])) }, ignored: () => !0 }; function Sl(t, e, n) { return wl[n.paths](t.root, e.root, n.matrixParams) && El[n.queryParams](t.queryParams, e.queryParams) && !("exact" === n.fragment && t.fragment !== e.fragment) } function Cl(t, e, n) { return xl(t, e, e.segments, n) } function xl(t, e, n, r) { if (t.segments.length > n.length) { const s = t.segments.slice(0, n.length); return !!Al(s, n) && !e.hasChildren() && !!Ol(s, n, r) } if (t.segments.length === n.length) { if (!Al(t.segments, n)) return !1; if (!Ol(t.segments, n, r)) return !1; for (const n in e.children) { if (!t.children[n]) return !1; if (!Cl(t.children[n], e.children[n], r)) return !1 } return !0 } { const s = n.slice(0, t.segments.length), i = n.slice(t.segments.length); return !!Al(t.segments, s) && !!Ol(t.segments, s, r) && !!t.children.primary && xl(t.children.primary, e, i, r) } } function Ol(t, e, n) { return e.every((e, r) => El[n](t[r].parameters, e.parameters)) } class Tl { constructor(t, e, n) { this.root = t, this.queryParams = e, this.fragment = n } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = dl(this.queryParams)), this._queryParamMap } toString() { return Ml.serialize(this) } } class Pl { constructor(t, e) { this.segments = t, this.children = e, this.parent = null, vl(e, (t, e) => t.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return Dl(this) } } class kl { constructor(t, e) { this.path = t, this.parameters = e } get parameterMap() { return this._parameterMap || (this._parameterMap = dl(this.parameters)), this._parameterMap } toString() { return Bl(this) } } function Al(t, e) { return t.length === e.length && t.every((t, n) => t.path === e[n].path) } class Il { } class Rl { parse(t) { const e = new Gl(t); return new Tl(e.parseRootSegment(), e.parseQueryParams(), e.parseFragment()) } serialize(t) { var e; return `/${Ll(t.root, !0)}${function (t) { const e = Object.keys(t).map(e => { const n = t[e]; return Array.isArray(n) ? n.map(t => `${Fl(e)}=${Fl(t)}`).join("&") : `${Fl(e)}=${Fl(n)}` }).filter(t => !!t); return e.length ? `?${e.join("&")}` : "" }(t.queryParams)}${"string" == typeof t.fragment ? `#${e = t.fragment, encodeURI(e)}` : ""}` } } const Ml = new Rl; function Dl(t) { return t.segments.map(t => Bl(t)).join("/") } function Ll(t, e) { if (!t.hasChildren()) return Dl(t); if (e) { const e = t.children.primary ? Ll(t.children.primary, !1) : "", n = []; return vl(t.children, (t, e) => { e !== ul && n.push(`${e}:${Ll(t, !1)}`) }), n.length > 0 ? `${e}(${n.join("//")})` : e } { const e = function (t, e) { let n = []; return vl(t.children, (t, r) => { r === ul && (n = n.concat(e(t, r))) }), vl(t.children, (t, r) => { r !== ul && (n = n.concat(e(t, r))) }), n }(t, (e, n) => n === ul ? [Ll(t.children.primary, !1)] : [`${n}:${Ll(e, !1)}`]); return 1 === Object.keys(t.children).length && null != t.children.primary ? `${Dl(t)}/${e[0]}` : `${Dl(t)}/(${e.join("//")})` } } function Nl(t) { return encodeURIComponent(t).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function Fl(t) { return Nl(t).replace(/%3B/gi, ";") } function jl(t) { return Nl(t).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function Ul(t) { return decodeURIComponent(t) } function Vl(t) { return Ul(t.replace(/\+/g, "%20")) } function Bl(t) { return `${jl(t.path)}${e = t.parameters, Object.keys(e).map(t => `;${jl(t)}=${jl(e[t])}`).join("")}`; var e } const ql = /^[^\/()?;=#]+/; function $l(t) { const e = t.match(ql); return e ? e[0] : "" } const zl = /^[^=?&#]+/, Hl = /^[^?&#]+/; class Gl { constructor(t) { this.url = t, this.remaining = t } parseRootSegment() { return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new Pl([], {}) : new Pl([], this.parseChildren()) } parseQueryParams() { const t = {}; if (this.consumeOptional("?")) do { this.parseQueryParam(t) } while (this.consumeOptional("&")); return t } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if ("" === this.remaining) return {}; this.consumeOptional("/"); const t = []; for (this.peekStartsWith("(") || t.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), t.push(this.parseSegment()); let e = {}; this.peekStartsWith("/(") && (this.capture("/"), e = this.parseParens(!0)); let n = {}; return this.peekStartsWith("(") && (n = this.parseParens(!1)), (t.length > 0 || Object.keys(e).length > 0) && (n.primary = new Pl(t, e)), n } parseSegment() { const t = $l(this.remaining); if ("" === t && this.peekStartsWith(";")) throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`); return this.capture(t), new kl(Ul(t), this.parseMatrixParams()) } parseMatrixParams() { const t = {}; for (; this.consumeOptional(";");)this.parseParam(t); return t } parseParam(t) { const e = $l(this.remaining); if (!e) return; this.capture(e); let n = ""; if (this.consumeOptional("=")) { const t = $l(this.remaining); t && (n = t, this.capture(n)) } t[Ul(e)] = Ul(n) } parseQueryParam(t) { const e = function (t) { const e = t.match(zl); return e ? e[0] : "" }(this.remaining); if (!e) return; this.capture(e); let n = ""; if (this.consumeOptional("=")) { const t = function (t) { const e = t.match(Hl); return e ? e[0] : "" }(this.remaining); t && (n = t, this.capture(n)) } const r = Vl(e), s = Vl(n); if (t.hasOwnProperty(r)) { let e = t[r]; Array.isArray(e) || (e = [e], t[r] = e), e.push(s) } else t[r] = s } parseParens(t) { const e = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { const n = $l(this.remaining), r = this.remaining[n.length]; if ("/" !== r && ")" !== r && ";" !== r) throw new Error(`Cannot parse url '${this.url}'`); let s; n.indexOf(":") > -1 ? (s = n.substr(0, n.indexOf(":")), this.capture(s), this.capture(":")) : t && (s = ul); const i = this.parseChildren(); e[s] = 1 === Object.keys(i).length ? i.primary : new Pl([], i), this.consumeOptional("//") } return e } peekStartsWith(t) { return this.remaining.startsWith(t) } consumeOptional(t) { return !!this.peekStartsWith(t) && (this.remaining = this.remaining.substring(t.length), !0) } capture(t) { if (!this.consumeOptional(t)) throw new Error(`Expected "${t}".`) } } class Zl { constructor(t) { this._root = t } get root() { return this._root.value } parent(t) { const e = this.pathFromRoot(t); return e.length > 1 ? e[e.length - 2] : null } children(t) { const e = Wl(t, this._root); return e ? e.children.map(t => t.value) : [] } firstChild(t) { const e = Wl(t, this._root); return e && e.children.length > 0 ? e.children[0].value : null } siblings(t) { const e = Kl(t, this._root); return e.length < 2 ? [] : e[e.length - 2].children.map(t => t.value).filter(e => e !== t) } pathFromRoot(t) { return Kl(t, this._root).map(t => t.value) } } function Wl(t, e) { if (t === e.value) return e; for (const n of e.children) { const e = Wl(t, n); if (e) return e } return null } function Kl(t, e) { if (t === e.value) return [e]; for (const n of e.children) { const r = Kl(t, n); if (r.length) return r.unshift(e), r } return [] } class Yl { constructor(t, e) { this.value = t, this.children = e } toString() { return `TreeNode(${this.value})` } } function Ql(t) { const e = {}; return t && t.children.forEach(t => e[t.value.outlet] = t), e } class Jl extends Zl { constructor(t, e) { super(t), this.snapshot = e, sc(this, t) } toString() { return this.snapshot.toString() } } function Xl(t, e) { const n = function (t, e) { const n = new nc([], {}, {}, "", {}, ul, e, null, t.root, -1, {}); return new rc("", new Yl(n, [])) }(t, e), r = new ma.X([new kl("", {})]), s = new ma.X({}), i = new ma.X({}), o = new ma.X({}), a = new ma.X(""), l = new tc(r, s, o, a, i, ul, e, n.root); return l.snapshot = n.root, new Jl(new Yl(l, []), n) } class tc { constructor(t, e, n, r, s, i, o, a) { this.url = t, this.params = e, this.queryParams = n, this.fragment = r, this.data = s, this.outlet = i, this.component = o, this._futureSnapshot = a } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = this.params.pipe((0, Mt.U)(t => dl(t)))), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe((0, Mt.U)(t => dl(t)))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } } function ec(t, e = "emptyOnly") { const n = t.pathFromRoot; let r = 0; if ("always" !== e) for (r = n.length - 1; r >= 1;) { const t = n[r], e = n[r - 1]; if (t.routeConfig && "" === t.routeConfig.path) r--; else { if (e.component) break; r-- } } return function (t) { return t.reduce((t, e) => ({ params: Object.assign(Object.assign({}, t.params), e.params), data: Object.assign(Object.assign({}, t.data), e.data), resolve: Object.assign(Object.assign({}, t.resolve), e._resolvedData) }), { params: {}, data: {}, resolve: {} }) }(n.slice(r)) } class nc { constructor(t, e, n, r, s, i, o, a, l, c, u) { this.url = t, this.params = e, this.queryParams = n, this.fragment = r, this.data = s, this.outlet = i, this.component = o, this.routeConfig = a, this._urlSegment = l, this._lastPathIndex = c, this._resolve = u } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = dl(this.params)), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = dl(this.queryParams)), this._queryParamMap } toString() { return `Route(url:'${this.url.map(t => t.toString()).join("/")}', path:'${this.routeConfig ? this.routeConfig.path : ""}')` } } class rc extends Zl { constructor(t, e) { super(e), this.url = t, sc(this, e) } toString() { return ic(this._root) } } function sc(t, e) { e.value._routerState = t, e.children.forEach(e => sc(t, e)) } function ic(t) { const e = t.children.length > 0 ? ` { ${t.children.map(ic).join(", ")} } ` : ""; return `${t.value}${e}` } function oc(t) { if (t.snapshot) { const e = t.snapshot, n = t._futureSnapshot; t.snapshot = n, gl(e.queryParams, n.queryParams) || t.queryParams.next(n.queryParams), e.fragment !== n.fragment && t.fragment.next(n.fragment), gl(e.params, n.params) || t.params.next(n.params), function (t, e) { if (t.length !== e.length) return !1; for (let n = 0; n < t.length; ++n)if (!gl(t[n], e[n])) return !1; return !0 }(e.url, n.url) || t.url.next(n.url), gl(e.data, n.data) || t.data.next(n.data) } else t.snapshot = t._futureSnapshot, t.data.next(t._futureSnapshot.data) } function ac(t, e) { var n, r; return gl(t.params, e.params) && Al(n = t.url, r = e.url) && n.every((t, e) => gl(t.parameters, r[e].parameters)) && !(!t.parent != !e.parent) && (!t.parent || ac(t.parent, e.parent)) } function lc(t, e, n) { if (n && t.shouldReuseRoute(e.value, n.value.snapshot)) { const r = n.value; r._futureSnapshot = e.value; const s = function (t, e, n) { return e.children.map(e => { for (const r of n.children) if (t.shouldReuseRoute(e.value, r.value.snapshot)) return lc(t, e, r); return lc(t, e) }) }(t, e, n); return new Yl(r, s) } { if (t.shouldAttach(e.value)) { const n = t.retrieve(e.value); if (null !== n) { const t = n.route; return cc(e, t), t } } const n = new tc(new ma.X((r = e.value).url), new ma.X(r.params), new ma.X(r.queryParams), new ma.X(r.fragment), new ma.X(r.data), r.outlet, r.component, r), s = e.children.map(e => lc(t, e)); return new Yl(n, s) } var r } function cc(t, e) { if (t.value.routeConfig !== e.value.routeConfig) throw new Error("Cannot reattach ActivatedRouteSnapshot created from a different route"); if (t.children.length !== e.children.length) throw new Error("Cannot reattach ActivatedRouteSnapshot with a different number of children"); e.value._futureSnapshot = t.value; for (let n = 0; n < t.children.length; ++n)cc(t.children[n], e.children[n]) } function uc(t) { return "object" == typeof t && null != t && !t.outlets && !t.segmentPath } function hc(t) { return "object" == typeof t && null != t && t.outlets } function dc(t, e, n, r, s) { let i = {}; return r && vl(r, (t, e) => { i[e] = Array.isArray(t) ? t.map(t => `${t}`) : `${t}` }), new Tl(n.root === t ? e : pc(n.root, t, e), i, s) } function pc(t, e, n) { const r = {}; return vl(t.children, (t, s) => { r[s] = t === e ? n : pc(t, e, n) }), new Pl(t.segments, r) } class fc { constructor(t, e, n) { if (this.isAbsolute = t, this.numberOfDoubleDots = e, this.commands = n, t && n.length > 0 && uc(n[0])) throw new Error("Root segment cannot have matrix parameters"); const r = n.find(hc); if (r && r !== yl(n)) throw new Error("{outlets:{}} has to be the last command") } toRoot() { return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0] } } class gc { constructor(t, e, n) { this.segmentGroup = t, this.processChildren = e, this.index = n } } function mc(t, e, n) { if (t || (t = new Pl([], {})), 0 === t.segments.length && t.hasChildren()) return _c(t, e, n); const r = function (t, e, n) { let r = 0, s = e; const i = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; s < t.segments.length;) { if (r >= n.length) return i; const e = t.segments[s], o = n[r]; if (hc(o)) break; const a = `${o}`, l = r < n.length - 1 ? n[r + 1] : null; if (s > 0 && void 0 === a) break; if (a && l && "object" == typeof l && void 0 === l.outlets) { if (!wc(a, l, e)) return i; r += 2 } else { if (!wc(a, {}, e)) return i; r++ } s++ } return { match: !0, pathIndex: s, commandIndex: r } }(t, e, n), s = n.slice(r.commandIndex); if (r.match && r.pathIndex < t.segments.length) { const e = new Pl(t.segments.slice(0, r.pathIndex), {}); return e.children.primary = new Pl(t.segments.slice(r.pathIndex), t.children), _c(e, 0, s) } return r.match && 0 === s.length ? new Pl(t.segments, {}) : r.match && !t.hasChildren() ? yc(t, e, n) : r.match ? _c(t, 0, s) : yc(t, e, n) } function _c(t, e, n) { if (0 === n.length) return new Pl(t.segments, {}); { const r = function (t) { return hc(t[0]) ? t[0].outlets : { [ul]: t } }(n), s = {}; return vl(r, (n, r) => { "string" == typeof n && (n = [n]), null !== n && (s[r] = mc(t.children[r], e, n)) }), vl(t.children, (t, e) => { void 0 === r[e] && (s[e] = t) }), new Pl(t.segments, s) } } function yc(t, e, n) { const r = t.segments.slice(0, e); let s = 0; for (; s < n.length;) { const i = n[s]; if (hc(i)) { const t = vc(i.outlets); return new Pl(r, t) } if (0 === s && uc(n[0])) { r.push(new kl(t.segments[e].path, bc(n[0]))), s++; continue } const o = hc(i) ? i.outlets.primary : `${i}`, a = s < n.length - 1 ? n[s + 1] : null; o && a && uc(a) ? (r.push(new kl(o, bc(a))), s += 2) : (r.push(new kl(o, {})), s++) } return new Pl(r, {}) } function vc(t) { const e = {}; return vl(t, (t, n) => { "string" == typeof t && (t = [t]), null !== t && (e[n] = yc(new Pl([], {}), 0, t)) }), e } function bc(t) { const e = {}; return vl(t, (t, n) => e[n] = `${t}`), e } function wc(t, e, n) { return t == n.path && gl(e, n.parameters) } class Ec { constructor(t, e, n, r) { this.routeReuseStrategy = t, this.futureState = e, this.currState = n, this.forwardEvent = r } activate(t) { const e = this.futureState._root, n = this.currState ? this.currState._root : null; this.deactivateChildRoutes(e, n, t), oc(this.futureState.root), this.activateChildRoutes(e, n, t) } deactivateChildRoutes(t, e, n) { const r = Ql(e); t.children.forEach(t => { const e = t.value.outlet; this.deactivateRoutes(t, r[e], n), delete r[e] }), vl(r, (t, e) => { this.deactivateRouteAndItsChildren(t, n) }) } deactivateRoutes(t, e, n) { const r = t.value, s = e ? e.value : null; if (r === s) if (r.component) { const s = n.getContext(r.outlet); s && this.deactivateChildRoutes(t, e, s.children) } else this.deactivateChildRoutes(t, e, n); else s && this.deactivateRouteAndItsChildren(e, n) } deactivateRouteAndItsChildren(t, e) { this.routeReuseStrategy.shouldDetach(t.value.snapshot) ? this.detachAndStoreRouteSubtree(t, e) : this.deactivateRouteAndOutlet(t, e) } detachAndStoreRouteSubtree(t, e) { const n = e.getContext(t.value.outlet); if (n && n.outlet) { const e = n.outlet.detach(), r = n.children.onOutletDeactivated(); this.routeReuseStrategy.store(t.value.snapshot, { componentRef: e, route: t, contexts: r }) } } deactivateRouteAndOutlet(t, e) { const n = e.getContext(t.value.outlet), r = n && t.value.component ? n.children : e, s = Ql(t); for (const i of Object.keys(s)) this.deactivateRouteAndItsChildren(s[i], r); n && n.outlet && (n.outlet.deactivate(), n.children.onOutletDeactivated(), n.attachRef = null, n.resolver = null, n.route = null) } activateChildRoutes(t, e, n) { const r = Ql(e); t.children.forEach(t => { this.activateRoutes(t, r[t.value.outlet], n), this.forwardEvent(new ll(t.value.snapshot)) }), t.children.length && this.forwardEvent(new ol(t.value.snapshot)) } activateRoutes(t, e, n) { const r = t.value, s = e ? e.value : null; if (oc(r), r === s) if (r.component) { const s = n.getOrCreateContext(r.outlet); this.activateChildRoutes(t, e, s.children) } else this.activateChildRoutes(t, e, n); else if (r.component) { const e = n.getOrCreateContext(r.outlet); if (this.routeReuseStrategy.shouldAttach(r.snapshot)) { const t = this.routeReuseStrategy.retrieve(r.snapshot); this.routeReuseStrategy.store(r.snapshot, null), e.children.onOutletReAttached(t.contexts), e.attachRef = t.componentRef, e.route = t.route.value, e.outlet && e.outlet.attach(t.componentRef, t.route.value), Sc(t.route) } else { const n = function (t) { for (let e = t.parent; e; e = e.parent) { const t = e.routeConfig; if (t && t._loadedConfig) return t._loadedConfig; if (t && t.component) return null } return null }(r.snapshot), s = n ? n.module.componentFactoryResolver : null; e.attachRef = null, e.route = r, e.resolver = s, e.outlet && e.outlet.activateWith(r, s), this.activateChildRoutes(t, null, e.children) } } else this.activateChildRoutes(t, null, n) } } function Sc(t) { oc(t.value), t.children.forEach(Sc) } class Cc { constructor(t, e) { this.routes = t, this.module = e } } function xc(t) { return "function" == typeof t } function Oc(t) { return t instanceof Tl } const Tc = Symbol("INITIAL_VALUE"); function Pc() { return (0, Do.w)(t => function (...t) { let e, n; return (0, _a.K)(t[t.length - 1]) && (n = t.pop()), "function" == typeof t[t.length - 1] && (e = t.pop()), 1 === t.length && (0, Rt.k)(t[0]) && (t = t[0]), (0, ba.n)(t, n).lift(new Ea(e)) }(t.map(t => t.pipe((0, ki.q)(1), function (...t) { const e = t[t.length - 1]; return (0, _a.K)(e) ? (t.pop(), n => Oa(t, n, e)) : e => Oa(t, e) }(Tc)))).pipe((0, Aa.R)((t, e) => { let n = !1; return e.reduce((t, r, s) => { if (t !== Tc) return t; if (r === Tc && (n = !0), !n) { if (!1 === r) return r; if (s === e.length - 1 || Oc(r)) return r } return t }, t) }, Tc), (0, Os.h)(t => t !== Tc), (0, Mt.U)(t => Oc(t) ? t : !0 === t), (0, ki.q)(1))) } let kc = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = r.Xpm({ type: t, selectors: [["ng-component"]], decls: 1, vars: 0, template: function (t, e) { 1 & t && r._UZ(0, "router-outlet") }, directives: function () { return [Tu] }, encapsulation: 2 }), t })(); function Ac(t, e = "") { for (let n = 0; n < t.length; n++) { const r = t[n]; Ic(r, Rc(e, r)) } } function Ic(t, e) { t.children && Ac(t.children, e) } function Rc(t, e) { return e ? t || e.path ? t && !e.path ? `${t}/` : !t && e.path ? e.path : `${t}/${e.path}` : "" : t } function Mc(t) { const e = t.children && t.children.map(Mc), n = e ? Object.assign(Object.assign({}, t), { children: e }) : Object.assign({}, t); return !n.component && (e || n.loadChildren) && n.outlet && n.outlet !== ul && (n.component = kc), n } function Dc(t) { return t.outlet || ul } function Lc(t, e) { const n = t.filter(t => Dc(t) === e); return n.push(...t.filter(t => Dc(t) !== e)), n } const Nc = { matched: !1, consumedSegments: [], lastChild: 0, parameters: {}, positionalParamSegments: {} }; function Fc(t, e, n) { var r; if ("" === e.path) return "full" === e.pathMatch && (t.hasChildren() || n.length > 0) ? Object.assign({}, Nc) : { matched: !0, consumedSegments: [], lastChild: 0, parameters: {}, positionalParamSegments: {} }; const s = (e.matcher || fl)(n, t, e); if (!s) return Object.assign({}, Nc); const i = {}; vl(s.posParams, (t, e) => { i[e] = t.path }); const o = s.consumed.length > 0 ? Object.assign(Object.assign({}, i), s.consumed[s.consumed.length - 1].parameters) : i; return { matched: !0, consumedSegments: s.consumed, lastChild: s.consumed.length, parameters: o, positionalParamSegments: null !== (r = s.posParams) && void 0 !== r ? r : {} } } function jc(t, e, n, r, s = "corrected") { if (n.length > 0 && function (t, e, n) { return n.some(n => Uc(t, e, n) && Dc(n) !== ul) }(t, n, r)) { const s = new Pl(e, function (t, e, n, r) { const s = {}; s.primary = r, r._sourceSegment = t, r._segmentIndexShift = e.length; for (const i of n) if ("" === i.path && Dc(i) !== ul) { const n = new Pl([], {}); n._sourceSegment = t, n._segmentIndexShift = e.length, s[Dc(i)] = n } return s }(t, e, r, new Pl(n, t.children))); return s._sourceSegment = t, s._segmentIndexShift = e.length, { segmentGroup: s, slicedSegments: [] } } if (0 === n.length && function (t, e, n) { return n.some(n => Uc(t, e, n)) }(t, n, r)) { const i = new Pl(t.segments, function (t, e, n, r, s, i) { const o = {}; for (const a of r) if (Uc(t, n, a) && !s[Dc(a)]) { const n = new Pl([], {}); n._sourceSegment = t, n._segmentIndexShift = "legacy" === i ? t.segments.length : e.length, o[Dc(a)] = n } return Object.assign(Object.assign({}, s), o) }(t, e, n, r, t.children, s)); return i._sourceSegment = t, i._segmentIndexShift = e.length, { segmentGroup: i, slicedSegments: n } } const i = new Pl(t.segments, t.children); return i._sourceSegment = t, i._segmentIndexShift = e.length, { segmentGroup: i, slicedSegments: n } } function Uc(t, e, n) { return (!(t.hasChildren() || e.length > 0) || "full" !== n.pathMatch) && "" === n.path } function Vc(t, e, n, r) { return !!(Dc(t) === r || r !== ul && Uc(e, n, t)) && ("**" === t.path || Fc(e, t, n).matched) } function Bc(t, e, n) { return 0 === e.length && !t.children[n] } class qc { constructor(t) { this.segmentGroup = t || null } } class $c { constructor(t) { this.urlTree = t } } function zc(t) { return new It.y(e => e.error(new qc(t))) } function Hc(t) { return new It.y(e => e.error(new $c(t))) } function Gc(t) { return new It.y(e => e.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${t}'`))) } class Zc { constructor(t, e, n, s, i) { this.configLoader = e, this.urlSerializer = n, this.urlTree = s, this.config = i, this.allowRedirects = !0, this.ngModule = t.get(r.h0i) } apply() { const t = jc(this.urlTree.root, [], [], this.config).segmentGroup, e = new Pl(t.segments, t.children); return this.expandSegmentGroup(this.ngModule, this.config, e, ul).pipe((0, Mt.U)(t => this.createUrlTree(Wc(t), this.urlTree.queryParams, this.urlTree.fragment))).pipe((0, fi.K)(t => { if (t instanceof $c) return this.allowRedirects = !1, this.match(t.urlTree); if (t instanceof qc) throw this.noMatchError(t); throw t })) } match(t) { return this.expandSegmentGroup(this.ngModule, this.config, t.root, ul).pipe((0, Mt.U)(e => this.createUrlTree(Wc(e), t.queryParams, t.fragment))).pipe((0, fi.K)(t => { if (t instanceof qc) throw this.noMatchError(t); throw t })) } noMatchError(t) { return new Error(`Cannot match any routes. URL Segment: '${t.segmentGroup}'`) } createUrlTree(t, e, n) { const r = t.segments.length > 0 ? new Pl([], { [ul]: t }) : t; return new Tl(r, e, n) } expandSegmentGroup(t, e, n, r) { return 0 === n.segments.length && n.hasChildren() ? this.expandChildren(t, e, n).pipe((0, Mt.U)(t => new Pl([], t))) : this.expandSegment(t, n, e, n.segments, r, !0) } expandChildren(t, e, n) { const r = []; for (const s of Object.keys(n.children)) "primary" === s ? r.unshift(s) : r.push(s); return (0, At.D)(r).pipe((0, xs.b)(r => { const s = n.children[r], i = Lc(e, r); return this.expandSegmentGroup(t, i, s, r).pipe((0, Mt.U)(t => ({ segment: t, outlet: r }))) }), (0, Aa.R)((t, e) => (t[e.outlet] = e.segment, t), {}), function (t, e) { const n = arguments.length >= 2; return r => r.pipe(t ? (0, Os.h)((e, n) => t(e, n, r)) : qa.y, Ra(1), n ? Ua(e) : La(() => new Ca)) }()) } expandSegment(t, e, n, r, s, i) { return (0, At.D)(n).pipe((0, xs.b)(o => this.expandSegmentAgainstRoute(t, e, n, o, r, s, i).pipe((0, fi.K)(t => { if (t instanceof qc) return (0, Cs.of)(null); throw t }))), $a(t => !!t), (0, fi.K)((t, n) => { if (t instanceof Ca || "EmptyError" === t.name) { if (Bc(e, r, s)) return (0, Cs.of)(new Pl([], {})); throw new qc(e) } throw t })) } expandSegmentAgainstRoute(t, e, n, r, s, i, o) { return Vc(r, e, s, i) ? void 0 === r.redirectTo ? this.matchSegmentAgainstRoute(t, e, r, s, i) : o && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(t, e, n, r, s, i) : zc(e) : zc(e) } expandSegmentAgainstRouteUsingRedirect(t, e, n, r, s, i) { return "**" === r.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(t, n, r, i) : this.expandRegularSegmentAgainstRouteUsingRedirect(t, e, n, r, s, i) } expandWildCardWithParamsAgainstRouteUsingRedirect(t, e, n, r) { const s = this.applyRedirectCommands([], n.redirectTo, {}); return n.redirectTo.startsWith("/") ? Hc(s) : this.lineralizeSegments(n, s).pipe((0, Ei.zg)(n => { const s = new Pl(n, {}); return this.expandSegment(t, s, e, n, r, !1) })) } expandRegularSegmentAgainstRouteUsingRedirect(t, e, n, r, s, i) { const { matched: o, consumedSegments: a, lastChild: l, positionalParamSegments: c } = Fc(e, r, s); if (!o) return zc(e); const u = this.applyRedirectCommands(a, r.redirectTo, c); return r.redirectTo.startsWith("/") ? Hc(u) : this.lineralizeSegments(r, u).pipe((0, Ei.zg)(r => this.expandSegment(t, e, n, r.concat(s.slice(l)), i, !1))) } matchSegmentAgainstRoute(t, e, n, r, s) { if ("**" === n.path) return n.loadChildren ? (n._loadedConfig ? (0, Cs.of)(n._loadedConfig) : this.configLoader.load(t.injector, n)).pipe((0, Mt.U)(t => (n._loadedConfig = t, new Pl(r, {})))) : (0, Cs.of)(new Pl(r, {})); const { matched: i, consumedSegments: o, lastChild: a } = Fc(e, n, r); if (!i) return zc(e); const l = r.slice(a); return this.getChildConfig(t, n, r).pipe((0, Ei.zg)(t => { const r = t.module, i = t.routes, { segmentGroup: a, slicedSegments: c } = jc(e, o, l, i), u = new Pl(a.segments, a.children); if (0 === c.length && u.hasChildren()) return this.expandChildren(r, i, u).pipe((0, Mt.U)(t => new Pl(o, t))); if (0 === i.length && 0 === c.length) return (0, Cs.of)(new Pl(o, {})); const h = Dc(n) === s; return this.expandSegment(r, u, i, c, h ? ul : s, !0).pipe((0, Mt.U)(t => new Pl(o.concat(t.segments), t.children))) })) } getChildConfig(t, e, n) { return e.children ? (0, Cs.of)(new Cc(e.children, t)) : e.loadChildren ? void 0 !== e._loadedConfig ? (0, Cs.of)(e._loadedConfig) : this.runCanLoadGuards(t.injector, e, n).pipe((0, Ei.zg)(n => n ? this.configLoader.load(t.injector, e).pipe((0, Mt.U)(t => (e._loadedConfig = t, t))) : function (t) { return new It.y(e => e.error(pl(`Cannot load children because the guard of the route "path: '${t.path}'" returned false`))) }(e))) : (0, Cs.of)(new Cc([], t)) } runCanLoadGuards(t, e, n) { const r = e.canLoad; if (!r || 0 === r.length) return (0, Cs.of)(!0); const s = r.map(r => { const s = t.get(r); let i; if (function (t) { return t && xc(t.canLoad) }(s)) i = s.canLoad(e, n); else { if (!xc(s)) throw new Error("Invalid CanLoad guard"); i = s(e, n) } return bl(i) }); return (0, Cs.of)(s).pipe(Pc(), Io(t => { if (!Oc(t)) return; const e = pl(`Redirecting to "${this.urlSerializer.serialize(t)}"`); throw e.url = t, e }), (0, Mt.U)(t => !0 === t)) } lineralizeSegments(t, e) { let n = [], r = e.root; for (; ;) { if (n = n.concat(r.segments), 0 === r.numberOfChildren) return (0, Cs.of)(n); if (r.numberOfChildren > 1 || !r.children.primary) return Gc(t.redirectTo); r = r.children.primary } } applyRedirectCommands(t, e, n) { return this.applyRedirectCreatreUrlTree(e, this.urlSerializer.parse(e), t, n) } applyRedirectCreatreUrlTree(t, e, n, r) { const s = this.createSegmentGroup(t, e.root, n, r); return new Tl(s, this.createQueryParams(e.queryParams, this.urlTree.queryParams), e.fragment) } createQueryParams(t, e) { const n = {}; return vl(t, (t, r) => { if ("string" == typeof t && t.startsWith(":")) { const s = t.substring(1); n[r] = e[s] } else n[r] = t }), n } createSegmentGroup(t, e, n, r) { const s = this.createSegments(t, e.segments, n, r); let i = {}; return vl(e.children, (e, s) => { i[s] = this.createSegmentGroup(t, e, n, r) }), new Pl(s, i) } createSegments(t, e, n, r) { return e.map(e => e.path.startsWith(":") ? this.findPosParam(t, e, r) : this.findOrReturn(e, n)) } findPosParam(t, e, n) { const r = n[e.path.substring(1)]; if (!r) throw new Error(`Cannot redirect to '${t}'. Cannot find '${e.path}'.`); return r } findOrReturn(t, e) { let n = 0; for (const r of e) { if (r.path === t.path) return e.splice(n), r; n++ } return t } } function Wc(t) { const e = {}; for (const n of Object.keys(t.children)) { const r = Wc(t.children[n]); (r.segments.length > 0 || r.hasChildren()) && (e[n] = r) } return function (t) { if (1 === t.numberOfChildren && t.children.primary) { const e = t.children.primary; return new Pl(t.segments.concat(e.segments), e.children) } return t }(new Pl(t.segments, e)) } class Kc { constructor(t) { this.path = t, this.route = this.path[this.path.length - 1] } } class Yc { constructor(t, e) { this.component = t, this.route = e } } function Qc(t, e, n) { const r = t._root; return Xc(r, e ? e._root : null, n, [r.value]) } function Jc(t, e, n) { const r = function (t) { if (!t) return null; for (let e = t.parent; e; e = e.parent) { const t = e.routeConfig; if (t && t._loadedConfig) return t._loadedConfig } return null }(e); return (r ? r.module.injector : n).get(t) } function Xc(t, e, n, r, s = { canDeactivateChecks: [], canActivateChecks: [] }) { const i = Ql(e); return t.children.forEach(t => { !function (t, e, n, r, s = { canDeactivateChecks: [], canActivateChecks: [] }) { const i = t.value, o = e ? e.value : null, a = n ? n.getContext(t.value.outlet) : null; if (o && i.routeConfig === o.routeConfig) { const l = function (t, e, n) { if ("function" == typeof n) return n(t, e); switch (n) { case "pathParamsChange": return !Al(t.url, e.url); case "pathParamsOrQueryParamsChange": return !Al(t.url, e.url) || !gl(t.queryParams, e.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !ac(t, e) || !gl(t.queryParams, e.queryParams); case "paramsChange": default: return !ac(t, e) } }(o, i, i.routeConfig.runGuardsAndResolvers); l ? s.canActivateChecks.push(new Kc(r)) : (i.data = o.data, i._resolvedData = o._resolvedData), Xc(t, e, i.component ? a ? a.children : null : n, r, s), l && a && a.outlet && a.outlet.isActivated && s.canDeactivateChecks.push(new Yc(a.outlet.component, o)) } else o && tu(e, a, s), s.canActivateChecks.push(new Kc(r)), Xc(t, null, i.component ? a ? a.children : null : n, r, s) }(t, i[t.value.outlet], n, r.concat([t.value]), s), delete i[t.value.outlet] }), vl(i, (t, e) => tu(t, n.getContext(e), s)), s } function tu(t, e, n) { const r = Ql(t), s = t.value; vl(r, (t, r) => { tu(t, s.component ? e ? e.children.getContext(r) : null : e, n) }), n.canDeactivateChecks.push(new Yc(s.component && e && e.outlet && e.outlet.isActivated ? e.outlet.component : null, s)) } class eu { } function nu(t) { return new It.y(e => e.error(t)) } class ru { constructor(t, e, n, r, s, i) { this.rootComponentType = t, this.config = e, this.urlTree = n, this.url = r, this.paramsInheritanceStrategy = s, this.relativeLinkResolution = i } recognize() { const t = jc(this.urlTree.root, [], [], this.config.filter(t => void 0 === t.redirectTo), this.relativeLinkResolution).segmentGroup, e = this.processSegmentGroup(this.config, t, ul); if (null === e) return null; const n = new nc([], Object.freeze({}), Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, {}, ul, this.rootComponentType, null, this.urlTree.root, -1, {}), r = new Yl(n, e), s = new rc(this.url, r); return this.inheritParamsAndData(s._root), s } inheritParamsAndData(t) { const e = t.value, n = ec(e, this.paramsInheritanceStrategy); e.params = Object.freeze(n.params), e.data = Object.freeze(n.data), t.children.forEach(t => this.inheritParamsAndData(t)) } processSegmentGroup(t, e, n) { return 0 === e.segments.length && e.hasChildren() ? this.processChildren(t, e) : this.processSegment(t, e, e.segments, n) } processChildren(t, e) { const n = []; for (const s of Object.keys(e.children)) { const r = e.children[s], i = Lc(t, s), o = this.processSegmentGroup(i, r, s); if (null === o) return null; n.push(...o) } const r = iu(n); return r.sort((t, e) => t.value.outlet === ul ? -1 : e.value.outlet === ul ? 1 : t.value.outlet.localeCompare(e.value.outlet)), r } processSegment(t, e, n, r) { for (const s of t) { const t = this.processSegmentAgainstRoute(s, e, n, r); if (null !== t) return t } return Bc(e, n, r) ? [] : null } processSegmentAgainstRoute(t, e, n, r) { if (t.redirectTo || !Vc(t, e, n, r)) return null; let s, i = [], o = []; if ("**" === t.path) { const r = n.length > 0 ? yl(n).parameters : {}; s = new nc(n, r, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, lu(t), Dc(t), t.component, t, ou(e), au(e) + n.length, cu(t)) } else { const r = Fc(e, t, n); if (!r.matched) return null; i = r.consumedSegments, o = n.slice(r.lastChild), s = new nc(i, r.parameters, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, lu(t), Dc(t), t.component, t, ou(e), au(e) + i.length, cu(t)) } const a = function (t) { return t.children ? t.children : t.loadChildren ? t._loadedConfig.routes : [] }(t), { segmentGroup: l, slicedSegments: c } = jc(e, i, o, a.filter(t => void 0 === t.redirectTo), this.relativeLinkResolution); if (0 === c.length && l.hasChildren()) { const t = this.processChildren(a, l); return null === t ? null : [new Yl(s, t)] } if (0 === a.length && 0 === c.length) return [new Yl(s, [])]; const u = Dc(t) === r, h = this.processSegment(a, l, c, u ? ul : r); return null === h ? null : [new Yl(s, h)] } } function su(t) { const e = t.value.routeConfig; return e && "" === e.path && void 0 === e.redirectTo } function iu(t) { const e = [], n = new Set; for (const r of t) { if (!su(r)) { e.push(r); continue } const t = e.find(t => r.value.routeConfig === t.value.routeConfig); void 0 !== t ? (t.children.push(...r.children), n.add(t)) : e.push(r) } for (const r of n) { const t = iu(r.children); e.push(new Yl(r.value, t)) } return e.filter(t => !n.has(t)) } function ou(t) { let e = t; for (; e._sourceSegment;)e = e._sourceSegment; return e } function au(t) { let e = t, n = e._segmentIndexShift ? e._segmentIndexShift : 0; for (; e._sourceSegment;)e = e._sourceSegment, n += e._segmentIndexShift ? e._segmentIndexShift : 0; return n - 1 } function lu(t) { return t.data || {} } function cu(t) { return t.resolve || {} } function uu(t) { return (0, Do.w)(e => { const n = t(e); return n ? (0, At.D)(n).pipe((0, Mt.U)(() => e)) : (0, Cs.of)(e) }) } class hu extends class { shouldDetach(t) { return !1 } store(t, e) { } shouldAttach(t) { return !1 } retrieve(t) { return null } shouldReuseRoute(t, e) { return t.routeConfig === e.routeConfig } }{ } const du = new r.OlP("ROUTES"); class pu { constructor(t, e, n, r) { this.loader = t, this.compiler = e, this.onLoadStartListener = n, this.onLoadEndListener = r } load(t, e) { if (e._loader$) return e._loader$; this.onLoadStartListener && this.onLoadStartListener(e); const n = this.loadModuleFactory(e.loadChildren).pipe((0, Mt.U)(n => { this.onLoadEndListener && this.onLoadEndListener(e); const s = n.create(t); return new Cc(_l(s.injector.get(du, void 0, r.XFs.Self | r.XFs.Optional)).map(Mc), s) }), (0, fi.K)(t => { throw e._loader$ = void 0, t })); return e._loader$ = new ka.c(n, () => new ai.xQ).pipe((0, za.x)()), e._loader$ } loadModuleFactory(t) { return "string" == typeof t ? (0, At.D)(this.loader.load(t)) : bl(t()).pipe((0, Ei.zg)(t => t instanceof r.YKP ? (0, Cs.of)(t) : (0, At.D)(this.compiler.compileModuleAsync(t)))) } } class fu { constructor() { this.outlet = null, this.route = null, this.resolver = null, this.children = new gu, this.attachRef = null } } class gu { constructor() { this.contexts = new Map } onChildOutletCreated(t, e) { const n = this.getOrCreateContext(t); n.outlet = e, this.contexts.set(t, n) } onChildOutletDestroyed(t) { const e = this.getContext(t); e && (e.outlet = null) } onOutletDeactivated() { const t = this.contexts; return this.contexts = new Map, t } onOutletReAttached(t) { this.contexts = t } getOrCreateContext(t) { let e = this.getContext(t); return e || (e = new fu, this.contexts.set(t, e)), e } getContext(t) { return this.contexts.get(t) || null } } class mu { shouldProcessUrl(t) { return !0 } extract(t) { return t } merge(t, e) { return t } } function _u(t) { throw t } function yu(t, e, n) { return e.parse("/") } function vu(t, e) { return (0, Cs.of)(null) } const bu = { paths: "exact", fragment: "ignored", matrixParams: "ignored", queryParams: "exact" }, wu = { paths: "subset", fragment: "ignored", matrixParams: "ignored", queryParams: "subset" }; let Eu = (() => { class t { constructor(t, e, n, s, i, o, a, l) { this.rootComponentType = t, this.urlSerializer = e, this.rootContexts = n, this.location = s, this.config = l, this.lastSuccessfulNavigation = null, this.currentNavigation = null, this.disposed = !1, this.lastLocationChangeInfo = null, this.navigationId = 0, this.currentPageId = 0, this.isNgZoneEnabled = !1, this.events = new ai.xQ, this.errorHandler = _u, this.malformedUriErrorHandler = yu, this.navigated = !1, this.lastSuccessfulId = -1, this.hooks = { beforePreactivation: vu, afterPreactivation: vu }, this.urlHandlingStrategy = new mu, this.routeReuseStrategy = new hu, this.onSameUrlNavigation = "ignore", this.paramsInheritanceStrategy = "emptyOnly", this.urlUpdateStrategy = "deferred", this.relativeLinkResolution = "corrected", this.canceledNavigationResolution = "replace", this.ngModule = i.get(r.h0i), this.console = i.get(r.c2e); const c = i.get(r.R0b); this.isNgZoneEnabled = c instanceof r.R0b && r.R0b.isInAngularZone(), this.resetConfig(l), this.currentUrlTree = new Tl(new Pl([], {}), {}, null), this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.configLoader = new pu(o, a, t => this.triggerEvent(new rl(t)), t => this.triggerEvent(new sl(t))), this.routerState = Xl(this.currentUrlTree, this.rootComponentType), this.transitions = new ma.X({ id: 0, targetPageId: 0, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree), urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree), rawUrl: this.currentUrlTree, extras: {}, resolve: null, reject: null, promise: Promise.resolve(!0), source: "imperative", restoredState: null, currentSnapshot: this.routerState.snapshot, targetSnapshot: null, currentRouterState: this.routerState, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.navigations = this.setupNavigations(this.transitions), this.processNavigations() } setupNavigations(t) { const e = this.events; return t.pipe((0, Os.h)(t => 0 !== t.id), (0, Mt.U)(t => Object.assign(Object.assign({}, t), { extractedUrl: this.urlHandlingStrategy.extract(t.rawUrl) })), (0, Do.w)(t => { let n = !1, r = !1; return (0, Cs.of)(t).pipe(Io(t => { this.currentNavigation = { id: t.id, initialUrl: t.currentRawUrl, extractedUrl: t.extractedUrl, trigger: t.source, extras: t.extras, previousNavigation: this.lastSuccessfulNavigation ? Object.assign(Object.assign({}, this.lastSuccessfulNavigation), { previousNavigation: null }) : null } }), (0, Do.w)(t => { const n = !this.navigated || t.extractedUrl.toString() !== this.browserUrlTree.toString(); if (("reload" === this.onSameUrlNavigation || n) && this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl)) return (0, Cs.of)(t).pipe((0, Do.w)(t => { const n = this.transitions.getValue(); return e.next(new Wa(t.id, this.serializeUrl(t.extractedUrl), t.source, t.restoredState)), n !== this.transitions.getValue() ? Ta.E : Promise.resolve(t) }), (r = this.ngModule.injector, s = this.configLoader, i = this.urlSerializer, o = this.config, (0, Do.w)(t => function (t, e, n, r, s) { return new Zc(t, e, n, r, s).apply() }(r, s, i, t.extractedUrl, o).pipe((0, Mt.U)(e => Object.assign(Object.assign({}, t), { urlAfterRedirects: e }))))), Io(t => { this.currentNavigation = Object.assign(Object.assign({}, this.currentNavigation), { finalUrl: t.urlAfterRedirects }) }), function (t, e, n, r, s) { return (0, Ei.zg)(i => function (t, e, n, r, s = "emptyOnly", i = "legacy") { try { const o = new ru(t, e, n, r, s, i).recognize(); return null === o ? nu(new eu) : (0, Cs.of)(o) } catch (o) { return nu(o) } }(t, e, i.urlAfterRedirects, n(i.urlAfterRedirects), r, s).pipe((0, Mt.U)(t => Object.assign(Object.assign({}, i), { targetSnapshot: t })))) }(this.rootComponentType, this.config, t => this.serializeUrl(t), this.paramsInheritanceStrategy, this.relativeLinkResolution), Io(t => { "eager" === this.urlUpdateStrategy && (t.extras.skipLocationChange || this.setBrowserUrl(t.urlAfterRedirects, t), this.browserUrlTree = t.urlAfterRedirects); const n = new Ja(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); e.next(n) })); var r, s, i, o; if (n && this.rawUrlTree && this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) { const { id: n, extractedUrl: r, source: s, restoredState: i, extras: o } = t, a = new Wa(n, this.serializeUrl(r), s, i); e.next(a); const l = Xl(r, this.rootComponentType).snapshot; return (0, Cs.of)(Object.assign(Object.assign({}, t), { targetSnapshot: l, urlAfterRedirects: r, extras: Object.assign(Object.assign({}, o), { skipLocationChange: !1, replaceUrl: !1 }) })) } return this.rawUrlTree = t.rawUrl, this.browserUrlTree = t.urlAfterRedirects, t.resolve(null), Ta.E }), uu(t => { const { targetSnapshot: e, id: n, extractedUrl: r, rawUrl: s, extras: { skipLocationChange: i, replaceUrl: o } } = t; return this.hooks.beforePreactivation(e, { navigationId: n, appliedUrlTree: r, rawUrlTree: s, skipLocationChange: !!i, replaceUrl: !!o }) }), Io(t => { const e = new Xa(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); this.triggerEvent(e) }), (0, Mt.U)(t => Object.assign(Object.assign({}, t), { guards: Qc(t.targetSnapshot, t.currentSnapshot, this.rootContexts) })), function (t, e) { return (0, Ei.zg)(n => { const { targetSnapshot: r, currentSnapshot: s, guards: { canActivateChecks: i, canDeactivateChecks: o } } = n; return 0 === o.length && 0 === i.length ? (0, Cs.of)(Object.assign(Object.assign({}, n), { guardsResult: !0 })) : function (t, e, n, r) { return (0, At.D)(t).pipe((0, Ei.zg)(t => function (t, e, n, r, s) { const i = e && e.routeConfig ? e.routeConfig.canDeactivate : null; if (!i || 0 === i.length) return (0, Cs.of)(!0); const o = i.map(i => { const o = Jc(i, e, s); let a; if (function (t) { return t && xc(t.canDeactivate) }(o)) a = bl(o.canDeactivate(t, e, n, r)); else { if (!xc(o)) throw new Error("Invalid CanDeactivate guard"); a = bl(o(t, e, n, r)) } return a.pipe($a()) }); return (0, Cs.of)(o).pipe(Pc()) }(t.component, t.route, n, e, r)), $a(t => !0 !== t, !0)) }(o, r, s, t).pipe((0, Ei.zg)(n => n && "boolean" == typeof n ? function (t, e, n, r) { return (0, At.D)(e).pipe((0, xs.b)(e => Oa(function (t, e) { return null !== t && e && e(new il(t)), (0, Cs.of)(!0) }(e.route.parent, r), function (t, e) { return null !== t && e && e(new al(t)), (0, Cs.of)(!0) }(e.route, r), function (t, e, n) { const r = e[e.length - 1], s = e.slice(0, e.length - 1).reverse().map(t => function (t) { const e = t.routeConfig ? t.routeConfig.canActivateChild : null; return e && 0 !== e.length ? { node: t, guards: e } : null }(t)).filter(t => null !== t).map(e => Pa(() => { const s = e.guards.map(s => { const i = Jc(s, e.node, n); let o; if (function (t) { return t && xc(t.canActivateChild) }(i)) o = bl(i.canActivateChild(r, t)); else { if (!xc(i)) throw new Error("Invalid CanActivateChild guard"); o = bl(i(r, t)) } return o.pipe($a()) }); return (0, Cs.of)(s).pipe(Pc()) })); return (0, Cs.of)(s).pipe(Pc()) }(t, e.path, n), function (t, e, n) { const r = e.routeConfig ? e.routeConfig.canActivate : null; if (!r || 0 === r.length) return (0, Cs.of)(!0); const s = r.map(r => Pa(() => { const s = Jc(r, e, n); let i; if (function (t) { return t && xc(t.canActivate) }(s)) i = bl(s.canActivate(e, t)); else { if (!xc(s)) throw new Error("Invalid CanActivate guard"); i = bl(s(e, t)) } return i.pipe($a()) })); return (0, Cs.of)(s).pipe(Pc()) }(t, e.route, n))), $a(t => !0 !== t, !0)) }(r, i, t, e) : (0, Cs.of)(n)), (0, Mt.U)(t => Object.assign(Object.assign({}, n), { guardsResult: t }))) }) }(this.ngModule.injector, t => this.triggerEvent(t)), Io(t => { if (Oc(t.guardsResult)) { const e = pl(`Redirecting to "${this.serializeUrl(t.guardsResult)}"`); throw e.url = t.guardsResult, e } const e = new tl(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot, !!t.guardsResult); this.triggerEvent(e) }), (0, Os.h)(t => !!t.guardsResult || (this.cancelNavigationTransition(t, ""), !1)), uu(t => { if (t.guards.canActivateChecks.length) return (0, Cs.of)(t).pipe(Io(t => { const e = new el(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); this.triggerEvent(e) }), (0, Do.w)(t => { let e = !1; return (0, Cs.of)(t).pipe((n = this.paramsInheritanceStrategy, r = this.ngModule.injector, (0, Ei.zg)(t => { const { targetSnapshot: e, guards: { canActivateChecks: s } } = t; if (!s.length) return (0, Cs.of)(t); let i = 0; return (0, At.D)(s).pipe((0, xs.b)(t => function (t, e, n, r) { return function (t, e, n, r) { const s = Object.keys(t); if (0 === s.length) return (0, Cs.of)({}); const i = {}; return (0, At.D)(s).pipe((0, Ei.zg)(s => function (t, e, n, r) { const s = Jc(t, e, r); return bl(s.resolve ? s.resolve(e, n) : s(e, n)) }(t[s], e, n, r).pipe(Io(t => { i[s] = t }))), Ra(1), (0, Ei.zg)(() => Object.keys(i).length === s.length ? (0, Cs.of)(i) : Ta.E)) }(t._resolve, t, e, r).pipe((0, Mt.U)(e => (t._resolvedData = e, t.data = Object.assign(Object.assign({}, t.data), ec(t, n).resolve), null))) }(t.route, e, n, r)), Io(() => i++), Ra(1), (0, Ei.zg)(e => i === s.length ? (0, Cs.of)(t) : Ta.E)) })), Io({ next: () => e = !0, complete: () => { e || this.cancelNavigationTransition(t, "At least one route resolver didn't emit any value.") } })); var n, r }), Io(t => { const e = new nl(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); this.triggerEvent(e) })) }), uu(t => { const { targetSnapshot: e, id: n, extractedUrl: r, rawUrl: s, extras: { skipLocationChange: i, replaceUrl: o } } = t; return this.hooks.afterPreactivation(e, { navigationId: n, appliedUrlTree: r, rawUrlTree: s, skipLocationChange: !!i, replaceUrl: !!o }) }), (0, Mt.U)(t => { const e = function (t, e, n) { const r = lc(t, e._root, n ? n._root : void 0); return new Jl(r, e) }(this.routeReuseStrategy, t.targetSnapshot, t.currentRouterState); return Object.assign(Object.assign({}, t), { targetRouterState: e }) }), Io(t => { this.currentUrlTree = t.urlAfterRedirects, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, t.rawUrl), this.routerState = t.targetRouterState, "deferred" === this.urlUpdateStrategy && (t.extras.skipLocationChange || this.setBrowserUrl(this.rawUrlTree, t), this.browserUrlTree = t.urlAfterRedirects) }), (i = this.rootContexts, o = this.routeReuseStrategy, a = t => this.triggerEvent(t), (0, Mt.U)(t => (new Ec(o, t.targetRouterState, t.currentRouterState, a).activate(i), t))), Io({ next() { n = !0 }, complete() { n = !0 } }), (s = () => { n || r || this.cancelNavigationTransition(t, `Navigation ID ${t.id} is not equal to the current navigation id ${this.navigationId}`), this.currentNavigation = null }, t => t.lift(new Ha(s))), (0, fi.K)(n => { if (r = !0, (s = n) && s.ngNavigationCancelingError) { const r = Oc(n.url); r || (this.navigated = !0, this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl)); const s = new Ya(t.id, this.serializeUrl(t.extractedUrl), n.message); e.next(s), r ? setTimeout(() => { const e = this.urlHandlingStrategy.merge(n.url, this.rawUrlTree); this.scheduleNavigation(e, "imperative", null, { skipLocationChange: t.extras.skipLocationChange, replaceUrl: "eager" === this.urlUpdateStrategy }, { resolve: t.resolve, reject: t.reject, promise: t.promise }) }, 0) : t.resolve(!1) } else { this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl); const r = new Qa(t.id, this.serializeUrl(t.extractedUrl), n); e.next(r); try { t.resolve(this.errorHandler(n)) } catch (i) { t.reject(i) } } var s; return Ta.E })); var s, i, o, a })) } resetRootComponentType(t) { this.rootComponentType = t, this.routerState.root.component = this.rootComponentType } getTransition() { const t = this.transitions.value; return t.urlAfterRedirects = this.browserUrlTree, t } setTransition(t) { this.transitions.next(Object.assign(Object.assign({}, this.getTransition()), t)) } initialNavigation() { this.setUpLocationChangeListener(), 0 === this.navigationId && this.navigateByUrl(this.location.path(!0), { replaceUrl: !0 }) } setUpLocationChangeListener() { this.locationSubscription || (this.locationSubscription = this.location.subscribe(t => { const e = this.extractLocationChangeInfoFromEvent(t); this.shouldScheduleNavigation(this.lastLocationChangeInfo, e) && setTimeout(() => { const { source: t, state: n, urlTree: r } = e, s = { replaceUrl: !0 }; if (n) { const t = Object.assign({}, n); delete t.navigationId, delete t.\u0275routerPageId, 0 !== Object.keys(t).length && (s.state = t) } this.scheduleNavigation(r, t, n, s) }, 0), this.lastLocationChangeInfo = e })) } extractLocationChangeInfoFromEvent(t) { var e; return { source: "popstate" === t.type ? "popstate" : "hashchange", urlTree: this.parseUrl(t.url), state: (null === (e = t.state) || void 0 === e ? void 0 : e.navigationId) ? t.state : null, transitionId: this.getTransition().id } } shouldScheduleNavigation(t, e) { if (!t) return !0; const n = e.urlTree.toString() === t.urlTree.toString(); return !(e.transitionId === t.transitionId && n && ("hashchange" === e.source && "popstate" === t.source || "popstate" === e.source && "hashchange" === t.source)) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.currentNavigation } triggerEvent(t) { this.events.next(t) } resetConfig(t) { Ac(t), this.config = t.map(Mc), this.navigated = !1, this.lastSuccessfulId = -1 } ngOnDestroy() { this.dispose() } dispose() { this.transitions.complete(), this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = void 0), this.disposed = !0 } createUrlTree(t, e = {}) { const { relativeTo: n, queryParams: r, fragment: s, queryParamsHandling: i, preserveFragment: o } = e, a = n || this.routerState.root, l = o ? this.currentUrlTree.fragment : s; let c = null; switch (i) { case "merge": c = Object.assign(Object.assign({}, this.currentUrlTree.queryParams), r); break; case "preserve": c = this.currentUrlTree.queryParams; break; default: c = r || null }return null !== c && (c = this.removeEmptyProps(c)), function (t, e, n, r, s) { if (0 === n.length) return dc(e.root, e.root, e, r, s); const i = function (t) { if ("string" == typeof t[0] && 1 === t.length && "/" === t[0]) return new fc(!0, 0, t); let e = 0, n = !1; const r = t.reduce((t, r, s) => { if ("object" == typeof r && null != r) { if (r.outlets) { const e = {}; return vl(r.outlets, (t, n) => { e[n] = "string" == typeof t ? t.split("/") : t }), [...t, { outlets: e }] } if (r.segmentPath) return [...t, r.segmentPath] } return "string" != typeof r ? [...t, r] : 0 === s ? (r.split("/").forEach((r, s) => { 0 == s && "." === r || (0 == s && "" === r ? n = !0 : ".." === r ? e++ : "" != r && t.push(r)) }), t) : [...t, r] }, []); return new fc(n, e, r) }(n); if (i.toRoot()) return dc(e.root, new Pl([], {}), e, r, s); const o = function (t, e, n) { if (t.isAbsolute) return new gc(e.root, !0, 0); if (-1 === n.snapshot._lastPathIndex) { const t = n.snapshot._urlSegment; return new gc(t, t === e.root, 0) } const r = uc(t.commands[0]) ? 0 : 1; return function (t, e, n) { let r = t, s = e, i = n; for (; i > s;) { if (i -= s, r = r.parent, !r) throw new Error("Invalid number of '../'"); s = r.segments.length } return new gc(r, !1, s - i) }(n.snapshot._urlSegment, n.snapshot._lastPathIndex + r, t.numberOfDoubleDots) }(i, e, t), a = o.processChildren ? _c(o.segmentGroup, o.index, i.commands) : mc(o.segmentGroup, o.index, i.commands); return dc(o.segmentGroup, a, e, r, s) }(a, this.currentUrlTree, t, c, null != l ? l : null) } navigateByUrl(t, e = { skipLocationChange: !1 }) { const n = Oc(t) ? t : this.parseUrl(t), r = this.urlHandlingStrategy.merge(n, this.rawUrlTree); let s = null; return "computed" === this.canceledNavigationResolution && (0 === this.currentPageId || e.skipLocationChange || e.replaceUrl) && (s = this.location.getState()), this.scheduleNavigation(r, "imperative", s, e) } navigate(t, e = { skipLocationChange: !1 }) { return function (t) { for (let e = 0; e < t.length; e++) { const n = t[e]; if (null == n) throw new Error(`The requested path contains ${n} segment at index ${e}`) } }(t), this.navigateByUrl(this.createUrlTree(t, e), e) } serializeUrl(t) { return this.urlSerializer.serialize(t) } parseUrl(t) { let e; try { e = this.urlSerializer.parse(t) } catch (n) { e = this.malformedUriErrorHandler(n, this.urlSerializer, t) } return e } isActive(t, e) { let n; if (n = !0 === e ? Object.assign({}, bu) : !1 === e ? Object.assign({}, wu) : e, Oc(t)) return Sl(this.currentUrlTree, t, n); const r = this.parseUrl(t); return Sl(this.currentUrlTree, r, n) } removeEmptyProps(t) { return Object.keys(t).reduce((e, n) => { const r = t[n]; return null != r && (e[n] = r), e }, {}) } processNavigations() { this.navigations.subscribe(t => { this.navigated = !0, this.lastSuccessfulId = t.id, this.currentPageId = t.targetPageId, this.events.next(new Ka(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(this.currentUrlTree))), this.lastSuccessfulNavigation = this.currentNavigation, t.resolve(!0) }, t => { this.console.warn("Unhandled Navigation Error: ") }) } scheduleNavigation(t, e, n, r, s) { if (this.disposed) return Promise.resolve(!1); const i = this.getTransition(), o = "imperative" !== e && "imperative" === (null == i ? void 0 : i.source), a = (this.lastSuccessfulId === i.id || this.currentNavigation ? i.rawUrl : i.urlAfterRedirects).toString() === t.toString(); if (o && a) return Promise.resolve(!0); let l, c, u; s ? (l = s.resolve, c = s.reject, u = s.promise) : u = new Promise((t, e) => { l = t, c = e }); const h = ++this.navigationId; let d; return d = "computed" === this.canceledNavigationResolution ? n && n.\u0275routerPageId ? n.\u0275routerPageId : this.currentPageId + 1 : 0, this.setTransition({ id: h, targetPageId: d, source: e, restoredState: n, currentUrlTree: this.currentUrlTree, currentRawUrl: this.rawUrlTree, rawUrl: t, extras: r, resolve: l, reject: c, promise: u, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), u.catch(t => Promise.reject(t)) } setBrowserUrl(t, e) { const n = this.urlSerializer.serialize(t), r = Object.assign(Object.assign({}, e.extras.state), this.generateNgRouterState(e.id, e.targetPageId)); this.location.isCurrentPathEqualTo(n) || e.extras.replaceUrl ? this.location.replaceState(n, "", r) : this.location.go(n, "", r) } resetStateAndUrl(t, e, n) { this.routerState = t, this.currentUrlTree = e, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, n), this.resetUrlToCurrentUrlTree() } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId)) } cancelNavigationTransition(t, e) { "computed" === this.canceledNavigationResolution ? "popstate" !== t.source && "eager" !== this.urlUpdateStrategy || this.location.historyGo(this.currentPageId - t.targetPageId) : this.resetUrlToCurrentUrlTree(); const n = new Ya(t.id, this.serializeUrl(t.extractedUrl), e); this.triggerEvent(n), t.resolve(!1) } generateNgRouterState(t, e) { return "computed" === this.canceledNavigationResolution ? { navigationId: t, "\u0275routerPageId": e } : { navigationId: t } } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(r.DyG), r.LFG(Il), r.LFG(gu), r.LFG(w), r.LFG(r.zs3), r.LFG(r.v3s), r.LFG(r.Sil), r.LFG(void 0)) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(), Su = (() => { class t { constructor(t, e, n, r, s) { this.router = t, this.route = e, this.commands = [], this.onChanges = new ai.xQ, null == n && r.setAttribute(s.nativeElement, "tabindex", "0") } ngOnChanges(t) { this.onChanges.next(this) } set routerLink(t) { this.commands = null != t ? Array.isArray(t) ? t : [t] : [] } onClick() { const t = { skipLocationChange: xu(this.skipLocationChange), replaceUrl: xu(this.replaceUrl), state: this.state }; return this.router.navigateByUrl(this.urlTree, t), !0 } get urlTree() { return this.router.createUrlTree(this.commands, { relativeTo: void 0 !== this.relativeTo ? this.relativeTo : this.route, queryParams: this.queryParams, fragment: this.fragment, queryParamsHandling: this.queryParamsHandling, preserveFragment: xu(this.preserveFragment) }) } } return t.\u0275fac = function (e) { return new (e || t)(r.Y36(Eu), r.Y36(tc), r.$8M("tabindex"), r.Y36(r.Qsj), r.Y36(r.SBq)) }, t.\u0275dir = r.lG2({ type: t, selectors: [["", "routerLink", "", 5, "a", 5, "area"]], hostBindings: function (t, e) { 1 & t && r.NdJ("click", function () { return e.onClick() }) }, inputs: { routerLink: "routerLink", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", state: "state", relativeTo: "relativeTo" }, features: [r.TTD] }), t })(), Cu = (() => { class t { constructor(t, e, n) { this.router = t, this.route = e, this.locationStrategy = n, this.commands = [], this.onChanges = new ai.xQ, this.subscription = t.events.subscribe(t => { t instanceof Ka && this.updateTargetUrlAndHref() }) } set routerLink(t) { this.commands = null != t ? Array.isArray(t) ? t : [t] : [] } ngOnChanges(t) { this.updateTargetUrlAndHref(), this.onChanges.next(this) } ngOnDestroy() { this.subscription.unsubscribe() } onClick(t, e, n, r, s) { if (0 !== t || e || n || r || s) return !0; if ("string" == typeof this.target && "_self" != this.target) return !0; const i = { skipLocationChange: xu(this.skipLocationChange), replaceUrl: xu(this.replaceUrl), state: this.state }; return this.router.navigateByUrl(this.urlTree, i), !1 } updateTargetUrlAndHref() { this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree)) } get urlTree() { return this.router.createUrlTree(this.commands, { relativeTo: void 0 !== this.relativeTo ? this.relativeTo : this.route, queryParams: this.queryParams, fragment: this.fragment, queryParamsHandling: this.queryParamsHandling, preserveFragment: xu(this.preserveFragment) }) } } return t.\u0275fac = function (e) { return new (e || t)(r.Y36(Eu), r.Y36(tc), r.Y36(m)) }, t.\u0275dir = r.lG2({ type: t, selectors: [["a", "routerLink", ""], ["area", "routerLink", ""]], hostVars: 2, hostBindings: function (t, e) { 1 & t && r.NdJ("click", function (t) { return e.onClick(t.button, t.ctrlKey, t.shiftKey, t.altKey, t.metaKey) }), 2 & t && (r.Ikx("href", e.href, r.LSH), r.uIk("target", e.target)) }, inputs: { routerLink: "routerLink", target: "target", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", state: "state", relativeTo: "relativeTo" }, features: [r.TTD] }), t })(); function xu(t) { return "" === t || !!t } let Ou = (() => { class t { constructor(t, e, n, r, s, i) { this.router = t, this.element = e, this.renderer = n, this.cdr = r, this.link = s, this.linkWithHref = i, this.classes = [], this.isActive = !1, this.routerLinkActiveOptions = { exact: !1 }, this.routerEventsSubscription = t.events.subscribe(t => { t instanceof Ka && this.update() }) } ngAfterContentInit() { (0, Cs.of)(this.links.changes, this.linksWithHrefs.changes, (0, Cs.of)(null)).pipe((0, xa.J)()).subscribe(t => { this.update(), this.subscribeToEachLinkOnChanges() }) } subscribeToEachLinkOnChanges() { var t; null === (t = this.linkInputChangesSubscription) || void 0 === t || t.unsubscribe(); const e = [...this.links.toArray(), ...this.linksWithHrefs.toArray(), this.link, this.linkWithHref].filter(t => !!t).map(t => t.onChanges); this.linkInputChangesSubscription = (0, At.D)(e).pipe((0, xa.J)()).subscribe(t => { this.isActive !== this.isLinkActive(this.router)(t) && this.update() }) } set routerLinkActive(t) { const e = Array.isArray(t) ? t : t.split(" "); this.classes = e.filter(t => !!t) } ngOnChanges(t) { this.update() } ngOnDestroy() { var t; this.routerEventsSubscription.unsubscribe(), null === (t = this.linkInputChangesSubscription) || void 0 === t || t.unsubscribe() } update() { this.links && this.linksWithHrefs && this.router.navigated && Promise.resolve().then(() => { const t = this.hasActiveLinks(); this.isActive !== t && (this.isActive = t, this.cdr.markForCheck(), this.classes.forEach(e => { t ? this.renderer.addClass(this.element.nativeElement, e) : this.renderer.removeClass(this.element.nativeElement, e) })) }) } isLinkActive(t) { const e = "paths" in this.routerLinkActiveOptions ? this.routerLinkActiveOptions : this.routerLinkActiveOptions.exact || !1; return n => t.isActive(n.urlTree, e) } hasActiveLinks() { const t = this.isLinkActive(this.router); return this.link && t(this.link) || this.linkWithHref && t(this.linkWithHref) || this.links.some(t) || this.linksWithHrefs.some(t) } } return t.\u0275fac = function (e) { return new (e || t)(r.Y36(Eu), r.Y36(r.SBq), r.Y36(r.Qsj), r.Y36(r.sBO), r.Y36(Su, 8), r.Y36(Cu, 8)) }, t.\u0275dir = r.lG2({ type: t, selectors: [["", "routerLinkActive", ""]], contentQueries: function (t, e, n) { if (1 & t && (r.Suo(n, Su, 5), r.Suo(n, Cu, 5)), 2 & t) { let t; r.iGM(t = r.CRH()) && (e.links = t), r.iGM(t = r.CRH()) && (e.linksWithHrefs = t) } }, inputs: { routerLinkActiveOptions: "routerLinkActiveOptions", routerLinkActive: "routerLinkActive" }, exportAs: ["routerLinkActive"], features: [r.TTD] }), t })(), Tu = (() => { class t { constructor(t, e, n, s, i) { this.parentContexts = t, this.location = e, this.resolver = n, this.changeDetector = i, this.activated = null, this._activatedRoute = null, this.activateEvents = new r.vpe, this.deactivateEvents = new r.vpe, this.name = s || ul, t.onChildOutletCreated(this.name, this) } ngOnDestroy() { this.parentContexts.onChildOutletDestroyed(this.name) } ngOnInit() { if (!this.activated) { const t = this.parentContexts.getContext(this.name); t && t.route && (t.attachRef ? this.attach(t.attachRef, t.route) : this.activateWith(t.route, t.resolver || null)) } } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new Error("Outlet is not activated"); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new Error("Outlet is not activated"); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new Error("Outlet is not activated"); this.location.detach(); const t = this.activated; return this.activated = null, this._activatedRoute = null, t } attach(t, e) { this.activated = t, this._activatedRoute = e, this.location.insert(t.hostView) } deactivate() { if (this.activated) { const t = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(t) } } activateWith(t, e) { if (this.isActivated) throw new Error("Cannot activate an already activated outlet"); this._activatedRoute = t; const n = (e = e || this.resolver).resolveComponentFactory(t._futureSnapshot.routeConfig.component), r = this.parentContexts.getOrCreateContext(this.name).children, s = new Pu(t, r, this.location.injector); this.activated = this.location.createComponent(n, this.location.length, s), this.changeDetector.markForCheck(), this.activateEvents.emit(this.activated.instance) } } return t.\u0275fac = function (e) { return new (e || t)(r.Y36(gu), r.Y36(r.s_b), r.Y36(r._Vd), r.$8M("name"), r.Y36(r.sBO)) }, t.\u0275dir = r.lG2({ type: t, selectors: [["router-outlet"]], outputs: { activateEvents: "activate", deactivateEvents: "deactivate" }, exportAs: ["outlet"] }), t })(); class Pu { constructor(t, e, n) { this.route = t, this.childContexts = e, this.parent = n } get(t, e) { return t === tc ? this.route : t === gu ? this.childContexts : this.parent.get(t, e) } } class ku { } class Au { preload(t, e) { return (0, Cs.of)(null) } } let Iu = (() => { class t { constructor(t, e, n, r, s) { this.router = t, this.injector = r, this.preloadingStrategy = s, this.loader = new pu(e, n, e => t.triggerEvent(new rl(e)), e => t.triggerEvent(new sl(e))) } setUpPreloading() { this.subscription = this.router.events.pipe((0, Os.h)(t => t instanceof Ka), (0, xs.b)(() => this.preload())).subscribe(() => { }) } preload() { const t = this.injector.get(r.h0i); return this.processRoutes(t, this.router.config) } ngOnDestroy() { this.subscription && this.subscription.unsubscribe() } processRoutes(t, e) { const n = []; for (const r of e) if (r.loadChildren && !r.canLoad && r._loadedConfig) { const t = r._loadedConfig; n.push(this.processRoutes(t.module, t.routes)) } else r.loadChildren && !r.canLoad ? n.push(this.preloadConfig(t, r)) : r.children && n.push(this.processRoutes(t, r.children)); return (0, At.D)(n).pipe((0, xa.J)(), (0, Mt.U)(t => { })) } preloadConfig(t, e) { return this.preloadingStrategy.preload(e, () => (e._loadedConfig ? (0, Cs.of)(e._loadedConfig) : this.loader.load(t.injector, e)).pipe((0, Ei.zg)(t => (e._loadedConfig = t, this.processRoutes(t.module, t.routes))))) } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(Eu), r.LFG(r.v3s), r.LFG(r.Sil), r.LFG(r.zs3), r.LFG(ku)) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(), Ru = (() => { class t { constructor(t, e, n = {}) { this.router = t, this.viewportScroller = e, this.options = n, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, n.scrollPositionRestoration = n.scrollPositionRestoration || "disabled", n.anchorScrolling = n.anchorScrolling || "disabled" } init() { "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.router.events.subscribe(t => { t instanceof Wa ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = t.navigationTrigger, this.restoredId = t.restoredState ? t.restoredState.navigationId : 0) : t instanceof Ka && (this.lastId = t.id, this.scheduleScrollEvent(t, this.router.parseUrl(t.urlAfterRedirects).fragment)) }) } consumeScrollEvents() { return this.router.events.subscribe(t => { t instanceof cl && (t.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(t.position) : t.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(t.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(t, e) { this.router.triggerEvent(new cl(t, "popstate" === this.lastSource ? this.store[this.restoredId] : null, e)) } ngOnDestroy() { this.routerEventsSubscription && this.routerEventsSubscription.unsubscribe(), this.scrollEventsSubscription && this.scrollEventsSubscription.unsubscribe() } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(Eu), r.LFG(Y), r.LFG(void 0)) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(); const Mu = new r.OlP("ROUTER_CONFIGURATION"), Du = new r.OlP("ROUTER_FORROOT_GUARD"), Lu = [w, { provide: Il, useClass: Rl }, { provide: Eu, useFactory: function (t, e, n, r, s, i, o, a = {}, l, c) { const u = new Eu(null, t, e, n, r, s, i, _l(o)); return l && (u.urlHandlingStrategy = l), c && (u.routeReuseStrategy = c), function (t, e) { t.errorHandler && (e.errorHandler = t.errorHandler), t.malformedUriErrorHandler && (e.malformedUriErrorHandler = t.malformedUriErrorHandler), t.onSameUrlNavigation && (e.onSameUrlNavigation = t.onSameUrlNavigation), t.paramsInheritanceStrategy && (e.paramsInheritanceStrategy = t.paramsInheritanceStrategy), t.relativeLinkResolution && (e.relativeLinkResolution = t.relativeLinkResolution), t.urlUpdateStrategy && (e.urlUpdateStrategy = t.urlUpdateStrategy) }(a, u), a.enableTracing && u.events.subscribe(t => { var e, n; null === (e = console.group) || void 0 === e || e.call(console, `Router Event: ${t.constructor.name}`), console.log(t.toString()), console.log(t), null === (n = console.groupEnd) || void 0 === n || n.call(console) }), u }, deps: [Il, gu, w, r.zs3, r.v3s, r.Sil, du, Mu, [class { }, new r.FiY], [class { }, new r.FiY]] }, gu, { provide: tc, useFactory: function (t) { return t.routerState.root }, deps: [Eu] }, { provide: r.v3s, useClass: r.EAV }, Iu, Au, class { preload(t, e) { return e().pipe((0, fi.K)(() => (0, Cs.of)(null))) } }, { provide: Mu, useValue: { enableTracing: !1 } }]; function Nu() { return new r.PXZ("Router", Eu) } let Fu = (() => { class t { constructor(t, e) { } static forRoot(e, n) { return { ngModule: t, providers: [Lu, Bu(e), { provide: Du, useFactory: Vu, deps: [[Eu, new r.FiY, new r.tp0]] }, { provide: Mu, useValue: n || {} }, { provide: m, useFactory: Uu, deps: [a, [new r.tBr(y), new r.FiY], Mu] }, { provide: Ru, useFactory: ju, deps: [Eu, Y, Mu] }, { provide: ku, useExisting: n && n.preloadingStrategy ? n.preloadingStrategy : Au }, { provide: r.PXZ, multi: !0, useFactory: Nu }, [qu, { provide: r.ip1, multi: !0, useFactory: $u, deps: [qu] }, { provide: Hu, useFactory: zu, deps: [qu] }, { provide: r.tb, multi: !0, useExisting: Hu }]] } } static forChild(e) { return { ngModule: t, providers: [Bu(e)] } } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(Du, 8), r.LFG(Eu, 8)) }, t.\u0275mod = r.oAB({ type: t }), t.\u0275inj = r.cJS({}), t })(); function ju(t, e, n) { return n.scrollOffset && e.setOffset(n.scrollOffset), new Ru(t, e, n) } function Uu(t, e, n = {}) { return n.useHash ? new b(t, e) : new v(t, e) } function Vu(t) { return "guarded" } function Bu(t) { return [{ provide: r.deG, multi: !0, useValue: t }, { provide: du, multi: !0, useValue: t }] } let qu = (() => { class t { constructor(t) { this.injector = t, this.initNavigation = !1, this.resultOfPreactivationDone = new ai.xQ } appInitializer() { return this.injector.get(c, Promise.resolve(null)).then(() => { let t = null; const e = new Promise(e => t = e), n = this.injector.get(Eu), r = this.injector.get(Mu); return "disabled" === r.initialNavigation ? (n.setUpLocationChangeListener(), t(!0)) : "enabled" === r.initialNavigation || "enabledBlocking" === r.initialNavigation ? (n.hooks.afterPreactivation = () => this.initNavigation ? (0, Cs.of)(null) : (this.initNavigation = !0, t(!0), this.resultOfPreactivationDone), n.initialNavigation()) : t(!0), e }) } bootstrapListener(t) { const e = this.injector.get(Mu), n = this.injector.get(Iu), s = this.injector.get(Ru), i = this.injector.get(Eu), o = this.injector.get(r.z2F); t === o.components[0] && ("enabledNonBlocking" !== e.initialNavigation && void 0 !== e.initialNavigation || i.initialNavigation(), n.setUpPreloading(), s.init(), i.resetRootComponentType(o.componentTypes[0]), this.resultOfPreactivationDone.next(null), this.resultOfPreactivationDone.complete()) } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(r.zs3)) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac }), t })(); function $u(t) { return t.appInitializer.bind(t) } function zu(t) { return t.bootstrapListener.bind(t) } const Hu = new r.OlP("Router Initializer"); var Gu = n(3588); function Zu(t, e) { if (1 & t && (r.TgZ(0, "option", 6), r._uU(1), r.qZA()), 2 & t) { const t = e.$implicit; r.Q6J("value", t), r.xp6(1), r.hij(" ", t, " ") } } let Wu = (() => { class t { constructor() { this.setFilter = new r.vpe, this.types = ["fire", "water", "grass", "poison", "bug", "dragon", "fighting", "ghost", "flying", "ice", "normal", "psychic", "rock"], this.filterByCopy = { name: "", type: "" } } ngOnInit() { } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = r.Xpm({ type: t, selectors: [["app-filter"]], inputs: { filterBy: "filterBy" }, outputs: { setFilter: "setFilter" }, decls: 8, vars: 3, consts: [[1, "filter", "flex"], ["type", "text", "name", "name", "autocomplete", "off", "placeholder", "Pokemon name...", 3, "ngModel", "ngModelChange"], ["for", "drop-down"], ["name", "types", 1, "drop-down", 3, "ngModel", "ngModelChange"], ["value", ""], [3, "value", 4, "ngFor", "ngForOf"], [3, "value"]], template: function (t, e) { 1 & t && (r.TgZ(0, "section", 0), r.TgZ(1, "input", 1), r.NdJ("ngModelChange", function (t) { return e.filterByCopy.name = t })("ngModelChange", function () { return e.setFilter.emit(e.filterByCopy) }), r.qZA(), r.TgZ(2, "label", 2), r._uU(3, "Filter by type "), r.TgZ(4, "select", 3), r.NdJ("ngModelChange", function (t) { return e.filterByCopy.type = t })("ngModelChange", function () { return e.setFilter.emit(e.filterByCopy) }), r.TgZ(5, "option", 4), r._uU(6, "all"), r.qZA(), r.YNc(7, Zu, 2, 2, "option", 5), r.qZA(), r.qZA(), r.qZA()), 2 & t && (r.xp6(1), r.Q6J("ngModel", e.filterByCopy.name), r.xp6(3), r.Q6J("ngModel", e.filterByCopy.type), r.xp6(3), r.Q6J("ngForOf", e.types)) }, directives: [Bt, ne, Te, Re, Me, Fe, F], styles: [".filter[_ngcontent-%COMP%]{padding:.9375rem;align-items:center;justify-content:center}.filter[_ngcontent-%COMP%] > *[_ngcontent-%COMP%]{margin-inline-end:.625rem}.filter[_ngcontent-%COMP%]   input[_ngcontent-%COMP%], .filter[_ngcontent-%COMP%]   label[_ngcontent-%COMP%], .filter[_ngcontent-%COMP%]   select[_ngcontent-%COMP%]{font-size:1.125rem;outline:none;border:none}.filter[_ngcontent-%COMP%]   input[_ngcontent-%COMP%], .filter[_ngcontent-%COMP%]   option[_ngcontent-%COMP%], .filter[_ngcontent-%COMP%]   select[_ngcontent-%COMP%]{padding:.3125rem;border-radius:.5rem;background-color:#f1eeee;color:#1e2020}@media screen and (max-width:770px){.filter[_ngcontent-%COMP%]{flex-direction:column;align-items:flex-start}.filter[_ngcontent-%COMP%]   label[for=drop-down][_ngcontent-%COMP%]{margin-block-start:.9375rem}}"] }), t })(); function Ku(t, e) { 1 & t && (r.TgZ(0, "div"), r._uU(1, "Loading..."), r.qZA()) } const Yu = function (t) { return ["/poke", t] }; function Qu(t, e) { if (1 & t && (r.TgZ(0, "article", 4), r.TgZ(1, "div", 5), r._UZ(2, "img", 6), r.qZA(), r.TgZ(3, "div", 7), r.TgZ(4, "span", 8), r._uU(5), r.qZA(), r.qZA(), r.qZA()), 2 & t) { const t = e.$implicit; r.Q6J("routerLink", r.VKq(3, Yu, t.name)), r.xp6(2), r.Q6J("src", t.sprites.front_default, r.LSH), r.xp6(3), r.Oqu(t.name) } } const Ju = function (t) { return { itemsPerPage: 10, currentPage: t, totalItems: 1118 } }; let Xu = (() => { class t { constructor() { this.pokes = [], this.setPage = new r.vpe, this.page = 1, this.total = 1118 } ngOnInit() { } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = r.Xpm({ type: t, selectors: [["app-list"]], inputs: { pokes: "pokes" }, outputs: { setPage: "setPage" }, decls: 5, vars: 7, consts: [[1, "app-list", "grid"], [4, "ngIf"], ["class", "card flex", 3, "routerLink", 4, "ngFor", "ngForOf"], [3, "pageChange"], [1, "card", "flex", 3, "routerLink"], [1, "img-container"], ["alt", "pokemon", 3, "src"], [1, "txt-container", "flex"], [1, "name"]], template: function (t, e) { 1 & t && (r.TgZ(0, "section", 0), r.YNc(1, Ku, 2, 0, "div", 1), r.YNc(2, Qu, 6, 5, "article", 2), r.ALo(3, "paginate"), r.qZA(), r.TgZ(4, "pagination-controls", 3), r.NdJ("pageChange", function (t) { return e.page = t, e.pokes = [], e.setPage.emit(e.page) }), r.qZA()), 2 & t && (r.xp6(1), r.Q6J("ngIf", !e.pokes), r.xp6(1), r.Q6J("ngForOf", r.xi3(3, 2, e.pokes, r.VKq(5, Ju, e.page)))) }, directives: [U, F, ha, Su], pipes: [aa], styles: [".app-list[_ngcontent-%COMP%]{grid-template-columns:repeat(auto-fit,minmax(250px,1fr));grid-gap:15px;gap:15px;margin-block-end:20px}pagination-controls[_ngcontent-%COMP%]{text-align:center}"] }), t })(); function th(t, e) { if (1 & t && (r.TgZ(0, "div", 6), r._uU(1), r.ALo(2, "async"), r.qZA()), 2 & t) { const t = r.oxw(); r.xp6(1), r.hij("", r.lcZ(2, 1, t.error$), " ") } } function eh(t, e) { 1 & t && (r.TgZ(0, "div", 7), r._uU(1, "Loading..."), r.qZA()) } let nh = (() => { class t { constructor(t, e) { this.store = t, this.pokeService = e, this.pokes$ = this.store.select("pokeState").pipe((0, Gu.j)("pokes")), this.isLoading$ = this.store.select("pokeState").pipe((0, Gu.j)("isLoading")), this.error$ = this.store.select("pokeState").pipe((0, Gu.j)("error")), this.filterBy = { name: "", type: "" } } ngOnInit() { this.store.dispatch(new So), this.store.dispatch(new bo(this.filterBy)), this.pokes$.subscribe(t => { this.pokes = t }) } onSetFilter(t) { this.filterBy = t, this.store.dispatch(new bo(Object.assign({}, this.filterBy))) } onNextPage(t) { var e = this; return No(function* () { yield e.pokeService.getDataFromApi(10, `${t}0`), e.store.dispatch(new bo(Object.assign({}, e.filterBy))), e.pokes$.subscribe(t => { e.pokes = [...t] }) })() } } return t.\u0275fac = function (e) { return new (e || t)(r.Y36(ii.yh), r.Y36(Go)) }, t.\u0275cmp = r.Xpm({ type: t, selectors: [["mister-dex"]], decls: 8, vars: 8, consts: [[1, "mister-dex"], ["class", "error-msg", 4, "ngIf"], ["else", "pokeList", 4, "ngIf"], [3, "filterBy", "setFilter"], [3, "pokes", "setPage"], ["pokeList", ""], [1, "error-msg"], ["else", "pokeList"]], template: function (t, e) { 1 & t && (r.TgZ(0, "section", 0), r.YNc(1, th, 3, 3, "div", 1), r.ALo(2, "async"), r.YNc(3, eh, 2, 0, "div", 2), r.ALo(4, "async"), r.TgZ(5, "app-filter", 3), r.NdJ("setFilter", function (t) { return e.onSetFilter(t) }), r.qZA(), r.TgZ(6, "app-list", 4, 5), r.NdJ("setPage", function (t) { return e.onNextPage(t) }), r.qZA(), r.qZA()), 2 & t && (r.xp6(1), r.Q6J("ngIf", r.lcZ(2, 4, e.error$)), r.xp6(2), r.Q6J("ngIf", r.lcZ(4, 6, e.isLoading$)), r.xp6(2), r.Q6J("filterBy", e.filterBy), r.xp6(1), r.Q6J("pokes", e.pokes)) }, directives: [U, Wu, Xu], pipes: [Z], styles: [".mister-dex[_ngcontent-%COMP%]{min-height:68vh;background-color:#373a3a;padding:.875rem}"] }), t })(), rh = (() => { class t { constructor() { } ngOnInit() { } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = r.Xpm({ type: t, selectors: [["app-home"]], decls: 7, vars: 0, consts: [[1, "home-page", "flex"], [1, "img-container"], ["src", "./assets/img/259212-middle.png", "alt", "pokedex"], ["routerLink", "/poke", 1, "btn", "link"]], template: function (t, e) { 1 & t && (r.TgZ(0, "section", 0), r.TgZ(1, "h1"), r._uU(2, "welcome to mister-dex"), r.qZA(), r.TgZ(3, "div", 1), r._UZ(4, "img", 2), r.qZA(), r.TgZ(5, "button", 3), r._uU(6, "see all pokemon"), r.qZA(), r.qZA()) }, directives: [Su], styles: [".home-page[_ngcontent-%COMP%]{flex-direction:column;align-items:center;justify-content:center;min-height:74vh;background-color:#373a3a;padding:1.25rem}.home-page[_ngcontent-%COMP%]   .img-container[_ngcontent-%COMP%]{max-width:265px}.home-page[_ngcontent-%COMP%]   h1[_ngcontent-%COMP%]{font-size:1.625rem;text-transform:capitalize}.home-page[_ngcontent-%COMP%]   .link[_ngcontent-%COMP%]:hover{background-color:#f32746}"] }), t })(), sh = (() => { class t { constructor() { } ngOnInit() { } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = r.Xpm({ type: t, selectors: [["app-about"]], decls: 2, vars: 0, template: function (t, e) { 1 & t && (r.TgZ(0, "p"), r._uU(1, "app-about works!"), r.qZA()) }, styles: [""] }), t })(); function ih(t, e) { if (1 & t && (r.TgZ(0, "span"), r._uU(1), r.qZA()), 2 & t) { const t = r.oxw(); r.Tol(null == t.poke || null == t.poke.types[1] || null == t.poke.types[1].type ? null : t.poke.types[1].type.name), r.xp6(1), r.Oqu(null == t.poke || null == t.poke.types[1] || null == t.poke.types[1].type ? null : t.poke.types[1].type.name) } } let oh = (() => { class t { constructor(t, e, n) { this.route = t, this.router = e, this.store = n, this.doneSub = this.store.select("pokeState").pipe((0, Gu.j)("isDone")).subscribe(t => { t && this.router.navigateByUrl("/poke") }) } ngOnInit() { var t = this; return No(function* () { t.subs = t.route.data.subscribe(e => t.poke = e.poke) })() } removePoke(t) { console.log("pokeApp: dispatching remove"), this.store.dispatch(new Eo(t)) } goToEditPage(t) { this.router.navigateByUrl(`/poke/edit/${t}`) } goBack() { this.router.navigateByUrl("/poke") } ngOnDestroy() { this.subs.unsubscribe(), this.doneSub.unsubscribe() } } return t.\u0275fac = function (e) { return new (e || t)(r.Y36(tc), r.Y36(Eu), r.Y36(ii.yh)) }, t.\u0275cmp = r.Xpm({ type: t, selectors: [["app-details"]], decls: 46, vars: 27, consts: [[1, "pokemon"], [1, "content-container", "grid"], [1, "img-container", "grid"], [1, "normal-front", "flex"], [3, "src", "alt"], [1, "normal-back"], [1, "shiny-front", "flex"], [1, "shiny-front"], [1, "details-container"], [1, "type", "flex"], [3, "class", 4, "ngIf"], [1, "btn-container", "flex"], [1, "btn", "back", 3, "click"], [1, "btn", "edit", 3, "click"], [1, "btn", "delete", 3, "click"]], template: function (t, e) { 1 & t && (r.TgZ(0, "article", 0), r.TgZ(1, "div", 1), r.TgZ(2, "div", 2), r.TgZ(3, "div", 3), r._UZ(4, "img", 4), r.qZA(), r.TgZ(5, "div", 5), r._UZ(6, "img", 4), r.qZA(), r.TgZ(7, "div", 6), r._UZ(8, "img", 4), r.qZA(), r.TgZ(9, "div", 7), r._UZ(10, "img", 4), r.qZA(), r.qZA(), r.TgZ(11, "div", 8), r.TgZ(12, "h2"), r._uU(13), r.qZA(), r.TgZ(14, "span"), r._uU(15), r.qZA(), r.TgZ(16, "span"), r._uU(17), r.qZA(), r.TgZ(18, "div", 9), r.TgZ(19, "span"), r._uU(20, "type: "), r.qZA(), r.TgZ(21, "span"), r._uU(22), r.qZA(), r.YNc(23, ih, 2, 3, "span", 10), r.qZA(), r.TgZ(24, "h2"), r._uU(25, "basic stats"), r.qZA(), r.TgZ(26, "span"), r._uU(27), r.qZA(), r.TgZ(28, "span"), r._uU(29), r.qZA(), r.TgZ(30, "span"), r._uU(31), r.qZA(), r.TgZ(32, "span"), r._uU(33), r.qZA(), r._UZ(34, "br"), r.TgZ(35, "span"), r._uU(36), r.qZA(), r.TgZ(37, "span"), r._uU(38), r.qZA(), r.qZA(), r.TgZ(39, "div", 11), r.TgZ(40, "button", 12), r.NdJ("click", function () { return e.goBack() }), r._uU(41, "go back"), r.qZA(), r.TgZ(42, "button", 13), r.NdJ("click", function () { return e.goToEditPage(e.poke.name) }), r._uU(43, "edit"), r.qZA(), r.TgZ(44, "button", 14), r.NdJ("click", function () { return e.removePoke(e.poke.id) }), r._uU(45, "delete"), r.qZA(), r.qZA(), r.qZA(), r.qZA()), 2 & t && (r.xp6(4), r.Q6J("src", e.poke.sprites.front_default, r.LSH)("alt", e.poke.name), r.xp6(2), r.Q6J("src", e.poke.sprites.back_default, r.LSH)("alt", e.poke.name), r.xp6(2), r.Q6J("src", e.poke.sprites.front_shiny, r.LSH)("alt", e.poke.name), r.xp6(2), r.Q6J("src", e.poke.sprites.back_shiny, r.LSH)("alt", e.poke.name), r.xp6(3), r.Oqu(e.poke.name), r.xp6(2), r.hij("height: ", e.poke.height, '"'), r.xp6(2), r.hij("weight: ", e.poke.weight, '"'), r.xp6(4), r.Tol(null == e.poke || null == e.poke.types[0] || null == e.poke.types[0].type ? null : e.poke.types[0].type.name), r.xp6(1), r.Oqu(null == e.poke || null == e.poke.types[0] || null == e.poke.types[0].type ? null : e.poke.types[0].type.name), r.xp6(1), r.Q6J("ngIf", null == e.poke ? null : e.poke.types[1]), r.xp6(4), r.AsE(" ", null == e.poke || null == e.poke.stats[0] ? null : e.poke.stats[0].stat.name, ": ", null == e.poke || null == e.poke.stats[0] ? null : e.poke.stats[0].base_stat, ", "), r.xp6(2), r.AsE(" ", null == e.poke || null == e.poke.stats[1] ? null : e.poke.stats[1].stat.name, ": ", null == e.poke || null == e.poke.stats[1] ? null : e.poke.stats[1].base_stat, ", "), r.xp6(2), r.AsE(" ", null == e.poke || null == e.poke.stats[2] ? null : e.poke.stats[2].stat.name, ": ", null == e.poke || null == e.poke.stats[2] ? null : e.poke.stats[2].base_stat, ", "), r.xp6(2), r.AsE(" ", null == e.poke || null == e.poke.stats[3] ? null : e.poke.stats[3].stat.name, ": ", null == e.poke || null == e.poke.stats[3] ? null : e.poke.stats[3].base_stat, ", "), r.xp6(3), r.AsE(" ", null == e.poke || null == e.poke.stats[4] ? null : e.poke.stats[4].stat.name, ": ", null == e.poke || null == e.poke.stats[4] ? null : e.poke.stats[4].base_stat, ", "), r.xp6(2), r.AsE(" ", null == e.poke || null == e.poke.stats[5] ? null : e.poke.stats[5].stat.name, ": ", null == e.poke || null == e.poke.stats[5] ? null : e.poke.stats[5].base_stat, " ")) }, directives: [U], styles: [".pokemon[_ngcontent-%COMP%]{padding-block:1rem}.pokemon[_ngcontent-%COMP%]   .content-container[_ngcontent-%COMP%]{grid-template-columns:repeat(5,1fr);grid-template-rows:repeat(2,1fr)}.pokemon[_ngcontent-%COMP%]   .content-container[_ngcontent-%COMP%]   .img-container[_ngcontent-%COMP%]{grid-column:1/-1;grid-row:1/2;justify-items:center;align-items:center;grid-template-columns:repeat(auto-fit,minmax(200px,auto))}.pokemon[_ngcontent-%COMP%]   .content-container[_ngcontent-%COMP%]   .img-container[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{object-fit:cover}.pokemon[_ngcontent-%COMP%]   .content-container[_ngcontent-%COMP%]   .img-container[_ngcontent-%COMP%]   .normal-back[_ngcontent-%COMP%], .pokemon[_ngcontent-%COMP%]   .content-container[_ngcontent-%COMP%]   .img-container[_ngcontent-%COMP%]   .normal-front[_ngcontent-%COMP%], .pokemon[_ngcontent-%COMP%]   .content-container[_ngcontent-%COMP%]   .img-container[_ngcontent-%COMP%]   .shiny-back[_ngcontent-%COMP%], .pokemon[_ngcontent-%COMP%]   .content-container[_ngcontent-%COMP%]   .img-container[_ngcontent-%COMP%]   .shiny-front[_ngcontent-%COMP%]{width:100%}.pokemon[_ngcontent-%COMP%]   .content-container[_ngcontent-%COMP%]   .details-container[_ngcontent-%COMP%]{grid-row:2/3;grid-column:1/4}.pokemon[_ngcontent-%COMP%]   .content-container[_ngcontent-%COMP%]   .details-container[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%]{font-size:1.375rem;text-transform:capitalize}.pokemon[_ngcontent-%COMP%]   .content-container[_ngcontent-%COMP%]   .details-container[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%]:last-of-type{margin-block-start:.9375rem}.pokemon[_ngcontent-%COMP%]   .content-container[_ngcontent-%COMP%]   .details-container[_ngcontent-%COMP%] > span[_ngcontent-%COMP%]{color:#ccc1c1;margin-inline-end:.875rem}.pokemon[_ngcontent-%COMP%]   .content-container[_ngcontent-%COMP%]   .btn-container[_ngcontent-%COMP%]{flex-direction:column;grid-column:4/6;grid-row:2/3}.pokemon[_ngcontent-%COMP%]   .content-container[_ngcontent-%COMP%]   .btn-container[_ngcontent-%COMP%]   *[_ngcontent-%COMP%]{margin-block-start:.625rem}.pokemon[_ngcontent-%COMP%]   .content-container[_ngcontent-%COMP%]   .btn-container[_ngcontent-%COMP%]   .edit[_ngcontent-%COMP%]{background-color:#1e2020;transition:.2s ease-in-out}.pokemon[_ngcontent-%COMP%]   .content-container[_ngcontent-%COMP%]   .btn-container[_ngcontent-%COMP%]   .edit[_ngcontent-%COMP%]:hover{background-color:#2a2d2d}.pokemon[_ngcontent-%COMP%]   .content-container[_ngcontent-%COMP%]   .btn-container[_ngcontent-%COMP%]   .back[_ngcontent-%COMP%]{background-color:#1e2020;transition:.2s ease-in-out}.pokemon[_ngcontent-%COMP%]   .content-container[_ngcontent-%COMP%]   .btn-container[_ngcontent-%COMP%]   .back[_ngcontent-%COMP%]:hover{background-color:#2a2d2d}.pokemon[_ngcontent-%COMP%]   .content-container[_ngcontent-%COMP%]   .btn-container[_ngcontent-%COMP%]   .delete[_ngcontent-%COMP%]{transition:.2s ease-in-out}.pokemon[_ngcontent-%COMP%]   .content-container[_ngcontent-%COMP%]   .btn-container[_ngcontent-%COMP%]   .delete[_ngcontent-%COMP%]:hover{background-color:#f32746}@media screen and (max-width:770px){.pokemon[_ngcontent-%COMP%]   .content-container[_ngcontent-%COMP%]{grid-template-rows:repeat(auto,250px);grid-template-columns:repeat(1,1fr);align-items:center}.pokemon[_ngcontent-%COMP%]   .content-container[_ngcontent-%COMP%]   .btn-container[_ngcontent-%COMP%]{grid-column:1/6;grid-row:3/4;flex-direction:row}.pokemon[_ngcontent-%COMP%]   .content-container[_ngcontent-%COMP%]   .btn-container[_ngcontent-%COMP%]   button[_ngcontent-%COMP%], .pokemon[_ngcontent-%COMP%]   .content-container[_ngcontent-%COMP%]   .btn-container[_ngcontent-%COMP%]   button.edit[_ngcontent-%COMP%]{width:100%;margin-inline-end:.625rem}}@media screen and (max-width:595px){.pokemon[_ngcontent-%COMP%]   .content-container[_ngcontent-%COMP%]{display:flex;flex-direction:column}.pokemon[_ngcontent-%COMP%]   .content-container[_ngcontent-%COMP%]   .img-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;width:100%}.pokemon[_ngcontent-%COMP%]   .content-container[_ngcontent-%COMP%]   .btn-container[_ngcontent-%COMP%]{margin-block-start:.5rem;width:100%;flex-direction:column}}"] }), t })(), ah = (() => { class t { constructor(t) { this.PokeService = t } resolve(t) { const { name: e } = t.params; return console.log("RESOLVE", this.PokeService.getByName(e)), this.PokeService.getByName(e) } } return t.\u0275fac = function (e) { return new (e || t)(r.LFG(Go)) }, t.\u0275prov = r.Yz7({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); function lh(t, e) { 1 & t && (r.TgZ(0, "div"), r._uU(1, "Loading......."), r.qZA()) } function ch(t, e) { if (1 & t) { const t = r.EpF(); r.TgZ(0, "section", 2), r.TgZ(1, "form", 3), r.NdJ("ngSubmit", function () { return r.CHM(t), r.oxw().onUpDatePokemon() }), r.TgZ(2, "label", 4), r._uU(3, " Pokemon name "), r.qZA(), r.TgZ(4, "input", 5), r.NdJ("ngModelChange", function (e) { return r.CHM(t), r.oxw().pokeName = e }), r.qZA(), r.TgZ(5, "button", 6), r._uU(6, "Save"), r.qZA(), r.qZA(), r.qZA() } if (2 & t) { const t = r.oxw(); r.xp6(4), r.Q6J("ngModel", t.pokeName) } } const uh = [{ path: "poke/edit/:name", component: (() => { class t { constructor(t, e, n) { this.store = t, this.route = e, this.router = n, this.poke$ = this.store.select("pokeState").pipe((0, Gu.j)("poke")) } ngOnInit() { this.subs = this.route.data.subscribe(t => { this.poke = t.poke }), this.subs = this.route.params.subscribe(t => { this.pokeName = t.name }), this.store.dispatch(new wo(this.pokeName)), this.poke$.subscribe(t => { this.poke = t }) } onUpDatePokemon() { const t = Object.assign(Object.assign({}, this.poke), { name: this.pokeName }); this.store.dispatch(new Co(t)), this.router.navigateByUrl("/") } ngOnDestroy() { this.subs.unsubscribe() } } return t.\u0275fac = function (e) { return new (e || t)(r.Y36(ii.yh), r.Y36(tc), r.Y36(Eu)) }, t.\u0275cmp = r.Xpm({ type: t, selectors: [["app-edit"]], decls: 2, vars: 2, consts: [[4, "ngIf"], ["class", "app-edit flex", 4, "ngIf"], [1, "app-edit", "flex"], [1, "flex", 3, "ngSubmit"], ["for", "name"], ["type", "text", "name", "name", 3, "ngModel", "ngModelChange"], [1, "btn"]], template: function (t, e) { 1 & t && (r.YNc(0, lh, 2, 0, "div", 0), r.YNc(1, ch, 7, 1, "section", 1)), 2 & t && (r.Q6J("ngIf", !e.poke), r.xp6(1), r.Q6J("ngIf", e.poke)) }, directives: [U, Pe, re, Ce, Bt, ne, Te], styles: [".app-edit[_ngcontent-%COMP%]{min-height:80vh;align-items:center;justify-content:center}.app-edit[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{flex-direction:column;width:50%}.app-edit[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]   [_ngcontent-%COMP%]:not(:first-child){margin-block-start:.625rem}.app-edit[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{padding:.5rem .6875rem;outline:none;border:none;border-radius:.5rem;font-size:1.125rem}.app-edit[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]   label[_ngcontent-%COMP%]{font-size:1.375rem}.app-edit[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:hover{background-color:#f32746}"] }), t })(), resolve: { poke: ah } }, { path: "poke/:name", component: oh, resolve: { poke: ah } }, { path: "poke", component: nh }, { path: "about", component: sh }, { path: "home", component: rh }, { path: "", redirectTo: "/home", pathMatch: "full" }]; let hh = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = r.oAB({ type: t }), t.\u0275inj = r.cJS({ imports: [[Fu.forRoot(uh)], Fu] }), t })(); const dh = function () { return { exact: !0 } }; let ph = (() => { class t { constructor() { this.isOpen = !1 } ngOnInit() { } onToggleMenu() { this.isOpen = !this.isOpen } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = r.Xpm({ type: t, selectors: [["app-header"]], decls: 12, vars: 4, consts: [[1, "flex", "full"], [1, "nav-bar", "flex"], [1, "links-container", "flex"], ["routerLink", ""], [1, "flex"], ["routerLinkActive", "active", "routerLink", "/home", 3, "routerLinkActiveOptions"], ["routerLinkActive", "active", "routerLink", "/poke", 3, "routerLinkActiveOptions"]], template: function (t, e) { 1 & t && (r.TgZ(0, "header", 0), r.TgZ(1, "nav", 1), r.TgZ(2, "div", 2), r.TgZ(3, "h1", 3), r._uU(4, "Mister-Dex"), r.qZA(), r.TgZ(5, "ul", 4), r.TgZ(6, "a", 5), r.TgZ(7, "li"), r._uU(8, "Home"), r.qZA(), r.qZA(), r.TgZ(9, "a", 6), r.TgZ(10, "li"), r._uU(11, "PokeDex"), r.qZA(), r.qZA(), r.qZA(), r.qZA(), r.qZA(), r.qZA()), 2 & t && (r.xp6(6), r.Q6J("routerLinkActiveOptions", r.DdM(2, dh)), r.xp6(3), r.Q6J("routerLinkActiveOptions", r.DdM(3, dh))) }, directives: [Su, Cu, Ou], styles: ["header[_ngcontent-%COMP%]{padding:1.875rem;background-color:#1e2020;justify-content:center}header[_ngcontent-%COMP%]   .active[_ngcontent-%COMP%]{color:#db0c2c}header[_ngcontent-%COMP%]   .nav-bar[_ngcontent-%COMP%]{min-width:80%;align-items:center}header[_ngcontent-%COMP%]   .nav-bar[_ngcontent-%COMP%]   .links-container[_ngcontent-%COMP%]{width:100%;justify-content:space-between}header[_ngcontent-%COMP%]   .nav-bar[_ngcontent-%COMP%]   .links-container[_ngcontent-%COMP%]   h1[_ngcontent-%COMP%]{cursor:pointer}header[_ngcontent-%COMP%]   .nav-bar[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%]{align-items:center}header[_ngcontent-%COMP%]   .nav-bar[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%]   [_ngcontent-%COMP%]:not(:last-child){margin-inline-end:1.125rem}"] }), t })(), fh = (() => { class t { constructor() { } ngOnInit() { } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = r.Xpm({ type: t, selectors: [["app-footer"]], decls: 3, vars: 0, consts: [[1, "flex", "full"]], template: function (t, e) { 1 & t && (r.TgZ(0, "footer", 0), r.TgZ(1, "h1"), r._uU(2, "CofeeRights"), r.qZA(), r.qZA()) }, styles: ["footer[_ngcontent-%COMP%]{padding:.625rem;align-items:center;justify-content:center;background-color:#1e2020}"] }), t })(), gh = (() => { class t { constructor() { this.title = "Mister Dex" } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = r.Xpm({ type: t, selectors: [["app-root"]], decls: 5, vars: 0, consts: [[1, "main-container"], [1, "full"], [1, "flex", "full"]], template: function (t, e) { 1 & t && (r.TgZ(0, "div", 0), r._UZ(1, "app-header", 1), r.TgZ(2, "main"), r._UZ(3, "router-outlet"), r.qZA(), r._UZ(4, "app-footer", 2), r.qZA()) }, directives: [ph, Tu, fh], encapsulation: 2 }), t })(), mh = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = r.oAB({ type: t, bootstrap: [gh] }), t.\u0275inj = r.cJS({ providers: [], imports: [[kt, hh, si, ga, Ue, Ss, ii.Aw.forRoot(To, { metaReducers: Po, runtimeChecks: { strictActionImmutability: !0, strictStateImmutability: !0 } }), io.FT.instrument({ maxAge: 25, logOnly: !0 }), no.forRoot([Zo])]] }), t })(); (0, r.G48)(), Tt().bootstrapModule(mh).catch(t => console.error(t)) } }, t => { "use strict"; t(t.s = 5252) }]);